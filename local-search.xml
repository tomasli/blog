<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>Leetcode 238 - 除自身以外数组的乘积</title>
    <link href="/2020/06/04/leetcode-238/"/>
    <url>/2020/06/04/leetcode-238/</url>
    
    <content type="html"><![CDATA[<p>题目：<br>来自每日一题</p><pre><code class="hljs quote">给你一个长度为 n 的整数数组 nums，其中 n &gt; 1，返回输出数组 output ，其中 output[i] 等于 nums 中除 nums[i] 之外其余各元素的乘积。提示：题目数据保证数组之中任意元素的全部前缀元素和后缀（甚至是整个数组）的乘积都在 32 位整数范围内。说明: 请不要使用除法，且在 O(n) 时间复杂度内完成此题。进阶：你可以在常数空间复杂度内完成这个题目吗？（ 出于对空间复杂度分析的目的，输出数组不被视为额外空间。）</code></pre><p>限制太多了吧。想的是全乘完了各自除一下，但明确不让除，这咋整<br>可以算每个值左边所有数的乘积*右边所有数的乘积，这个可以用二维dp数组来搞，但是空间和时间复杂度都超了<br>可以不二维dp，因为乘积不用保存中间的，只需要保存从头开始和从尾开始的就够了，三个循环，用dict存</p><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span><span class="hljs-params">(object)</span>:</span>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">productExceptSelf</span><span class="hljs-params">(self, nums)</span>:</span>        <span class="hljs-string">"""</span><span class="hljs-string">        :type nums: List[int]</span><span class="hljs-string">        :rtype: List[int]</span><span class="hljs-string">        """</span>        <span class="hljs-keyword">if</span> len(nums) == <span class="hljs-number">1</span>:            <span class="hljs-keyword">return</span> nums        length = len(nums)        dict = &#123;&#125;        res = []        dict[(<span class="hljs-number">0</span>,<span class="hljs-number">0</span>)] = <span class="hljs-number">1</span>        dict[(length, length<span class="hljs-number">-1</span>)] = <span class="hljs-number">1</span>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> xrange(length<span class="hljs-number">-1</span>):            dict[(<span class="hljs-number">0</span>, i+<span class="hljs-number">1</span>)] = dict[(<span class="hljs-number">0</span>, i)]*nums[i]        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> xrange(length<span class="hljs-number">-1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">-1</span>):            dict[(i, length<span class="hljs-number">-1</span>)] = dict[(i+<span class="hljs-number">1</span>, length<span class="hljs-number">-1</span>)]*nums[i]        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> xrange(length):            res.append(dict[(<span class="hljs-number">0</span>,i)]*dict[(i+<span class="hljs-number">1</span>, length<span class="hljs-number">-1</span>)])        <span class="hljs-keyword">return</span> res</code></pre><p>来回调边界值，两头的边界值还标准不太一样，只战胜了5%的答案。。。<br>看答案<br>我慢是因为创建的是dict，比他们用的双数组慢点，一个思路<br>空间为常数神奇了<br>用结果数组先保存左边的乘积，然后用一个常量保存右边的乘积，然后从右往左挨个算，常量乘积也跟着变化</p><p>这个题回头还可以回来做做</p>]]></content>
    
    
    <categories>
      
      <category>Leetcode</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Leetcode 283 - 移动零</title>
    <link href="/2020/06/03/leetcode-283/"/>
    <url>/2020/06/03/leetcode-283/</url>
    
    <content type="html"><![CDATA[<p>题目：<br>来自热题100</p><pre><code class="hljs quote">给定一个数组 nums，编写一个函数将所有 0 移动到数组的末尾，同时保持非零元素的相对顺序。必须在原数组上操作，不能拷贝额外的数组。尽量减少操作次数。</code></pre><p>原数组操作，不能再搞一个<br>数组里元素交换就好，只要要移动非0的，这些步骤省不了，只是每个要移动的非0直接移到它应在的位置就是了</p><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span><span class="hljs-params">(object)</span>:</span>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">moveZeroes</span><span class="hljs-params">(self, nums)</span>:</span>        <span class="hljs-string">"""</span><span class="hljs-string">        :type nums: List[int]</span><span class="hljs-string">        :rtype: None Do not return anything, modify nums in-place instead.</span><span class="hljs-string">        """</span>        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> nums <span class="hljs-keyword">or</span> len(nums) == <span class="hljs-number">1</span>:            <span class="hljs-keyword">return</span>         <span class="hljs-comment"># 偏移值</span>        offset = <span class="hljs-number">0</span>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> xrange(len(nums)):            <span class="hljs-keyword">if</span> nums[i] == <span class="hljs-number">0</span>:                offset += <span class="hljs-number">1</span>            <span class="hljs-comment"># 直接else挂了，因为会把本来不需要移位置的都设成0</span>            <span class="hljs-comment"># else:</span>            <span class="hljs-keyword">elif</span> offset != <span class="hljs-number">0</span>:                nums[i-offset] = nums[i]                nums[i] = <span class="hljs-number">0</span></code></pre><p>双指针更容易理解些，i快指针指向当前判断元素，j慢指针停在最前边的0处，一旦i碰到非0，就交换他们的值，j进一步<br>类似快速排序。快速排序也要复习下</p>]]></content>
    
    
    <categories>
      
      <category>Leetcode</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Leetcode 538 - 把二叉搜索树转换为累加树</title>
    <link href="/2020/06/03/leetcode-538/"/>
    <url>/2020/06/03/leetcode-538/</url>
    
    <content type="html"><![CDATA[<p>题目：<br>来自热题100</p><pre><code class="hljs quote">给定一个二叉搜索树（Binary Search Tree），把它转换成为累加树（Greater Tree使得每个节点的值是原来的节点值加上所有大于它的节点值之和。</code></pre><p>二叉搜索树，是所有左子节点小于父节点小于所有右子节点<br>那么要累加，就是从最右下角的节点开始遍历加总一个值到所有其它元素呗，中序深度遍历反过来。 递归或迭代。 写个递归吧</p><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span><span class="hljs-params">(object)</span>:</span>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">convertBST</span><span class="hljs-params">(self, root)</span>:</span>        <span class="hljs-string">"""</span><span class="hljs-string">        :type root: TreeNode</span><span class="hljs-string">        :rtype: TreeNode</span><span class="hljs-string">        """</span>        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> root <span class="hljs-keyword">or</span> (<span class="hljs-keyword">not</span> root.right <span class="hljs-keyword">and</span> <span class="hljs-keyword">not</span> root.left):            <span class="hljs-keyword">return</span> root        <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">subproblem</span><span class="hljs-params">(node, cur_sum=<span class="hljs-number">0</span>)</span>:</span>            <span class="hljs-comment"># 写错了。。。查了好会儿</span>            <span class="hljs-comment"># if not node.right and not root.left:</span>            <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> node.right <span class="hljs-keyword">and</span> <span class="hljs-keyword">not</span> node.left:                            node.val += cur_sum                <span class="hljs-keyword">return</span> node.val            <span class="hljs-comment"># 这里如果没右孩子应该将右边和设为cur_sum，不是0</span>            <span class="hljs-comment"># right_sum = subproblem(node.right, cur_sum) if node.right else 0</span>            right_sum = subproblem(node.right, cur_sum) <span class="hljs-keyword">if</span> node.right <span class="hljs-keyword">else</span> cur_sum            node.val += right_sum            <span class="hljs-keyword">return</span> subproblem(node.left, node.val) <span class="hljs-keyword">if</span> node.left <span class="hljs-keyword">else</span> node.val        <span class="hljs-comment"># 不是直接返回root不执行递归，也不是返回递归，而是递归后返回根节点</span>        <span class="hljs-comment"># return root</span>        <span class="hljs-comment"># return subproblem(root)</span>        subproblem(root)        <span class="hljs-keyword">return</span> root</code></pre><p>这个遍历还是可以进入到node == None的，把和拿到外边形式上还简单点</p>]]></content>
    
    
    <categories>
      
      <category>Leetcode</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Leetcode 21 - 合并两个有序链表</title>
    <link href="/2020/06/03/leetcode-21/"/>
    <url>/2020/06/03/leetcode-21/</url>
    
    <content type="html"><![CDATA[<p>题目：<br>来自热题100</p><pre><code class="hljs quote">将两个升序链表合并为一个新的 升序 链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的。</code></pre><p>维护两个指针就好了吧</p><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span><span class="hljs-params">(object)</span>:</span>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">mergeTwoLists</span><span class="hljs-params">(self, l1, l2)</span>:</span>        <span class="hljs-string">"""</span><span class="hljs-string">        :type l1: ListNode</span><span class="hljs-string">        :type l2: ListNode</span><span class="hljs-string">        :rtype: ListNode</span><span class="hljs-string">        """</span>        res = <span class="hljs-literal">None</span>        cur = <span class="hljs-literal">None</span>        <span class="hljs-keyword">while</span> l1 <span class="hljs-keyword">or</span> l2:            <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> l1:                <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> cur:                    cur = l2                <span class="hljs-keyword">else</span>:                    cur.next = l2                <span class="hljs-comment"># 另两个地方缺了这句</span>                l2 = <span class="hljs-literal">None</span>            <span class="hljs-keyword">elif</span> <span class="hljs-keyword">not</span> l2:                <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> cur:                    cur = l1                <span class="hljs-keyword">else</span>:                    cur.next = l1                l1 = <span class="hljs-literal">None</span>            <span class="hljs-keyword">elif</span> l1.val &lt;= l2.val:                <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> cur:                    cur = ListNode(l1.val)                <span class="hljs-keyword">else</span>:                    cur.next = ListNode(l1.val)                    <span class="hljs-comment"># 2个地方缺了这句</span>                    cur = cur.next                l1 = l1.next            <span class="hljs-keyword">elif</span> l1.val &gt; l2.val:                <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> cur:                    cur = ListNode(l2.val)                <span class="hljs-keyword">else</span>:                    cur.next = ListNode(l2.val)                    cur = cur.next                l2 = l2.next            <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> res:                res = cur        <span class="hljs-keyword">return</span> res</code></pre><p>以为新建结构省事，其实看看还不如说，把l2叉在l1里更简明写<br>答案很简明，在更头上建一个节点然后最终返回这个节点的next就好了。l1或l2跑完了的情况拿到while外边来单独解决<br>我总是陷入起始状态的纠结里出不来<br>递归也很简单，把两个链表剩下的东西传进去</p>]]></content>
    
    
    <categories>
      
      <category>Leetcode</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Leetcode 169 - 多数元素</title>
    <link href="/2020/06/03/leetcode-169/"/>
    <url>/2020/06/03/leetcode-169/</url>
    
    <content type="html"><![CDATA[<p>题目：<br>来自热题100</p><pre><code class="hljs quote">给定一个大小为 n 的数组，找到其中的多数元素。多数元素是指在数组中出现次数大于 ⌊ n&#x2F;2 ⌋ 的元素。你可以假设数组是非空的，并且给定的数组总是存在多数元素。</code></pre><p>数组中多于一半的元素。 排序后中间那个数就是呗</p><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span><span class="hljs-params">(object)</span>:</span>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">majorityElement</span><span class="hljs-params">(self, nums)</span>:</span>        <span class="hljs-string">"""</span><span class="hljs-string">        :type nums: List[int]</span><span class="hljs-string">        :rtype: int</span><span class="hljs-string">        """</span>        nums.sort()        <span class="hljs-keyword">return</span> nums[len(nums)/<span class="hljs-number">2</span>]</code></pre><p>这题方法巨多，我这只是较好的，值得后边回来再行研究</p>]]></content>
    
    
    <categories>
      
      <category>Leetcode</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Leetcode 206 - 反转链表</title>
    <link href="/2020/06/03/leetcode-206/"/>
    <url>/2020/06/03/leetcode-206/</url>
    
    <content type="html"><![CDATA[<p>题目：<br>来自热题100</p><pre><code class="hljs quote">反转一个单链表。进阶:你可以迭代或递归地反转链表。你能否用两种方法解决这道题？</code></pre><p><del>简单，两个都写写呗</del></p><p>以为好写，好不容易挤出一个栈的写法</p><pre><code class="hljs python"><span class="hljs-comment"># Definition for singly-linked list.</span><span class="hljs-comment"># class ListNode(object):</span><span class="hljs-comment">#     def __init__(self, x):</span><span class="hljs-comment">#         self.val = x</span><span class="hljs-comment">#         self.next = None</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span><span class="hljs-params">(object)</span>:</span>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">reverseList</span><span class="hljs-params">(self, head)</span>:</span>        <span class="hljs-string">"""</span><span class="hljs-string">        :type head: ListNode</span><span class="hljs-string">        :rtype: ListNode</span><span class="hljs-string">        """</span>        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> head:            <span class="hljs-keyword">return</span>        stack = []        stack.append(head)        <span class="hljs-keyword">while</span> <span class="hljs-literal">True</span>:            <span class="hljs-keyword">if</span> stack[<span class="hljs-number">-1</span>].next:                stack.append(stack[<span class="hljs-number">-1</span>].next)            <span class="hljs-keyword">else</span>:                reverseList = stack.pop()                res = reverseList                <span class="hljs-keyword">break</span>        <span class="hljs-keyword">while</span> stack:            reverseList.next = stack.pop()            reverseList = reverseList.next            reverseList.next = <span class="hljs-literal">None</span>        <span class="hljs-keyword">return</span> res</code></pre><p>写了个差不多的，在看了题解后终于找到关键点了</p><pre><code class="hljs python"><span class="hljs-comment"># Definition for singly-linked list.</span><span class="hljs-comment"># class ListNode(object):</span><span class="hljs-comment">#     def __init__(self, x):</span><span class="hljs-comment">#         self.val = x</span><span class="hljs-comment">#         self.next = None</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span><span class="hljs-params">(object)</span>:</span>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">reverseList</span><span class="hljs-params">(self, head)</span>:</span>        <span class="hljs-string">"""</span><span class="hljs-string">        :type head: ListNode</span><span class="hljs-string">        :rtype: ListNode</span><span class="hljs-string">        """</span>        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> head:            <span class="hljs-keyword">return</span>        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> head.next:            <span class="hljs-keyword">return</span> head        preNode = head        resNode = preNode.next        preNode.next = <span class="hljs-literal">None</span>        <span class="hljs-keyword">while</span> resNode:            holder = resNode.next            resNode.next = preNode            preNode = resNode            resNode = holder        <span class="hljs-comment"># 这里 resNode是None啊，应该返回</span>        <span class="hljs-comment"># return resNode</span>        <span class="hljs-keyword">return</span> preNode</code></pre><p>再挤一挤迭代。。看了答案。也对，迭代只管当前步骤而不论剩下的部分到底怎么进去的<br>先递归进入下层，再处理当前层的事。其实比二叉树还简单点，怎么一点也想不出来呢</p><pre><code class="hljs python"><span class="hljs-comment"># Definition for singly-linked list.</span><span class="hljs-comment"># class ListNode(object):</span><span class="hljs-comment">#     def __init__(self, x):</span><span class="hljs-comment">#         self.val = x</span><span class="hljs-comment">#         self.next = None</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span><span class="hljs-params">(object)</span>:</span>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">reverseList</span><span class="hljs-params">(self, head)</span>:</span>        <span class="hljs-string">"""</span><span class="hljs-string">        :type head: ListNode</span><span class="hljs-string">        :rtype: ListNode</span><span class="hljs-string">        """</span>        <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">nextNode</span><span class="hljs-params">(node)</span>:</span>            <span class="hljs-comment"># 这个地方要不就是连一个节点也没有，要不就是返回了老链表尾巴，新链表的头</span>            <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> node <span class="hljs-keyword">or</span> <span class="hljs-keyword">not</span> node.next:                <span class="hljs-keyword">return</span> node            <span class="hljs-comment"># 先把后半截反转掉，等于从屁股开始处理</span>            new_head = nextNode(node.next)            <span class="hljs-comment"># 把已经反转的链表后半部分最后一个的指向当前层的节点</span>            node.next.next = node            node.next = <span class="hljs-literal">None</span>            <span class="hljs-comment"># 一层层传递的是新链表头</span>            <span class="hljs-keyword">return</span> new_head    <span class="hljs-comment"># 返回了个啥</span>    <span class="hljs-keyword">return</span> nextNode    <span class="hljs-keyword">return</span> nextNode(head)</code></pre>]]></content>
    
    
    <categories>
      
      <category>Leetcode</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Leetcode 461 - 汉明距离</title>
    <link href="/2020/06/03/leetcode-461/"/>
    <url>/2020/06/03/leetcode-461/</url>
    
    <content type="html"><![CDATA[<p>题目：<br>来自热题100</p><pre><code class="hljs quote">两个整数之间的汉明距离指的是这两个数字对应二进制位不同的位置的数目。给出两个整数 x 和 y，计算它们之间的汉明距离。注意：0 ≤ x, y &lt; 2**31.</code></pre><p>二进制位不同的数目，异或呗，相同等于0，不同等于1<br>注意里的意思，单数字占位4个字节，而且是正数</p><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span><span class="hljs-params">(object)</span>:</span>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">hammingDistance</span><span class="hljs-params">(self, x, y)</span>:</span>        <span class="hljs-string">"""</span><span class="hljs-string">        :type x: int</span><span class="hljs-string">        :type y: int</span><span class="hljs-string">        :rtype: int</span><span class="hljs-string">        """</span>        res = <span class="hljs-number">0</span>        <span class="hljs-comment"># 二进制转换后前两位分别代表正负(0或1)和"b"二进制</span>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> str(bin(x^y))[<span class="hljs-number">2</span>:]:            <span class="hljs-keyword">if</span> i == <span class="hljs-string">"1"</span>:                res += <span class="hljs-number">1</span>        <span class="hljs-keyword">return</span> res</code></pre><p>取巧了，因为昨天刚研究一轮二进制所以知道。看看通常思路<br>bin(x ^ y).count(‘1’)<br>位计数就行…都忘了还有这种函数了</p><p>还可以这样：<br>检查最右位是否为 1，可以使用取模运算（i % 2）或者 AND 操作（i &amp; 1），这两个操作都会屏蔽最右位以外的其他位</p><p>另外：<br>布赖恩·克尼根算法。。。我弃疗</p>]]></content>
    
    
    <categories>
      
      <category>Leetcode</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Leetcode 617 - 合并二叉树</title>
    <link href="/2020/06/03/leetcode-617/"/>
    <url>/2020/06/03/leetcode-617/</url>
    
    <content type="html"><![CDATA[<p>题目：<br>来自热题100</p><pre><code class="hljs quote">给定两个二叉树，想象当你将它们中的一个覆盖到另一个上时，两个二叉树的一些节点便会重叠。你需要将他们合并为一个新的二叉树。合并的规则是如果两个节点重叠，那么将他们的值相加作为节点合并后的新值，否则不为 NULL 的节点将直接作为新二叉树的节点。</code></pre><p>共同进行深度遍历就完了。什么遍历都一样</p><pre><code class="hljs python"><span class="hljs-keyword">import</span> Queue<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span><span class="hljs-params">(object)</span>:</span>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">mergeTrees</span><span class="hljs-params">(self, t1, t2)</span>:</span>        <span class="hljs-string">"""</span><span class="hljs-string">        :type t1: TreeNode</span><span class="hljs-string">        :type t2: TreeNode</span><span class="hljs-string">        :rtype: TreeNode</span><span class="hljs-string">        """</span>        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> t1 <span class="hljs-keyword">and</span> <span class="hljs-keyword">not</span> t2:            <span class="hljs-keyword">return</span> <span class="hljs-literal">None</span>        <span class="hljs-keyword">if</span> t1 <span class="hljs-keyword">and</span> <span class="hljs-keyword">not</span> t2:            <span class="hljs-keyword">return</span> t1        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> t1 <span class="hljs-keyword">and</span> t2:            <span class="hljs-keyword">return</span> t2        stack = []        stack.append((t1, t2))        que = Queue.Queue()        que.put((t1, t2))        <span class="hljs-keyword">while</span> <span class="hljs-keyword">not</span> que.empty():            <span class="hljs-comment"># 输出printh会导致超时</span>            <span class="hljs-comment"># print "size: " + str(que.qsize())</span>            cur = que.get()            <span class="hljs-comment"># print cur</span>            cur[<span class="hljs-number">0</span>].val = cur[<span class="hljs-number">0</span>].val + cur[<span class="hljs-number">1</span>].val            <span class="hljs-keyword">if</span> cur[<span class="hljs-number">0</span>].left <span class="hljs-keyword">and</span> cur[<span class="hljs-number">1</span>].left:                que.put((cur[<span class="hljs-number">0</span>].left, cur[<span class="hljs-number">1</span>].left))            <span class="hljs-comment"># 查了好久，吃完饭才想起来，没事别continue，这样后边那截都没机会跑</span>            <span class="hljs-comment"># elif cur[0].left and not cur[1].left:</span>            <span class="hljs-comment">#     continue</span>            <span class="hljs-keyword">elif</span> <span class="hljs-keyword">not</span> cur[<span class="hljs-number">0</span>].left <span class="hljs-keyword">and</span> cur[<span class="hljs-number">1</span>].left:                cur[<span class="hljs-number">0</span>].left = cur[<span class="hljs-number">1</span>].left            <span class="hljs-keyword">if</span> cur[<span class="hljs-number">0</span>].right <span class="hljs-keyword">and</span> cur[<span class="hljs-number">1</span>].right:                que.put((cur[<span class="hljs-number">0</span>].right, cur[<span class="hljs-number">1</span>].right))            <span class="hljs-comment"># elif cur[0].right and not cur[1].right:</span>            <span class="hljs-comment">#     continue</span>            <span class="hljs-keyword">elif</span> <span class="hljs-keyword">not</span> cur[<span class="hljs-number">0</span>].right <span class="hljs-keyword">and</span> cur[<span class="hljs-number">1</span>].right:                cur[<span class="hljs-number">0</span>].right = cur[<span class="hljs-number">1</span>].right                    <span class="hljs-keyword">return</span> t1</code></pre><p>题本身其实没啥好说的，就是要警醒，状态写的太随意不行，真的容易带入错误</p>]]></content>
    
    
    <categories>
      
      <category>Leetcode</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Leetcode 498 - 对角线遍历</title>
    <link href="/2020/06/03/leetcode-498/"/>
    <url>/2020/06/03/leetcode-498/</url>
    
    <content type="html"><![CDATA[<p>题目：<br>来自探索-二维数组简介</p><pre><code class="hljs quote">给定一个含有 M x N 个元素的矩阵（M 行，N 列），请以对角线遍历的顺序返回这个矩阵中的所有元素，对角线遍历如下图所示。</code></pre><p>这个有点意思，练一练数组遍历的手。 图里就是先向右上的蛇形遍历<br>应该有个标志量来说明目前轮次是向右上还是向左下遍历<br>终结点必然是右下</p><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span><span class="hljs-params">(object)</span>:</span>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">findDiagonalOrder</span><span class="hljs-params">(self, matrix)</span>:</span>        <span class="hljs-string">"""</span><span class="hljs-string">        :type matrix: List[List[int]]</span><span class="hljs-string">        :rtype: List[int]</span><span class="hljs-string">        """</span>        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> matrix:            <span class="hljs-keyword">return</span> []        <span class="hljs-comment"># 奇数轮向右上遍历，偶数轮向左下遍历</span>        flag = <span class="hljs-number">1</span>        res = []        i, j = <span class="hljs-number">0</span>, <span class="hljs-number">0</span>        <span class="hljs-keyword">while</span> i &lt;= len(matrix)<span class="hljs-number">-1</span> <span class="hljs-keyword">and</span> j &lt;= len(matrix[<span class="hljs-number">0</span>])<span class="hljs-number">-1</span>:            res.append(matrix[i][j])            <span class="hljs-comment"># 之前向右上遍历的</span>            <span class="hljs-keyword">if</span> flag%<span class="hljs-number">2</span>:                <span class="hljs-comment"># 如果可以继续向右上走</span>                <span class="hljs-keyword">if</span> i<span class="hljs-number">-1</span> &gt;= <span class="hljs-number">0</span> <span class="hljs-keyword">and</span> j+<span class="hljs-number">1</span>&lt;=len(matrix[<span class="hljs-number">0</span>])<span class="hljs-number">-1</span>:                    i -= <span class="hljs-number">1</span>                    j += <span class="hljs-number">1</span>                <span class="hljs-comment"># 要转向了</span>                <span class="hljs-keyword">else</span>:                    flag += <span class="hljs-number">1</span>                    <span class="hljs-comment"># 右边还有元素，向右一格</span>                    <span class="hljs-keyword">if</span> j+<span class="hljs-number">1</span> &lt;= len(matrix[<span class="hljs-number">0</span>])<span class="hljs-number">-1</span>:                        j += <span class="hljs-number">1</span>                    <span class="hljs-comment"># 右边没元素了，向下走</span>                    <span class="hljs-keyword">else</span>:                        i += <span class="hljs-number">1</span>                <span class="hljs-comment"># # 遍历到第一行了，肯定换方向</span>                <span class="hljs-comment"># if i-1 &lt; 0:</span>                <span class="hljs-comment">#     flag += 1</span>                <span class="hljs-comment">#     # 右边也没更多列了，就该向下走一格</span>                <span class="hljs-comment">#     if j+1 &gt; len(matrix[0])-1:</span>                <span class="hljs-comment">#         i += 1</span>                <span class="hljs-comment">#     # y右边还有元素，向右一格</span>                <span class="hljs-comment">#     else:</span>                <span class="hljs-comment">#         j += 1</span>                <span class="hljs-comment"># # 还可以继续向右上走</span>                <span class="hljs-comment"># else:</span>                <span class="hljs-comment">#     # 但是右边已经没列了，向下一格，也换方向</span>                <span class="hljs-comment">#     if j+1 &gt; len(matrix[0])-1:</span>                <span class="hljs-comment">#         flag += 1</span>                <span class="hljs-comment">#         i += 1</span>                <span class="hljs-comment">#     # 真正可以向右上走</span>                <span class="hljs-comment">#     else:</span>                <span class="hljs-comment">#         i -= 1</span>                <span class="hljs-comment">#         j += 1</span>            <span class="hljs-keyword">else</span>:                <span class="hljs-comment"># 可以继续向左下走</span>                <span class="hljs-keyword">if</span> j<span class="hljs-number">-1</span> &gt;=<span class="hljs-number">0</span>  <span class="hljs-keyword">and</span> i+<span class="hljs-number">1</span>&lt;=len(matrix)<span class="hljs-number">-1</span>:                    i += <span class="hljs-number">1</span>                    j -= <span class="hljs-number">1</span>                <span class="hljs-comment"># 要转向</span>                <span class="hljs-keyword">else</span>:                    flag += <span class="hljs-number">1</span>                    <span class="hljs-comment"># 下方还有元素，向下一格</span>                    <span class="hljs-keyword">if</span> i+<span class="hljs-number">1</span>&lt;=len(matrix)<span class="hljs-number">-1</span>:                        i += <span class="hljs-number">1</span>                    <span class="hljs-comment"># 必须向右了</span>                    <span class="hljs-keyword">else</span>:                        j += <span class="hljs-number">1</span>        <span class="hljs-keyword">return</span> res</code></pre><p>还算顺利吧，中间注释掉的地方是我在开始写的。 if分支里先解决最最主要得部分是简化得关键，比先解决特别情况要更优雅些，代码少点<br>另一种算法是，沿一个方向得对角线遍历，在内层用一个list保存遍历内容，遍历完直接加入结果或者，取反加入结果<br>list.extend() 扩展数组</p>]]></content>
    
    
    <categories>
      
      <category>Leetcode</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Leetcode mian-01-08 零矩阵</title>
    <link href="/2020/06/02/leetcode-mian-01-08/"/>
    <url>/2020/06/02/leetcode-mian-01-08/</url>
    
    <content type="html"><![CDATA[<p>题目：<br>来自探索-二维数组简介</p><pre><code class="hljs quote">编写一种算法，若M × N矩阵中某个元素为0，则将其所在的行与列清零。</code></pre><p>必须先遍历一遍，否则会导致误变很多行列的0</p><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span><span class="hljs-params">(object)</span>:</span>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">setZeroes</span><span class="hljs-params">(self, matrix)</span>:</span>        <span class="hljs-string">"""</span><span class="hljs-string">        :type matrix: List[List[int]]</span><span class="hljs-string">        :rtype: None Do not return anything, modify matrix in-place instead.</span><span class="hljs-string">        """</span>        r_set = set()        c_set = set()        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> xrange(len(matrix)):            <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> xrange(len(matrix[<span class="hljs-number">0</span>])):                <span class="hljs-keyword">if</span> matrix[i][j] == <span class="hljs-number">0</span>:                    r_set.add(i)                    c_set.add(j)        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> r_set:            <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> xrange(len(matrix[<span class="hljs-number">0</span>])):                matrix[i][j] = <span class="hljs-number">0</span>        <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> c_set:            <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> xrange(len(matrix)):                matrix[i][j] = <span class="hljs-number">0</span></code></pre><p>这道题怎么就中等难度了。。。一下就写完了。不用回来看</p>]]></content>
    
    
    <categories>
      
      <category>Leetcode</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Leetcode mian-64 - 求1+2+…+n</title>
    <link href="/2020/06/02/leetcode-mian-64/"/>
    <url>/2020/06/02/leetcode-mian-64/</url>
    
    <content type="html"><![CDATA[<p>题目：<br>来自每日一题</p><pre><code class="hljs quote">&quot;求 1+2+...+n ，要求不能使用乘除法、for、while、if、else、switch、case等关键字及条件判断语句（A?B:C）。&quot;</code></pre><p>不能使用判断语句的叠加，就是取中间值的倍数呗。但要判断一下是奇数还是偶数个数字<br>我去，没看到不能使用乘除法，条件判断语句。这样怎么玩。递归吧。递归结束条件也得要if啊。。建个list来判断结束好了<br>只能加加加呗</p><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span><span class="hljs-params">(object)</span>:</span>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">sumNums</span><span class="hljs-params">(self, n)</span>:</span>        <span class="hljs-string">"""</span><span class="hljs-string">        :type n: int</span><span class="hljs-string">        :rtype: int</span><span class="hljs-string">        """</span>        list_nums = list(n)        <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">subproblem</span><span class="hljs-params">(n)</span>:</span>        <span class="hljs-keyword">return</span> n + sum</code></pre><p>写不出来，感觉完全是个智力题，和编程关系不大<br>三元运算符是题目允许的，但是python常用的还是”if else”<br>其实也有别的写法但是不适合用在项目里，这样：</p><pre><code class="hljs quote">print(&#123;True: &quot;More&quot;, False: &quot;Less&quot;&#125;[a &gt; b]) # 运行结果为：Lessprint((&quot;FalseValue&quot;, &quot;TrueValue&quot;)[a &gt; b]) # 运行结果为：FalseValue</code></pre><p>递归写一个。这个跑不出来递归，判断条件会沿着true false两条线向下跑，就会是循环超出限制的错误。<br>理解了一下，主要是因为dict和tuple是建完之后再做判断的，建立过程中就跑到下层逻辑里去了</p><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span><span class="hljs-params">(object)</span>:</span>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">sumNums</span><span class="hljs-params">(self, n)</span>:</span>        <span class="hljs-string">"""</span><span class="hljs-string">        :type n: int</span><span class="hljs-string">        :rtype: int</span><span class="hljs-string">        """</span>        <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">subproblem</span><span class="hljs-params">(n)</span>:</span>            <span class="hljs-keyword">return</span> &#123;<span class="hljs-literal">True</span>: subproblem(n<span class="hljs-number">-1</span>)+n, <span class="hljs-literal">False</span>: n&#125;[n&gt;<span class="hljs-number">0</span>]        <span class="hljs-keyword">return</span> subproblem(n)</code></pre><p>其实还有快速乘方法，使用位运算，可降低时间复杂度，看了一知半解先放过<br>还有用我上边差不多脑洞的，比我多想一步，用try来判断list是否溢出，溢出就结束循环<br>还是有”sum(range(n+1))”这种取巧型。限制太多就是这么回事，漏洞也多</p>]]></content>
    
    
    <categories>
      
      <category>Leetcode</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Leetcode 56 - 合并区间</title>
    <link href="/2020/06/01/leetcode-56/"/>
    <url>/2020/06/01/leetcode-56/</url>
    
    <content type="html"><![CDATA[<p>题目：<br>来自探索-数组简介</p><pre><code class="hljs quote">给出一个区间的集合，请合并所有重叠的区间。</code></pre><p>重叠区间, 数组元素的后一个 &gt;= 另一个数组元素的前一个，则两个要合并。<br>暴力法，两个循环，取第一个元素，其它元素尝试是否能和这个元素合并；然后取第二个元素，重复以上流程</p><p>感觉肯定可以减小时间复杂度。先按每个数组元素里第一位来排序，然后两两对比：</p><ol><li>后一个元素的第一个&lt;=前一个元素的第二个，两个要合并，继续和下一个元素比较</li><li>否则，第一个元素肯定是没法合并的，单独存结果里</li></ol><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span><span class="hljs-params">(object)</span>:</span>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">merge</span><span class="hljs-params">(self, intervals)</span>:</span>        <span class="hljs-string">"""</span><span class="hljs-string">        :type intervals: List[List[int]]</span><span class="hljs-string">        :rtype: List[List[int]]</span><span class="hljs-string">        """</span>        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> intervals:            <span class="hljs-keyword">return</span> []        pre = <span class="hljs-literal">None</span>        res = []        <span class="hljs-comment"># 果然不是默认排序的，自己排</span>        intervals.sort()        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> intervals:            <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> pre:                pre = i            <span class="hljs-comment"># 这个地方不能&lt;=, 否则没法合并前后正好是界值的情况</span>            <span class="hljs-keyword">if</span> pre[<span class="hljs-number">1</span>] &lt; i[<span class="hljs-number">0</span>]:                res.append(pre)                pre = i            <span class="hljs-keyword">else</span>:                pre = [pre[<span class="hljs-number">0</span>], max(i[<span class="hljs-number">1</span>], pre[<span class="hljs-number">1</span>])]        <span class="hljs-keyword">if</span> pre:            res.append(pre)        <span class="hljs-keyword">return</span> res</code></pre><p>写的还挺快的，想回家的加成吧</p>]]></content>
    
    
    <categories>
      
      <category>Leetcode</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Leetcode 35 - 搜索插入位置</title>
    <link href="/2020/06/01/leetcode-35/"/>
    <url>/2020/06/01/leetcode-35/</url>
    
    <content type="html"><![CDATA[<p>题目：<br>来自探索-数组简介</p><pre><code class="hljs quote">给定一个排序数组和一个目标值，在数组中找到目标值，并返回其索引。如果目标值不存在于数组中，返回它将会被按顺序插入的位置。你可以假设数组中无重复元素。</code></pre><p>很直接，折半查找。边界值条件要熟练</p><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span><span class="hljs-params">(object)</span>:</span>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">searchInsert</span><span class="hljs-params">(self, nums, target)</span>:</span>        <span class="hljs-string">"""</span><span class="hljs-string">        :type nums: List[int]</span><span class="hljs-string">        :type target: int</span><span class="hljs-string">        :rtype: int</span><span class="hljs-string">        """</span>        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> nums:            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>                <span class="hljs-comment"># 题解要求同大小时放前边</span>        <span class="hljs-comment"># if nums[0] &gt; target:</span>        <span class="hljs-keyword">if</span> nums[<span class="hljs-number">0</span>] &gt;= target:            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>        <span class="hljs-keyword">if</span> nums[<span class="hljs-number">-1</span>] &lt; target:            <span class="hljs-keyword">return</span> len(nums)        left = <span class="hljs-number">0</span>        right = len(nums)<span class="hljs-number">-1</span>        <span class="hljs-keyword">while</span> left+<span class="hljs-number">1</span> &lt; right:            <span class="hljs-keyword">print</span>  str(left) + <span class="hljs-string">"          "</span> + str(right)            middle = (right-left)/<span class="hljs-number">2</span> + left            <span class="hljs-keyword">if</span> nums[middle] == target:                <span class="hljs-keyword">return</span> middle            <span class="hljs-keyword">elif</span> nums[middle] &gt; target:                right = middle            <span class="hljs-keyword">else</span>:                left = middle        <span class="hljs-comment"># 跳出循环必然是left+1==right</span>        <span class="hljs-comment"># 也覆盖了len(nums) == 1 的情况</span>        <span class="hljs-keyword">return</span> right</code></pre>]]></content>
    
    
    <categories>
      
      <category>Leetcode</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Leetcode 724 - 寻找数组的中心索引</title>
    <link href="/2020/06/01/leetcode-724/"/>
    <url>/2020/06/01/leetcode-724/</url>
    
    <content type="html"><![CDATA[<p>题目：<br>来自探索-数组简介</p><pre><code class="hljs quote">给定一个整数类型的数组 nums，请编写一个能够返回数组“中心索引”的方法。我们是这样定义数组中心索引的：数组中心索引的左侧所有元素相加的和等于右侧所有元素相加的和。如果数组不存在中心索引，那么我们应该返回 -1。如果数组有多个中心索引，那么我们应该返回最靠近左边的那一个。</code></pre><p>直接点，用sum，一个for循环，时间复杂度”O(n**2)”</p><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span><span class="hljs-params">(object)</span>:</span>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">pivotIndex</span><span class="hljs-params">(self, nums)</span>:</span>        <span class="hljs-string">"""</span><span class="hljs-string">        :type nums: List[int]</span><span class="hljs-string">        :rtype: int</span><span class="hljs-string">        """</span>        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> nums:            <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> xrange(len(nums)):            <span class="hljs-comment"># nums[:i-1]这个i-1小于0会倒到末尾去截取；nums[i+1:] i+1再大也是返回[]的</span>            <span class="hljs-keyword">if</span> nums[:max(i<span class="hljs-number">-1</span>, <span class="hljs-number">0</span>)] <span class="hljs-keyword">and</span> nums[i+<span class="hljs-number">1</span>:] <span class="hljs-keyword">and</span> sum(nums[::max(i<span class="hljs-number">-1</span>, <span class="hljs-number">0</span>)]) == sum(nums[i+<span class="hljs-number">1</span>:]):                <span class="hljs-keyword">return</span> nums[i]        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span></code></pre><p>上边的跑不过，也不想调试了<br>改改写法，算整个sum，然后一步一步加左边减右边，相等就返回，时间复杂度”O(n)”</p><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span><span class="hljs-params">(object)</span>:</span>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">pivotIndex</span><span class="hljs-params">(self, nums)</span>:</span>        <span class="hljs-string">"""</span><span class="hljs-string">        :type nums: List[int]</span><span class="hljs-string">        :rtype: int</span><span class="hljs-string">        """</span>        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> nums:            <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>        <span class="hljs-comment"># 初始时将第一个数去掉，因为比较的是除去当前数的两边的数</span>        right_sum = sum(nums[<span class="hljs-number">1</span>:])        left_sum = <span class="hljs-number">0</span>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> xrange(len(nums)):            <span class="hljs-keyword">print</span> str(left_sum) + <span class="hljs-string">"            "</span> + str(right_sum)            <span class="hljs-keyword">if</span> left_sum == right_sum:                <span class="hljs-keyword">return</span> i            left_sum += nums[i]            <span class="hljs-comment"># 左右的步长不一致，右边必须先减一次。还要小心边界值情况</span>            <span class="hljs-comment"># right_sum -= nums[i]</span>            right_sum = right_sum - nums[i+<span class="hljs-number">1</span>] <span class="hljs-keyword">if</span> i+<span class="hljs-number">1</span>&lt;len(nums) <span class="hljs-keyword">else</span> <span class="hljs-number">0</span>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span></code></pre><p>看起来容易，但是仍然在边界值上踟蹰了一会儿</p>]]></content>
    
    
    <categories>
      
      <category>Leetcode</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Leetcode 1431 - 拥有最多糖果的孩子</title>
    <link href="/2020/06/01/leetcode-1431/"/>
    <url>/2020/06/01/leetcode-1431/</url>
    
    <content type="html"><![CDATA[<p>题目：<br>来自每日一题</p><pre><code class="hljs quote">开始限制时间了，15分钟一题，能做就做出来，不行就看答案数组值+额外值是否是最大值的问题。 这道题没必要回来重看了&#96;&#96;&#96;pythonclass Solution(object):    def kidsWithCandies(self, candies, extraCandies):        &quot;&quot;&quot;        :type candies: List[int]        :type extraCandies: int        :rtype: List[bool]        &quot;&quot;&quot;        max_one &#x3D; max(candies)        # 这个地方不需要not not        # return [not not i+extraCandies &gt;&#x3D; max_one for i in candies]        return [i+extraCandies &gt;&#x3D; max_one for i in candies]</code></pre><p>5分钟就搞了，基本用来审题了，这个也太容易</p>]]></content>
    
    
    <categories>
      
      <category>Leetcode</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Leetcode 733 - 图像渲染</title>
    <link href="/2020/05/29/leetcode-733/"/>
    <url>/2020/05/29/leetcode-733/</url>
    
    <content type="html"><![CDATA[<p>题目：<br>来自探索-&gt;栈和深度优先搜索</p><pre><code class="hljs quote">有一幅以二维整数数组表示的图画，每一个整数表示该图画的像素值大小，数值在 0 到 65535 之间。给你一个坐标 (sr, sc) 表示图像渲染开始的像素值（行 ，列）和一个新的颜色值 newColor，让你重新上色这幅图像。为了完成上色工作，从初始坐标开始，记录初始坐标的上下左右四个方向上像素值与初始坐标相同的相连像素点，接着再记录这四个方向上符合条件的像素点与他们对应四个方向上像素值与初始坐标相同的相连像素点，……，重复该过程。将所有有记录的像素点的颜色值改为新的颜色值。最后返回经过上色渲染后的图像。</code></pre><p>这题就是从起始坐标开始DFS找最大岛的过程，用队列<br>比较简单的，做这种题已经很顺了</p><pre><code class="hljs python"><span class="hljs-keyword">import</span> Queue<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span><span class="hljs-params">(object)</span>:</span>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">floodFill</span><span class="hljs-params">(self, image, sr, sc, newColor)</span>:</span>        <span class="hljs-string">"""</span><span class="hljs-string">        :type image: List[List[int]]</span><span class="hljs-string">        :type sr: int</span><span class="hljs-string">        :type sc: int</span><span class="hljs-string">        :type newColor: int</span><span class="hljs-string">        :rtype: List[List[int]]</span><span class="hljs-string">        """</span>        <span class="hljs-keyword">if</span>  <span class="hljs-keyword">not</span> image:            <span class="hljs-keyword">return</span> image        que = Queue.Queue()        reached_set = set()        <span class="hljs-comment"># 自作聪明了，行数和列数就该是这样的</span>        <span class="hljs-comment"># i_sr, i_sc = len(image[0]), len(image)</span>        i_sr, i_sc = len(image), len(image[<span class="hljs-number">0</span>])        que.put((sr, sc))        originColor = image[sr][sc]        <span class="hljs-keyword">while</span> <span class="hljs-keyword">not</span> que.empty():            cur = que.get()            reached_set.add(cur)            (sr, sc) = cur            image[sr][sc] = newColor            <span class="hljs-comment"># b不是elif啊，都要的</span>            <span class="hljs-keyword">if</span> sr+<span class="hljs-number">1</span> &lt; i_sr <span class="hljs-keyword">and</span> (sr+<span class="hljs-number">1</span>, sc) <span class="hljs-keyword">not</span> <span class="hljs-keyword">in</span> reached_set <span class="hljs-keyword">and</span> image[sr+<span class="hljs-number">1</span>][sc] == originColor:                que.put((sr+<span class="hljs-number">1</span>, sc))            <span class="hljs-keyword">if</span> sc+<span class="hljs-number">1</span> &lt; i_sc <span class="hljs-keyword">and</span> (sr, sc+<span class="hljs-number">1</span>) <span class="hljs-keyword">not</span> <span class="hljs-keyword">in</span> reached_set <span class="hljs-keyword">and</span> image[sr][sc+<span class="hljs-number">1</span>] == originColor:                que.put((sr, sc+<span class="hljs-number">1</span>))            <span class="hljs-keyword">if</span> sr<span class="hljs-number">-1</span> &gt;= <span class="hljs-number">0</span> <span class="hljs-keyword">and</span> (sr<span class="hljs-number">-1</span>, sc) <span class="hljs-keyword">not</span> <span class="hljs-keyword">in</span> reached_set <span class="hljs-keyword">and</span> image[sr<span class="hljs-number">-1</span>][sc] == originColor:                que.put((sr<span class="hljs-number">-1</span>, sc))            <span class="hljs-keyword">if</span> sc<span class="hljs-number">-1</span> &gt;= <span class="hljs-number">0</span> <span class="hljs-keyword">and</span> (sr, sc<span class="hljs-number">-1</span>) <span class="hljs-keyword">not</span> <span class="hljs-keyword">in</span> reached_set <span class="hljs-keyword">and</span> image[sr][sc<span class="hljs-number">-1</span>] == originColor:                que.put((sr, sc<span class="hljs-number">-1</span>))        <span class="hljs-keyword">return</span> image</code></pre>]]></content>
    
    
    <categories>
      
      <category>Leetcode</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Leetcode 225 - 用队列实现栈</title>
    <link href="/2020/05/29/leetcode-225/"/>
    <url>/2020/05/29/leetcode-225/</url>
    
    <content type="html"><![CDATA[<p>题目：<br>来自探索-&gt;栈和深度优先搜索</p><pre><code class="hljs quote">使用队列实现栈的下列操作：push(x) -- 元素 x 入栈pop() -- 移除栈顶元素top() -- 获取栈顶元素empty() -- 返回栈是否为空注意:你只能使用队列的基本操作-- 也就是 push to back, peek&#x2F;pop from front, size, 和 is empty 这些操作是合法的。你所使用的语言也许不支持队列。 你可以使用 list 或者 deque（双端队列）来模拟一个队列 , 只要是标准的队列操作即可。你可以假设所有操作都是有效的（例如, 对一个空的栈不会调用 pop 或者 top 操作）。</code></pre><p>用栈实现队列的逆操作，试试看<br>push也是放在尾巴上<br>pop时候没法从尾巴上拿，只能从头上拿。再搞个队列入队用，除了最后一个不入队就好<br>top要返回当前最后一个值。用个变量记录最后往里放的一个<br>empty和队列一致</p><pre><code class="hljs python"><span class="hljs-keyword">import</span> Queue<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyStack</span><span class="hljs-params">(object)</span>:</span>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span><span class="hljs-params">(self)</span>:</span>        <span class="hljs-string">"""</span><span class="hljs-string">        Initialize your data structure here.</span><span class="hljs-string">        """</span>        self.que1 = Queue.Queue()        self.que2 = Queue.Queue()        self.top_holder = <span class="hljs-literal">None</span>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">push</span><span class="hljs-params">(self, x)</span>:</span>        <span class="hljs-string">"""</span><span class="hljs-string">        Push element x onto stack.</span><span class="hljs-string">        :type x: int</span><span class="hljs-string">        :rtype: None</span><span class="hljs-string">        """</span>        self.que1.put(x) <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> self.que1.empty() <span class="hljs-keyword">else</span> self.que2.put(x)        self.top_holder = x    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">pop</span><span class="hljs-params">(self)</span>:</span>        <span class="hljs-string">"""</span><span class="hljs-string">        Removes the element on top of the stack and returns that element.</span><span class="hljs-string">        :rtype: int</span><span class="hljs-string">        """</span>        last_one = <span class="hljs-literal">None</span>        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> self.que1.empty():            <span class="hljs-keyword">while</span> self.que1.qsize():                <span class="hljs-comment"># 迟一轮put</span>                <span class="hljs-keyword">if</span> last_one:                    self.top_holder = last_one                    self.que2.put(self.top_holder)                last_one = self.que1.get()        <span class="hljs-keyword">elif</span> <span class="hljs-keyword">not</span> self.que2.empty():            <span class="hljs-keyword">while</span> self.que2.qsize():                <span class="hljs-keyword">if</span> last_one:                    self.top_holder = last_one                    self.que1.put(self.top_holder)                last_one = self.que2.get()        <span class="hljs-keyword">return</span> last_one             <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">top</span><span class="hljs-params">(self)</span>:</span>        <span class="hljs-string">"""</span><span class="hljs-string">        Get the top element.</span><span class="hljs-string">        :rtype: int</span><span class="hljs-string">        """</span>        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> self.empty():            <span class="hljs-keyword">return</span> self.top_holder    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">empty</span><span class="hljs-params">(self)</span>:</span>        <span class="hljs-string">"""</span><span class="hljs-string">        Returns whether the stack is empty.</span><span class="hljs-string">        :rtype: bool</span><span class="hljs-string">        """</span>        <span class="hljs-keyword">return</span> self.que1.empty() <span class="hljs-keyword">and</span> self.que2.empty()<span class="hljs-comment"># Your MyStack object will be instantiated and called as such:</span><span class="hljs-comment"># obj = MyStack()</span><span class="hljs-comment"># obj.push(x)</span><span class="hljs-comment"># param_2 = obj.pop()</span><span class="hljs-comment"># param_3 = obj.top()</span><span class="hljs-comment"># param_4 = obj.empty()</span></code></pre>]]></content>
    
    
    <categories>
      
      <category>Leetcode</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Leetcode 232 - 用栈实现队列</title>
    <link href="/2020/05/28/leetcode-232/"/>
    <url>/2020/05/28/leetcode-232/</url>
    
    <content type="html"><![CDATA[<p>题目：<br>来自探索-&gt;栈和深度优先搜索</p><pre><code class="hljs quote">使用栈实现队列的下列操作：push(x) -- 将一个元素放入队列的尾部。pop() -- 从队列首部移除元素。peek() -- 返回队列首部的元素。empty() -- 返回队列是否为空。你只能使用标准的栈操作 -- 也就是只有 push to top, peek&#x2F;pop from top, size, 和 is empty 操作是合法的。你所使用的语言也许不支持栈。你可以使用 list 或者 deque（双端队列）来模拟一个栈，只要是标准的栈操作即可。假设所有操作都是有效的 （例如，一个空的队列不会调用 pop 或者 peek 操作）。</code></pre><p>用list随便搞搞的感觉，结果在pop那耽误好久</p><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyQueue</span><span class="hljs-params">(object)</span>:</span>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span><span class="hljs-params">(self)</span>:</span>        <span class="hljs-string">"""</span><span class="hljs-string">        Initialize your data structure here.</span><span class="hljs-string">        """</span>        self.bottom = <span class="hljs-literal">None</span>        self.list = []    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">push</span><span class="hljs-params">(self, x)</span>:</span>        <span class="hljs-string">"""</span><span class="hljs-string">        Push element x to the back of queue.</span><span class="hljs-string">        :type x: int</span><span class="hljs-string">        :rtype: None</span><span class="hljs-string">        """</span>        self.list.append(x)        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> self.bottom:            self.bottom = x    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">pop</span><span class="hljs-params">(self)</span>:</span>        <span class="hljs-string">"""</span><span class="hljs-string">        Removes the element from in front of queue and returns that element.</span><span class="hljs-string">        :rtype: int</span><span class="hljs-string">        """</span>        holders = []        <span class="hljs-keyword">while</span> <span class="hljs-keyword">not</span> self.empty():            holders.append(self.list.pop())        poped = holders.pop()        <span class="hljs-keyword">if</span> len(holders) != <span class="hljs-number">0</span>:            self.bottom = holders.pop()            self.list.append(self.bottom)                <span class="hljs-keyword">while</span> holders:                self.list.append(holders.pop())        <span class="hljs-keyword">else</span>:            self.bottom = <span class="hljs-literal">None</span>        <span class="hljs-keyword">return</span> poped    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">peek</span><span class="hljs-params">(self)</span>:</span>        <span class="hljs-string">"""</span><span class="hljs-string">        Get the front element.</span><span class="hljs-string">        :rtype: int</span><span class="hljs-string">        """</span>        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> self.empty():            <span class="hljs-keyword">return</span> self.bottom    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">empty</span><span class="hljs-params">(self)</span>:</span>        <span class="hljs-string">"""</span><span class="hljs-string">        Returns whether the queue is empty.</span><span class="hljs-string">        :rtype: bool</span><span class="hljs-string">        """</span>        <span class="hljs-keyword">return</span> len(self.list) == <span class="hljs-number">0</span><span class="hljs-comment"># Your MyQueue object will be instantiated and called as such:</span><span class="hljs-comment"># obj = MyQueue()</span><span class="hljs-comment"># obj.push(x)</span><span class="hljs-comment"># param_2 = obj.pop()</span><span class="hljs-comment"># param_3 = obj.peek()</span><span class="hljs-comment"># param_4 = obj.empty()</span></code></pre><p>果然用了两个栈，但是pop时从第二个逆序的栈pop就行了。push的时候两个栈来回倒数，这样降低了时间复杂度。 有机会再试试</p>]]></content>
    
    
    <categories>
      
      <category>Leetcode</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Leetcode 94 - 二叉树的中序遍历</title>
    <link href="/2020/05/28/leetcode-94/"/>
    <url>/2020/05/28/leetcode-94/</url>
    
    <content type="html"><![CDATA[<p>题目：<br>来自探索-&gt;栈和深度优先搜索</p><pre><code class="hljs quote">给定一个二叉树，返回它的中序 遍历。</code></pre><p>要求迭代就迭代，一下就做完了。估计难点就是中序迭代时候，父节点如何安放的</p><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span><span class="hljs-params">(object)</span>:</span>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">inorderTraversal</span><span class="hljs-params">(self, root)</span>:</span>        <span class="hljs-string">"""</span><span class="hljs-string">        :type root: TreeNode</span><span class="hljs-string">        :rtype: List[int]</span><span class="hljs-string">        """</span>        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> root:            <span class="hljs-keyword">return</span> []        res = []        stack = [root]        <span class="hljs-keyword">while</span> stack:            node = stack.pop()            <span class="hljs-keyword">if</span> type(node) != TreeNode:                res.append(node)                <span class="hljs-keyword">continue</span>            <span class="hljs-keyword">if</span> node.right:                stack.append(node.right)            stack.append(node.val)            <span class="hljs-keyword">if</span> node.left:                stack.append(node.left)        <span class="hljs-keyword">return</span> res</code></pre><p>尝试更兼容的写法一下没写出来。即向左一直跑到头，到头之后拿出来一个向右走一步，进行下一步循环</p>]]></content>
    
    
    <categories>
      
      <category>Leetcode</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Leetcode 394 - 字符串解码</title>
    <link href="/2020/05/28/leetcode-394/"/>
    <url>/2020/05/28/leetcode-394/</url>
    
    <content type="html"><![CDATA[<p>题目：<br>来自每日一题</p><pre><code class="hljs quote">给定一个经过编码的字符串，返回它解码后的字符串。编码规则为: k[encoded_string]，表示其中方括号内部的 encoded_string 正好重复 k 次。注意 k 保证为正整数。你可以认为输入字符串总是有效的；输入字符串中没有额外的空格，且输入的方括号总是符合格式要求的。此外，你可以认为原始数据不包含数字，所有的数字只表示重复的次数 k ，例如不会出现像 3a 或 2[4] 的输入。</code></pre><p>看例子字符串格式是可嵌套的<br>这个看起来就是个用栈的简单题，试试<br>感觉递归一下就好，碰到中括号就递归</p><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span><span class="hljs-params">(object)</span>:</span>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">decodeString</span><span class="hljs-params">(self, s)</span>:</span>        <span class="hljs-string">"""</span><span class="hljs-string">        :type s: str</span><span class="hljs-string">        :rtype: str</span><span class="hljs-string">        """</span>        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> s:            <span class="hljs-keyword">return</span> <span class="hljs-string">""</span>        <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">innnerLevel</span><span class="hljs-params">(s)</span>:</span>            start, end, new_s_parts = <span class="hljs-number">-1</span>, <span class="hljs-number">-1</span>, []            <span class="hljs-comment"># 这里还是需要坐标的</span>            <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> xrange(len(s)):                <span class="hljs-keyword">if</span> s[i] == <span class="hljs-string">"["</span>:                    start = i                    new_s_parts.append(s[:start<span class="hljs-number">-1</span>])                <span class="hljs-keyword">if</span> s[i] == <span class="hljs-string">"]"</span> <span class="hljs-keyword">and</span> start &gt;= <span class="hljs-number">0</span>:                    end = i                    new_s_parts.append(innnerLevel(s[start+<span class="hljs-number">1</span>:end])*int(s[start<span class="hljs-number">-1</span>]))                    start, end = <span class="hljs-number">-1</span>, <span class="hljs-number">-1</span>            <span class="hljs-keyword">return</span> reduce(<span class="hljs-keyword">lambda</span> x, y: x+y, new_s_parts)        <span class="hljs-keyword">return</span> innnerLevel(s)</code></pre><p>缺少情况判断，每层中间夹着的普通字符串和没有编码的子串都没返回<br>而且k也不是肯定个位数,占多位时候都要解决一下<br>完全重写要</p><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span><span class="hljs-params">(object)</span>:</span>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">decodeString</span><span class="hljs-params">(self, s)</span>:</span>        <span class="hljs-string">"""</span><span class="hljs-string">        :type s: str</span><span class="hljs-string">        :rtype: str</span><span class="hljs-string">        """</span>        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> s:            <span class="hljs-keyword">return</span> <span class="hljs-string">""</span>        <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">solveEncode</span><span class="hljs-params">(s)</span>:</span>            <span class="hljs-comment"># init</span>            cur = <span class="hljs-number">0</span>            alpha_str_holder = <span class="hljs-string">""</span>            num_str_holder = <span class="hljs-string">""</span>            sub_start = <span class="hljs-number">-1</span>            sub_end = <span class="hljs-number">-1</span>            new_s_parts = []            times = <span class="hljs-number">0</span>            <span class="hljs-comment"># loop</span>            <span class="hljs-keyword">while</span> s[cur:]:                <span class="hljs-keyword">print</span> s[cur:]                <span class="hljs-keyword">if</span> s[cur] == <span class="hljs-string">"["</span>:                    times = int(num_str_holder)                    num_str_holder = <span class="hljs-string">""</span>                    sub_start = cur                    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> xrange(len(s[cur:])):                        <span class="hljs-keyword">if</span> s[cur:][i] == <span class="hljs-string">"]"</span>:                            sub_end = cur + i                            part = solveEncode(s[sub_start+<span class="hljs-number">1</span>:sub_end])                            new_s_parts.append(reduce(<span class="hljs-keyword">lambda</span> x,y: x+y, [part]*times))                            times = <span class="hljs-number">0</span>                            sub_start = <span class="hljs-number">-1</span>                            sub_end = <span class="hljs-number">-1</span>                            cur = cur + i + <span class="hljs-number">1</span>                            <span class="hljs-keyword">break</span>                <span class="hljs-keyword">elif</span> s[cur].isdigit():                    new_s_parts.append(alpha_str_holder)                    alpha_str_holder = <span class="hljs-string">""</span>                    num_str_holder = num_str_holder + s[cur]                <span class="hljs-keyword">elif</span> s[cur].isalpha():                    alpha_str_holder = alpha_str_holder + s[cur]                cur += <span class="hljs-number">1</span>            <span class="hljs-comment"># finally</span>            <span class="hljs-keyword">if</span> alpha_str_holder:                new_s_parts.append(alpha_str_holder)            <span class="hljs-keyword">return</span> reduce(<span class="hljs-keyword">lambda</span> x, y: x+y, new_s_parts)        <span class="hljs-keyword">return</span> solveEncode(s)</code></pre><p>改来改去内部逻辑仍然有问题，递归好难调，不知道到哪一层<br>以上逻辑会把外层”[“配对内层”]”,问题很大<br>还是用栈吧，存储所有遇到的”[“的位置，用来配对</p><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span><span class="hljs-params">(object)</span>:</span>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">decodeString</span><span class="hljs-params">(self, s)</span>:</span>        <span class="hljs-string">"""</span><span class="hljs-string">        :type s: str</span><span class="hljs-string">        :rtype: str</span><span class="hljs-string">        """</span>        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> s:            <span class="hljs-keyword">return</span> <span class="hljs-string">""</span>        <span class="hljs-comment"># stack元素结构, 存字符串和数字</span>        <span class="hljs-comment"># 存"["用于区隔,前后都是数字的情况</span>        <span class="hljs-comment"># 遇到"]"开始弹出计算直到上一个num</span>        stack = []        alpha_str_holder = <span class="hljs-string">""</span>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> xrange(len(s)):            <span class="hljs-keyword">if</span> s[i].isalpha():                <span class="hljs-keyword">if</span> stack <span class="hljs-keyword">and</span> stack[<span class="hljs-number">-1</span>].isalpha():                    stack[<span class="hljs-number">-1</span>] = stack[<span class="hljs-number">-1</span>] + s[i]                <span class="hljs-keyword">else</span>:                    stack.append(s[i])            <span class="hljs-keyword">elif</span> s[i].isdigit():                <span class="hljs-keyword">if</span> stack <span class="hljs-keyword">and</span> stack[<span class="hljs-number">-1</span>].isdigit():                    stack[<span class="hljs-number">-1</span>] = stack[<span class="hljs-number">-1</span>] + s[i]                <span class="hljs-keyword">else</span>:                    stack.append(s[i])            <span class="hljs-keyword">elif</span> s[i] == <span class="hljs-string">"["</span>:                stack.append(s[i])            <span class="hljs-keyword">elif</span> s[i] == <span class="hljs-string">"]"</span>:                chars = stack.pop()                <span class="hljs-comment"># 多余的"["没用了，扔掉</span>                stack.pop()                nums = stack.pop()                <span class="hljs-comment"># 子串肯定是字母字符串，其栈前如果也是字母字符串，两串应该合并</span>                cur_sum = reduce(<span class="hljs-keyword">lambda</span> x,y: x+y, [chars]*int(nums))                <span class="hljs-keyword">if</span> stack <span class="hljs-keyword">and</span> stack[<span class="hljs-number">-1</span>].isalpha():                    stack[<span class="hljs-number">-1</span>] = stack[<span class="hljs-number">-1</span>] + cur_sum                <span class="hljs-keyword">else</span>:                    stack.append(cur_sum)        <span class="hljs-keyword">return</span> reduce(<span class="hljs-keyword">lambda</span> x,y: x+y, stack)</code></pre><p>实践证明，还是用栈好调试<br>答案和我差不多，比我简洁</p>]]></content>
    
    
    <categories>
      
      <category>Leetcode</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Leetcode 133 - 克隆图</title>
    <link href="/2020/05/28/leetcode-133/"/>
    <url>/2020/05/28/leetcode-133/</url>
    
    <content type="html"><![CDATA[<p>题目：<br>来自于探索-》栈：后入先出的数据结构</p><pre><code class="hljs quote">给你无向 连通 图中一个节点的引用，请你返回该图的 深拷贝（克隆）。图中的每个节点都包含它的值 val（int） 和其邻居的列表（list[Node]）。</code></pre><p>You must return a copy of all the nodes in the original graph<br>看不出哪错了，看答案</p><pre><code class="hljs python"><span class="hljs-string">"""</span><span class="hljs-string"># Definition for a Node.</span><span class="hljs-string">class Node(object):</span><span class="hljs-string">    def __init__(self, val = 0, neighbors = []):</span><span class="hljs-string">        self.val = val</span><span class="hljs-string">        self.neighbors = neighbors</span><span class="hljs-string">"""</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span><span class="hljs-params">(object)</span>:</span>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">cloneGraph</span><span class="hljs-params">(self, node)</span>:</span>        <span class="hljs-string">"""</span><span class="hljs-string">        :type node: Node</span><span class="hljs-string">        :rtype: Node</span><span class="hljs-string">        """</span>                <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> node:            <span class="hljs-keyword">return</span> <span class="hljs-literal">None</span>        self.reached_node = set()        <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">DFS</span><span class="hljs-params">(node)</span>:</span>            <span class="hljs-keyword">if</span> node <span class="hljs-keyword">in</span> self.reached_node:                <span class="hljs-keyword">return</span> node            <span class="hljs-keyword">else</span>:                cur_node = Node(node.val)                <span class="hljs-comment"># 新建的节点放进去待用</span>                self.reached_node.add(cur_node)                <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> node.neighbors:                    cur_node.neighbors.append(DFS(i))                <span class="hljs-keyword">return</span> cur_node        <span class="hljs-keyword">return</span> DFS(node)</code></pre><p>早晨来了没看答案做了几次打印发现，neighours因为递归进内层后node的内存地址不一样了，所以要比较node和reached_node里边的value，但返回reached_node里边的节点</p><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span><span class="hljs-params">(object)</span>:</span>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">cloneGraph</span><span class="hljs-params">(self, node)</span>:</span>        <span class="hljs-string">"""</span><span class="hljs-string">        :type node: Node</span><span class="hljs-string">        :rtype: Node</span><span class="hljs-string">        """</span>                <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> node:            <span class="hljs-keyword">return</span> <span class="hljs-literal">None</span>        <span class="hljs-comment"># self.reached_node = set()</span>        self.reached_node = &#123;&#125;                <span class="hljs-keyword">print</span> <span class="hljs-string">"node"</span> + str(node.val) + <span class="hljs-string">"    "</span> + str(node.neighbors)        <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">DFS</span><span class="hljs-params">(node)</span>:</span>            <span class="hljs-comment"># 这样的内层node是新node，而不是我们所要的老的内存地址里已经创建的node</span>            <span class="hljs-comment"># if node in self.reached_node:</span>            <span class="hljs-comment">#     return node</span>            <span class="hljs-keyword">if</span> node.val <span class="hljs-keyword">in</span> self.reached_node:                <span class="hljs-keyword">return</span> self.reached_node[node.val]            <span class="hljs-keyword">else</span>:                cur_node = Node(node.val)                <span class="hljs-comment"># self.reached_node.add(cur_node)</span>                <span class="hljs-comment"># Line 23: TypeError: unhashable type: 'dict'</span>                <span class="hljs-comment"># self.reached_node.add(&#123;cur_node.val:cur_node&#125;)</span>                self.reached_node[cur_node.val] = cur_node                <span class="hljs-keyword">print</span> <span class="hljs-string">"old_node "</span> + str(node) + <span class="hljs-string">"     "</span> + str(node.val) + <span class="hljs-string">"    "</span> + str(node.neighbors)                <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> node.neighbors:                    cur_node.neighbors.append(DFS(i))                <span class="hljs-keyword">print</span> <span class="hljs-string">"cur_node "</span> + str(cur_node) + <span class="hljs-string">"     "</span> + str(cur_node.val) + <span class="hljs-string">"    "</span> + str(cur_node.neighbors)                <span class="hljs-keyword">return</span> cur_node        <span class="hljs-keyword">return</span> DFS(node)</code></pre>]]></content>
    
    
    <categories>
      
      <category>Leetcode</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Leetcode 200 - 岛屿数量</title>
    <link href="/2020/05/27/leetcode-200/"/>
    <url>/2020/05/27/leetcode-200/</url>
    
    <content type="html"><![CDATA[<p>题目：<br>来自于探索-》栈：后入先出的数据结构</p><pre><code class="hljs quote">给你一个由 &#39;1&#39;（陆地）和 &#39;0&#39;（水）组成的的二维网格，请你计算网格中岛屿的数量。岛屿总是被水包围，并且每座岛屿只能由水平方向或竖直方向上相邻的陆地连接形成。此外，你可以假设该网格的四条边均被水包围。</code></pre><p>这个题用BFS做完了，这后补的感想已经忘了当时的想法了。大概情况就是在二维数组上一发现1就开始广度优先搜索到头，同时岛数加1</p><pre><code class="hljs python"><span class="hljs-keyword">import</span> Queue<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span><span class="hljs-params">(object)</span>:</span>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">numIslands</span><span class="hljs-params">(self, grid)</span>:</span>        <span class="hljs-string">"""</span><span class="hljs-string">        :type grid: List[List[str]]</span><span class="hljs-string">        :rtype: int</span><span class="hljs-string">        """</span>        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> grid:            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>        que = Queue.Queue()        checked_set = set()        island_num = <span class="hljs-number">0</span>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(len(grid)):            <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> range(len(grid[<span class="hljs-number">0</span>])):                <span class="hljs-keyword">print</span> <span class="hljs-string">"!!!!!!!!!!!!!!!!!"</span>                <span class="hljs-keyword">if</span> (grid[i][j] == <span class="hljs-string">"1"</span>) <span class="hljs-keyword">and</span> (str([i, j]) <span class="hljs-keyword">not</span> <span class="hljs-keyword">in</span> checked_set):                    que.put((i,j))                    checked_set.add(str([i,j]))                    island_num += <span class="hljs-number">1</span>                    <span class="hljs-keyword">while</span> <span class="hljs-keyword">not</span> que.empty():                        cur = que.get()                        <span class="hljs-keyword">print</span> cur                        <span class="hljs-keyword">print</span> cur[<span class="hljs-number">0</span>]                        <span class="hljs-keyword">if</span> cur[<span class="hljs-number">0</span>]+<span class="hljs-number">1</span>&lt;len(grid) <span class="hljs-keyword">and</span> grid[cur[<span class="hljs-number">0</span>]+<span class="hljs-number">1</span>][cur[<span class="hljs-number">1</span>]] == <span class="hljs-string">"1"</span> <span class="hljs-keyword">and</span> str([cur[<span class="hljs-number">0</span>]+<span class="hljs-number">1</span>, cur[<span class="hljs-number">1</span>]]) <span class="hljs-keyword">not</span> <span class="hljs-keyword">in</span> checked_set:                            <span class="hljs-keyword">print</span> <span class="hljs-string">"right"</span>                            que.put((cur[<span class="hljs-number">0</span>]+<span class="hljs-number">1</span>, cur[<span class="hljs-number">1</span>]))                            checked_set.add(str([cur[<span class="hljs-number">0</span>]+<span class="hljs-number">1</span>, cur[<span class="hljs-number">1</span>]]))                        <span class="hljs-keyword">if</span> cur[<span class="hljs-number">0</span>]<span class="hljs-number">-1</span>&gt;=<span class="hljs-number">0</span> <span class="hljs-keyword">and</span> grid[cur[<span class="hljs-number">0</span>]<span class="hljs-number">-1</span>][cur[<span class="hljs-number">1</span>]] == <span class="hljs-string">"1"</span> <span class="hljs-keyword">and</span> str([cur[<span class="hljs-number">0</span>]<span class="hljs-number">-1</span>, cur[<span class="hljs-number">1</span>]]) <span class="hljs-keyword">not</span> <span class="hljs-keyword">in</span> checked_set:                             <span class="hljs-keyword">print</span> <span class="hljs-string">"left"</span>                            que.put((cur[<span class="hljs-number">0</span>]<span class="hljs-number">-1</span>, cur[<span class="hljs-number">1</span>]))                            checked_set.add(str([cur[<span class="hljs-number">0</span>]<span class="hljs-number">-1</span>, cur[<span class="hljs-number">1</span>]]))                        <span class="hljs-keyword">if</span> cur[<span class="hljs-number">1</span>]+<span class="hljs-number">1</span>&lt;len(grid[<span class="hljs-number">0</span>]) <span class="hljs-keyword">and</span> grid[cur[<span class="hljs-number">0</span>]][cur[<span class="hljs-number">1</span>]+<span class="hljs-number">1</span>] == <span class="hljs-string">"1"</span> <span class="hljs-keyword">and</span> str([cur[<span class="hljs-number">0</span>], cur[<span class="hljs-number">1</span>]+<span class="hljs-number">1</span>]) <span class="hljs-keyword">not</span> <span class="hljs-keyword">in</span> checked_set:                             <span class="hljs-keyword">print</span> <span class="hljs-string">"down"</span>                            que.put((cur[<span class="hljs-number">0</span>], cur[<span class="hljs-number">1</span>]+<span class="hljs-number">1</span>))                            checked_set.add(str([cur[<span class="hljs-number">0</span>], cur[<span class="hljs-number">1</span>]+<span class="hljs-number">1</span>]))                        <span class="hljs-keyword">if</span> cur[<span class="hljs-number">1</span>]<span class="hljs-number">-1</span>&gt;=<span class="hljs-number">0</span> <span class="hljs-keyword">and</span> grid[cur[<span class="hljs-number">0</span>]][cur[<span class="hljs-number">1</span>]<span class="hljs-number">-1</span>] == <span class="hljs-string">"1"</span> <span class="hljs-keyword">and</span> str([cur[<span class="hljs-number">0</span>], cur[<span class="hljs-number">1</span>]<span class="hljs-number">-1</span>]) <span class="hljs-keyword">not</span> <span class="hljs-keyword">in</span> checked_set:                             <span class="hljs-keyword">print</span> <span class="hljs-string">"up"</span>                            que.put((cur[<span class="hljs-number">0</span>], cur[<span class="hljs-number">1</span>]<span class="hljs-number">-1</span>))                            checked_set.add(str([cur[<span class="hljs-number">0</span>], cur[<span class="hljs-number">1</span>]<span class="hljs-number">-1</span>]))        <span class="hljs-keyword">return</span> island_num</code></pre><p>现在用深度优先搜索做一遍。但是这里的深度，指的是啥东西，先想明白<br>找到一个1的位置，开始上下左右走，四路，每路走到头之前不回头</p><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span><span class="hljs-params">(object)</span>:</span>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">numIslands</span><span class="hljs-params">(self, grid)</span>:</span>        <span class="hljs-string">"""</span><span class="hljs-string">        :type grid: List[List[str]]</span><span class="hljs-string">        :rtype: int</span><span class="hljs-string">        """</span>        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> grid:            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>        stack = []        reached_set = set()        island_num = <span class="hljs-number">0</span>        <span class="hljs-comment"># xrange返回迭代生成器，range返回list，xrange比较好性能，占内存小</span>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> xrange(len(grid)):            <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> xrange(len(grid[<span class="hljs-number">0</span>])):                <span class="hljs-keyword">if</span> grid[i][j] == <span class="hljs-string">"1"</span> <span class="hljs-keyword">and</span> (i, j) <span class="hljs-keyword">not</span> <span class="hljs-keyword">in</span> reached_set:                    island_num += <span class="hljs-number">1</span>                    stack.append((i, j))                    reached_set.add((i, j))                    <span class="hljs-keyword">while</span> stack:                        <span class="hljs-comment"># 这样不行，因为前边的while会改变mn的值，有些点就找不到了</span>                        <span class="hljs-comment"># (m, n) = stack.pop()</span>                        (x, y) = stack.pop()                        m, n = x, y                        <span class="hljs-keyword">while</span> m+<span class="hljs-number">1</span>&gt;=<span class="hljs-number">0</span> <span class="hljs-keyword">and</span> m+<span class="hljs-number">1</span>&lt;len(grid) <span class="hljs-keyword">and</span> n&gt;=<span class="hljs-number">0</span> <span class="hljs-keyword">and</span> n&lt;len(grid[<span class="hljs-number">0</span>]) <span class="hljs-keyword">and</span> grid[m+<span class="hljs-number">1</span>][n]==<span class="hljs-string">"1"</span> <span class="hljs-keyword">and</span> (m+<span class="hljs-number">1</span>, n) <span class="hljs-keyword">not</span> <span class="hljs-keyword">in</span> reached_set:                            m += <span class="hljs-number">1</span>                            stack.append((m, n))                            reached_set.add((m, n))                        m, n = x, y                        <span class="hljs-keyword">while</span> m&gt;=<span class="hljs-number">0</span> <span class="hljs-keyword">and</span> m&lt;len(grid) <span class="hljs-keyword">and</span> n+<span class="hljs-number">1</span>&gt;=<span class="hljs-number">0</span> <span class="hljs-keyword">and</span> n+<span class="hljs-number">1</span>&lt;len(grid[<span class="hljs-number">0</span>]) <span class="hljs-keyword">and</span> grid[m][n+<span class="hljs-number">1</span>]==<span class="hljs-string">"1"</span> <span class="hljs-keyword">and</span> (m, n+<span class="hljs-number">1</span>) <span class="hljs-keyword">not</span> <span class="hljs-keyword">in</span> reached_set:                            n += <span class="hljs-number">1</span>                            stack.append((m, n))                            reached_set.add((m, n))                        m, n = x, y                        <span class="hljs-keyword">while</span> m<span class="hljs-number">-1</span>&gt;=<span class="hljs-number">0</span> <span class="hljs-keyword">and</span> m<span class="hljs-number">-1</span>&lt;len(grid) <span class="hljs-keyword">and</span> n&gt;=<span class="hljs-number">0</span> <span class="hljs-keyword">and</span> n&lt;len(grid[<span class="hljs-number">0</span>]) <span class="hljs-keyword">and</span> grid[m<span class="hljs-number">-1</span>][n]==<span class="hljs-string">"1"</span> <span class="hljs-keyword">and</span> (m<span class="hljs-number">-1</span>, n) <span class="hljs-keyword">not</span> <span class="hljs-keyword">in</span> reached_set:                            m -= <span class="hljs-number">1</span>                            stack.append((m, n))                            reached_set.add((m, n))                        m, n = x, y                        <span class="hljs-keyword">while</span> m&gt;=<span class="hljs-number">0</span> <span class="hljs-keyword">and</span> m&lt;len(grid) <span class="hljs-keyword">and</span> n<span class="hljs-number">-1</span>&gt;=<span class="hljs-number">0</span> <span class="hljs-keyword">and</span> n<span class="hljs-number">-1</span>&lt;len(grid[<span class="hljs-number">0</span>]) <span class="hljs-keyword">and</span> grid[m][n<span class="hljs-number">-1</span>]==<span class="hljs-string">"1"</span> <span class="hljs-keyword">and</span> (m, n<span class="hljs-number">-1</span>) <span class="hljs-keyword">not</span> <span class="hljs-keyword">in</span> reached_set:                            n -= <span class="hljs-number">1</span>                            stack.append((m, n))                            reached_set.add((m, n))        <span class="hljs-keyword">return</span> island_num</code></pre><p>写完发现仍然不是深度的，不过也算做出来了。。。</p>]]></content>
    
    
    <categories>
      
      <category>Leetcode</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Leetcode 150 - 逆波兰表达式求值</title>
    <link href="/2020/05/27/leetcode-150/"/>
    <url>/2020/05/27/leetcode-150/</url>
    
    <content type="html"><![CDATA[<p>题目：<br>来自于探索-》栈：后入先出的数据结构</p><pre><code class="hljs quote">根据逆波兰表示法，求表达式的值。有效的运算符包括 +, -, *, &#x2F; 。每个运算对象可以是整数，也可以是另一个逆波兰表达式。说明：整数除法只保留整数部分。给定逆波兰表达式总是有效的。换句话说，表达式总会得出有效数值且不存在除数为 0 的情况。</code></pre><p>这个题感觉也是十年前做过</p><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span><span class="hljs-params">(object)</span>:</span>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">evalRPN</span><span class="hljs-params">(self, tokens)</span>:</span>        <span class="hljs-string">"""</span><span class="hljs-string">        :type tokens: List[str]</span><span class="hljs-string">        :rtype: int</span><span class="hljs-string">        """</span>        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> tokens:            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>        <span class="hljs-comment"># 这样没法初始化set。set方法只有1个参数。虽然set没什么用。</span>        <span class="hljs-comment"># multi_set = set("+", "-", "*", "/")</span>        multi_set = set([<span class="hljs-string">"+"</span>, <span class="hljs-string">"-"</span>, <span class="hljs-string">"*"</span>, <span class="hljs-string">"/"</span>])        stack = []        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> tokens:            <span class="hljs-keyword">if</span> i <span class="hljs-keyword">in</span> multi_set:                num1 = stack.pop()                num2 = stack.pop()                <span class="hljs-keyword">if</span> i == <span class="hljs-string">"+"</span>:                    stack.append(num1+num2)                <span class="hljs-keyword">elif</span> i == <span class="hljs-string">"-"</span>:                    stack.append(num2-num1)                <span class="hljs-keyword">elif</span> i == <span class="hljs-string">"*"</span>:                    <span class="hljs-comment"># can't multiply sequence by non-int of type 'unicode'</span>                    <span class="hljs-comment"># stack.append(num1*num2)</span>                    stack.append(num1*num2)                <span class="hljs-keyword">elif</span> i == <span class="hljs-string">"/"</span>:                    <span class="hljs-comment"># 这道题同时还考了负值的取整方法，有个测试用例时6//-132应该时0。但是按python来就是-1了</span>                    operator = <span class="hljs-number">1</span> <span class="hljs-keyword">if</span> num1*num2 &gt;= <span class="hljs-number">0</span> <span class="hljs-keyword">else</span> <span class="hljs-number">-1</span>                    stack.append(abs(num2)//abs(num1)*operator)            <span class="hljs-keyword">else</span>:                <span class="hljs-comment"># 与其运算时unicode转int，不如这时转</span>                stack.append(int(i))        <span class="hljs-keyword">return</span> stack.pop()</code></pre>]]></content>
    
    
    <categories>
      
      <category>Leetcode</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Leetcode 739 - 每日温度</title>
    <link href="/2020/05/27/leetcode-739/"/>
    <url>/2020/05/27/leetcode-739/</url>
    
    <content type="html"><![CDATA[<p>题目：<br>来自于探索-》栈：后入先出的数据结构</p><pre><code class="hljs quote">根据每日 气温 列表，请重新生成一个列表，对应位置的输出是需要再等待多久温度才会升高超过该日的天数。如果之后都不会升高，请在该位置用 0 来代替。例如，给定一个列表 temperatures &#x3D; [73, 74, 75, 71, 69, 72, 76, 73]，你的输出应该是 [1, 1, 4, 2, 1, 1, 0, 0]。提示：气温 列表长度的范围是 [1, 30000]。每个气温的值的均为华氏度，都是在 [30, 100] 范围内的整数。</code></pre><p>这道题挺有意思的样子。返回的list长度等于tempreratures长度。没有直接思路的感觉。双指针循环过于暴力了把<br>列表里最后一个元素必然是0<br>这样尝试：<br>a&gt;b，a&lt;c，b一定&lt;c。<br>遍历列表的过程中，比较值小于栈顶元素，压栈；比较值大于栈顶元素，则出栈，计算出栈的次数来填入结果对应位置。</p><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span><span class="hljs-params">(object)</span>:</span>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">dailyTemperatures</span><span class="hljs-params">(self, T)</span>:</span>        <span class="hljs-string">"""</span><span class="hljs-string">        :type T: List[int]</span><span class="hljs-string">        :rtype: List[int]</span><span class="hljs-string">        """</span>        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> T:            <span class="hljs-keyword">return</span> []        stack = []        res = [<span class="hljs-number">0</span>]*len(T)        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(len(T)):            <span class="hljs-comment"># counter这个算法是错的，因为栈中元素可能在中间状态已经pop出去一些了，while的次数并不是实际两个元素间距离</span>            <span class="hljs-comment"># 直接用保存的元素位置相减就完了</span>            <span class="hljs-comment"># counter = 0</span>            <span class="hljs-keyword">while</span> stack <span class="hljs-keyword">and</span> stack[<span class="hljs-number">-1</span>][<span class="hljs-number">0</span>] &lt; T[i]:                element = stack.pop()                <span class="hljs-comment"># counter += 1</span>                res[element[<span class="hljs-number">1</span>]] = i - element[<span class="hljs-number">1</span>]            <span class="hljs-comment">#保存tuple(元素值，元素位置)</span>            stack.append((T[i],i))        <span class="hljs-comment"># 处理没有更大值得位置</span>        <span class="hljs-keyword">while</span> stack:            element = stack.pop()            res[element[<span class="hljs-number">1</span>]] = <span class="hljs-number">0</span>        <span class="hljs-keyword">return</span> res</code></pre><p>思考过之后还是做出来了。如果题没出现在这估计我联想不到栈<br>元素间距离的相对马虎错误不停的犯</p>]]></content>
    
    
    <categories>
      
      <category>Leetcode</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Leetcode 20 - 有效的括号</title>
    <link href="/2020/05/27/leetcode-20/"/>
    <url>/2020/05/27/leetcode-20/</url>
    
    <content type="html"><![CDATA[<p>题目：<br>来自于探索-》栈：后入先出的数据结构</p><pre><code class="hljs quote">给定一个只包括 &#39;(&#39;，&#39;)&#39;，&#39;&#123;&#39;，&#39;&#125;&#39;，&#39;[&#39;，&#39;]&#39; 的字符串，判断字符串是否有效。有效字符串需满足：左括号必须用相同类型的右括号闭合。左括号必须以正确的顺序闭合。注意空字符串可被认为是有效字符串。</code></pre><p>这道题十年前就碰见过了</p><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span><span class="hljs-params">(object)</span>:</span>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">isValid</span><span class="hljs-params">(self, s)</span>:</span>        <span class="hljs-string">"""</span><span class="hljs-string">        :type s: str</span><span class="hljs-string">        :rtype: bool</span><span class="hljs-string">        """</span>        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> s:            <span class="hljs-keyword">return</span> <span class="hljs-literal">True</span>        match_dict = &#123;<span class="hljs-string">"("</span>:<span class="hljs-string">")"</span>, <span class="hljs-string">"["</span>:<span class="hljs-string">"]"</span>, <span class="hljs-string">"&#123;"</span>:<span class="hljs-string">"&#125;"</span>&#125;        stack = []        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> s:            <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> stack:                <span class="hljs-keyword">if</span> i <span class="hljs-keyword">in</span> match_dict:                    stack.append(i)                <span class="hljs-keyword">else</span>:                    <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span>            <span class="hljs-keyword">else</span>:                <span class="hljs-keyword">if</span> i <span class="hljs-keyword">in</span> match_dict:                    stack.append(i)                <span class="hljs-keyword">else</span>:                    <span class="hljs-keyword">if</span> i == match_dict[stack[<span class="hljs-number">-1</span>]]:                        stack.pop()                    <span class="hljs-keyword">else</span>:                        <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">not</span> stack</code></pre><p>一遍过。只不过分支优化细节有机会再回来看一下</p>]]></content>
    
    
    <categories>
      
      <category>Leetcode</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Leetcode 279 - 完全平方数</title>
    <link href="/2020/05/27/leetcode-279/"/>
    <url>/2020/05/27/leetcode-279/</url>
    
    <content type="html"><![CDATA[<p>题目：<br>来自于探索-》队列和广度优先搜索</p><pre><code class="hljs quote">给定正整数 n，找到若干个完全平方数（比如 1, 4, 9, 16, ...）使得它们的和等于 n。你需要让组成和的完全平方数的个数最少。</code></pre><p>昨天和今天跟了几道探索的题，用队列做广度优先已经举步维艰了，所以现在决定先把探索的过一遍<br>探索挺好的，脑子不够用嗯。里边的题也是题库里的</p><p>这道题没想到怎么能广度搜索，自己用递归随便做了</p><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span><span class="hljs-params">(object)</span>:</span>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">numSquares</span><span class="hljs-params">(self, n)</span>:</span>        <span class="hljs-string">"""</span><span class="hljs-string">        :type n: int</span><span class="hljs-string">        :rtype: int</span><span class="hljs-string">        """</span>        self.num = <span class="hljs-number">0</span>        <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">calcu</span><span class="hljs-params">(n)</span>:</span>            self.num += <span class="hljs-number">1</span>            <span class="hljs-keyword">print</span> <span class="hljs-string">"1111111111111"</span>            <span class="hljs-keyword">print</span> n            <span class="hljs-comment"># round() 是四舍五入，不行的</span>            <span class="hljs-comment"># tmp = round(n**0.5)</span>            tmp = int(n**<span class="hljs-number">0.5</span>)            <span class="hljs-keyword">print</span> tmp            <span class="hljs-comment"># 忘了把p重新搞成乘方的状态</span>            <span class="hljs-keyword">if</span> n - tmp**<span class="hljs-number">2</span> != <span class="hljs-number">0</span>:                calcu(n - tmp**<span class="hljs-number">2</span>)        calcu(n)        <span class="hljs-keyword">return</span> self.num</code></pre><p>上面思路完全错了，比如例子里，12=4+4+4，而我的算出来是 12=9+1+1+1<br>广度优先搜索诚不欺我<br>这里的每步，应该是把所有m**2 &lt;= n的正整数m进行广度搜索</p><pre><code class="hljs python"><span class="hljs-keyword">import</span> Queue<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span><span class="hljs-params">(object)</span>:</span>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">numSquares</span><span class="hljs-params">(self, n)</span>:</span>        <span class="hljs-string">"""</span><span class="hljs-string">        :type n: int</span><span class="hljs-string">        :rtype: int</span><span class="hljs-string">        """</span>        que = Queue.Queue()        que.put(n)        step = <span class="hljs-number">0</span>        <span class="hljs-comment"># 这个不要会形成环，出不来了</span>        reached_set= set()        reached_set.add(n)        <span class="hljs-keyword">while</span> <span class="hljs-keyword">not</span> que.empty():            <span class="hljs-keyword">print</span> list(que.queue)            step += <span class="hljs-number">1</span>            cur_size = que.qsize()            <span class="hljs-keyword">for</span> c <span class="hljs-keyword">in</span> range(cur_size):                <span class="hljs-keyword">print</span> <span class="hljs-string">"c: "</span> + str(c)                cur = que.get()                m = int(cur**<span class="hljs-number">0.5</span>)                <span class="hljs-comment"># 让减的快的先</span>                <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(m, <span class="hljs-number">0</span>, <span class="hljs-number">-1</span>):                <span class="hljs-comment"># 取值有毛病，每个少了1</span>                <span class="hljs-comment"># for i in range(m):</span>                    <span class="hljs-comment"># 脑抽了,n应该是cur，m应该是i。脑子不清楚</span>                    <span class="hljs-comment"># minus = n-m**2</span>                    minus = cur-i**<span class="hljs-number">2</span>                    <span class="hljs-keyword">if</span> minus == <span class="hljs-number">0</span>:                        <span class="hljs-keyword">return</span> step                    <span class="hljs-keyword">elif</span> minus <span class="hljs-keyword">not</span> <span class="hljs-keyword">in</span> reached_set:                        que.put(minus)                        reached_set.add(minus)</code></pre><p>中午吃个饭回来立马做出来了。这个脑子不清搞不了</p>]]></content>
    
    
    <categories>
      
      <category>Leetcode</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Leetcode 303 - 区域和检索 - 数组不可变</title>
    <link href="/2020/05/21/leetcode-303/"/>
    <url>/2020/05/21/leetcode-303/</url>
    
    <content type="html"><![CDATA[<p>题目：</p><pre><code class="hljs quote">给定一个整数数组  nums，求出数组从索引 i 到 j  (i ≤ j) 范围内元素的总和，包含 i,  j 两点。1. 你可以假设数组不可变。2. 会多次调用 sumRange 方法。</code></pre><p>isinstance判断类型<br>直接相加超时</p><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">NumArray</span><span class="hljs-params">(object)</span>:</span>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span><span class="hljs-params">(self, nums)</span>:</span>        <span class="hljs-string">"""</span><span class="hljs-string">        :type nums: List[int]</span><span class="hljs-string">        """</span>        self.nums = nums    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">sumRange</span><span class="hljs-params">(self, i, j)</span>:</span>        <span class="hljs-string">"""</span><span class="hljs-string">        :type i: int</span><span class="hljs-string">        :type j: int</span><span class="hljs-string">        :rtype: int</span><span class="hljs-string">        """</span>        <span class="hljs-comment">## 要验证格式</span>        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> isinstance(i, int) <span class="hljs-keyword">or</span> <span class="hljs-keyword">not</span> isinstance(j, int):            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>        <span class="hljs-keyword">if</span> i &lt; <span class="hljs-number">0</span> <span class="hljs-keyword">or</span> j &lt; i <span class="hljs-keyword">or</span> j &gt;=len(self.nums):            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>                <span class="hljs-comment">## reduce又忘了用法了</span>        <span class="hljs-keyword">return</span> reduce(<span class="hljs-keyword">lambda</span> x, y: x+y, self.nums[i:j+<span class="hljs-number">1</span>])</code></pre><p>忘了说明了，这意思是拿空间换时间咯，动态规划重写<br>这个就是前缀和呗<br>sum[i:j] = sum[0:j] - sum[0:i]<br>dp[i]定义：子串[0:i+1]的和<br>选择：加一个元素<br>动态规划方程：dp[i] = dp[i-1] + nums[i]<br>起始状态：dp[0] = nums[0]<br>终结状态：dp[len(nums)-1]</p><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">NumArray</span><span class="hljs-params">(object)</span>:</span>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span><span class="hljs-params">(self, nums)</span>:</span>        <span class="hljs-string">"""</span><span class="hljs-string">        :type nums: List[int]</span><span class="hljs-string">        """</span>        self.nums = nums        self.dp = [<span class="hljs-number">0</span>] * len(nums)        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(len(nums)):            <span class="hljs-keyword">if</span> i == <span class="hljs-number">0</span>:                self.dp[<span class="hljs-number">0</span>] = nums[<span class="hljs-number">0</span>]            <span class="hljs-keyword">else</span>:                self.dp[i] = self.dp[i<span class="hljs-number">-1</span>] + nums[i]    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">sumRange</span><span class="hljs-params">(self, i, j)</span>:</span>        <span class="hljs-string">"""</span><span class="hljs-string">        :type i: int</span><span class="hljs-string">        :type j: int</span><span class="hljs-string">        :rtype: int</span><span class="hljs-string">        """</span>        <span class="hljs-comment">## 要验证格式</span>        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> isinstance(i, int) <span class="hljs-keyword">or</span> <span class="hljs-keyword">not</span> isinstance(j, int):            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>        <span class="hljs-keyword">if</span> i &lt; <span class="hljs-number">0</span> <span class="hljs-keyword">or</span> j &lt; i <span class="hljs-keyword">or</span> j &gt;=len(self.nums):            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>                <span class="hljs-comment">## 闭闭区间，包括j在内的</span>        <span class="hljs-keyword">return</span> self.dp[j]-self.dp[i]</code></pre><p>相减的位置总差一位，改一下起始状态逻辑为：<br>dp[0] = 0<br>原来的问题在于，dp[0]用来存了第一个数组值，这样求[0:2]的和成了dp[2]-dp[0]，多减了sums[0]的值</p><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">NumArray</span><span class="hljs-params">(object)</span>:</span>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span><span class="hljs-params">(self, nums)</span>:</span>        <span class="hljs-string">"""</span><span class="hljs-string">        :type nums: List[int]</span><span class="hljs-string">        """</span>        self.nums = nums        self.dp = [<span class="hljs-number">0</span>] * (len(nums)+<span class="hljs-number">1</span>)        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(len(nums)+<span class="hljs-number">1</span>):            <span class="hljs-keyword">if</span> i == <span class="hljs-number">0</span>:                self.dp[<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>            <span class="hljs-keyword">else</span>:                <span class="hljs-comment"># 这种状态转移也比较自然</span>                self.dp[i] = self.dp[i<span class="hljs-number">-1</span>] + nums[i<span class="hljs-number">-1</span>]    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">sumRange</span><span class="hljs-params">(self, i, j)</span>:</span>        <span class="hljs-string">"""</span><span class="hljs-string">        :type i: int</span><span class="hljs-string">        :type j: int</span><span class="hljs-string">        :rtype: int</span><span class="hljs-string">        """</span>        <span class="hljs-comment">## 要验证格式</span>        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> isinstance(i, int) <span class="hljs-keyword">or</span> <span class="hljs-keyword">not</span> isinstance(j, int):            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>        <span class="hljs-keyword">if</span> i &lt; <span class="hljs-number">0</span> <span class="hljs-keyword">or</span> j &lt; i <span class="hljs-keyword">or</span> j &gt;=len(self.nums):            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>                <span class="hljs-comment">## 闭闭区间，包括j在内的</span>        <span class="hljs-keyword">return</span> self.dp[j+<span class="hljs-number">1</span>]-self.dp[i]</code></pre><p>看似简单，在边界值上纠结了好一会儿</p>]]></content>
    
    
    <categories>
      
      <category>Leetcode</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Leetcode 392 - 判断子序列</title>
    <link href="/2020/05/21/leetcode-392/"/>
    <url>/2020/05/21/leetcode-392/</url>
    
    <content type="html"><![CDATA[<p>题目：</p><pre><code class="hljs quote">给定字符串 s 和 t ，判断 s 是否为 t 的子序列。你可以认为 s 和 t 中仅包含英文小写字母。字符串 t 可能会很长（长度 ~&#x3D; 500,000），而 s 是个短字符串（长度 &lt;&#x3D;100）。字符串的一个子序列是原始字符串删除一些（也可以不删除）字符而不改变剩余字符相对位置形成的新字符串。（例如，&quot;ace&quot;是&quot;abcde&quot;的一个子序列，而&quot;aec&quot;不是）。</code></pre><p>很简单的一个双指针吧，刚做过这个题的高难度版 </p><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span><span class="hljs-params">(object)</span>:</span>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">isSubsequence</span><span class="hljs-params">(self, s, t)</span>:</span>        <span class="hljs-string">"""</span><span class="hljs-string">        :type s: str</span><span class="hljs-string">        :type t: str</span><span class="hljs-string">        :rtype: bool</span><span class="hljs-string">        """</span>        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> s:            <span class="hljs-keyword">return</span> <span class="hljs-literal">True</span>        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> t <span class="hljs-keyword">or</span> len(s) &gt; len(t):            <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span>        i, j = <span class="hljs-number">0</span>, <span class="hljs-number">0</span>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(len(t)):            <span class="hljs-keyword">if</span> t[i] == s[j]:                j += <span class="hljs-number">1</span>                <span class="hljs-comment">## z这个地方写成t了，st混了</span>                <span class="hljs-keyword">if</span> j &gt;= len(s):                    <span class="hljs-keyword">return</span> <span class="hljs-literal">True</span>        <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span></code></pre>]]></content>
    
    
    <categories>
      
      <category>Leetcode</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Leetcode 524 - 通过删除字母匹配到字典里最长单词</title>
    <link href="/2020/05/21/leetcode-524/"/>
    <url>/2020/05/21/leetcode-524/</url>
    
    <content type="html"><![CDATA[<p>题目：</p><pre><code class="hljs quote">给定一个字符串和一个字符串字典，找到字典里面最长的字符串，该字符串可以通过删除给定字符串的某些字符来得到。如果答案不止一个，返回长度最长且字典顺序最小的字符串。如果答案不存在，则返回空字符串。</code></pre><p>首先想法：d中str的元素在s中能按顺序找到，str就满足条件。用两个指针记录位置就能穷举了。<br>不过这题肯定没这么简单，s被刷len(d)遍，时间复杂度在n^2上<br>d中元素之间的关系应该也可以利用的？想不到</p><p>另一个想法：用pointers = [0]*len(d)来保存d上str的指针集，然后开始遍历s，与s相同的str的指针也走，最后pointer走到str头且str最大的就是答案。按这个写了<br>这里边有纠结。从头开始走不知道哪里是具体str底不用走了，决定全部从后往前遍历，这样走到-1就算走完了；还要再判断一遍满足条件str里最长最左的，也是没办法</p><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span><span class="hljs-params">(object)</span>:</span>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">findLongestWord</span><span class="hljs-params">(self, s, d)</span>:</span>        <span class="hljs-string">"""</span><span class="hljs-string">        :type s: str</span><span class="hljs-string">        :type d: List[str]</span><span class="hljs-string">        :rtype: str</span><span class="hljs-string">        """</span>        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> d <span class="hljs-keyword">or</span> <span class="hljs-keyword">not</span> s:            <span class="hljs-keyword">return</span> <span class="hljs-string">""</span>        reverse_pointers = [len(i)<span class="hljs-number">-1</span> <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> d]        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(len(s)<span class="hljs-number">-1</span>, <span class="hljs-number">-1</span>, <span class="hljs-number">-1</span>):            <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> range(len(d)):                <span class="hljs-comment"># d中第j个str,其reverse_pointers[j]为这个str当前位置指针</span>                <span class="hljs-keyword">if</span> reverse_pointers[j] &gt;= <span class="hljs-number">0</span> <span class="hljs-keyword">and</span> d[j][reverse_pointers[j]] == s[i]:                    reverse_pointers[j] -= <span class="hljs-number">1</span>        max_len = <span class="hljs-number">0</span>        res = <span class="hljs-string">""</span>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(len(d)):            <span class="hljs-keyword">if</span> reverse_pointers[i] == <span class="hljs-number">-1</span> <span class="hljs-keyword">and</span> len(d[i]) &gt; max_len:                max_len = max(max_len, len(d[i]))                res = d[i]        <span class="hljs-keyword">return</span> res</code></pre><p>被审题框了，不是”长度最长数组顺序最小”，而是”长度最长字典序最小”。比如</p><pre><code class="hljs quote">解答错误显示详情输入&quot;bab&quot;[&quot;ba&quot;,&quot;ab&quot;,&quot;a&quot;,&quot;b&quot;]输出&quot;ba&quot;预期结果&quot;ab&quot;</code></pre><p>重新改改最后一截</p><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span><span class="hljs-params">(object)</span>:</span>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">findLongestWord</span><span class="hljs-params">(self, s, d)</span>:</span>        <span class="hljs-string">"""</span><span class="hljs-string">        :type s: str</span><span class="hljs-string">        :type d: List[str]</span><span class="hljs-string">        :rtype: str</span><span class="hljs-string">        """</span>        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> d <span class="hljs-keyword">or</span> <span class="hljs-keyword">not</span> s:            <span class="hljs-keyword">return</span> <span class="hljs-string">""</span>        reverse_pointers = [len(i)<span class="hljs-number">-1</span> <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> d]        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(len(s)<span class="hljs-number">-1</span>, <span class="hljs-number">-1</span>, <span class="hljs-number">-1</span>):            <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> range(len(d)):                <span class="hljs-comment"># d中第j个str,其reverse_pointers[j]为这个str当前位置指针</span>                <span class="hljs-keyword">if</span> reverse_pointers[j] &gt;= <span class="hljs-number">0</span> <span class="hljs-keyword">and</span> d[j][reverse_pointers[j]] == s[i]:                    reverse_pointers[j] -= <span class="hljs-number">1</span>        max_len = <span class="hljs-number">0</span>        res = <span class="hljs-string">""</span>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(len(d)):            <span class="hljs-keyword">if</span> reverse_pointers[i] == <span class="hljs-number">-1</span>:                <span class="hljs-keyword">if</span> len(d[i]) &gt; max_len:                    max_len = len(d[i])                    res = d[i]                <span class="hljs-keyword">elif</span> len(d[i]) == max_len <span class="hljs-keyword">and</span> d[i] &gt; res:                    res = d[i]        <span class="hljs-keyword">return</span> res</code></pre><p>答案还挺多的4种，思想差不多，细节跳过不表</p>]]></content>
    
    
    <categories>
      
      <category>Leetcode</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Leetcode 107 - 二叉树的层次遍历 II</title>
    <link href="/2020/05/21/leetcode-107/"/>
    <url>/2020/05/21/leetcode-107/</url>
    
    <content type="html"><![CDATA[<p>题目：</p><pre><code class="hljs quote">给定一个二叉树，返回其节点值自底向上的层次遍历。 （即按从叶子节点所在层到根节点所在的层，逐层从左向右遍历）</code></pre><p>挺久没二叉树了，这道简单正好<br>二叉树先决定前中后序遍历，这个用前序好，从底向上的遍历就是从顶向下遍历反过来[::-1]<br>每层产生了第一个点就append进数组，底二个点就append进对应位置子数组。用个常量记录当前的层数<br>速度击败83%的用户，优化空间没必要看了，过了<br>目前来说做的最顺的一题，随便画画一想很快搞定了</p><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span><span class="hljs-params">(object)</span>:</span>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">levelOrderBottom</span><span class="hljs-params">(self, root)</span>:</span>        <span class="hljs-string">"""</span><span class="hljs-string">        :type root: TreeNode</span><span class="hljs-string">        :rtype: List[List[int]]</span><span class="hljs-string">        """</span>        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> root:            <span class="hljs-keyword">return</span> []        level = <span class="hljs-number">0</span>        list = []        <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">nextLevel</span><span class="hljs-params">(level, node)</span>:</span>            <span class="hljs-keyword">if</span> len(list) &lt; level+<span class="hljs-number">1</span>:                list.append([node.val])            <span class="hljs-keyword">else</span>:                list[level].append(node.val)            <span class="hljs-keyword">if</span> node.left:                nextLevel(level+<span class="hljs-number">1</span>, node.left)            <span class="hljs-keyword">if</span> node.right:                nextLevel(level+<span class="hljs-number">1</span>, node.right)                nextLevel(level, root)        <span class="hljs-keyword">return</span> list[::<span class="hljs-number">-1</span>]</code></pre>]]></content>
    
    
    <categories>
      
      <category>Leetcode</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Leetcode 5 - 最长回文子串</title>
    <link href="/2020/05/21/leetcode-5/"/>
    <url>/2020/05/21/leetcode-5/</url>
    
    <content type="html"><![CDATA[<p>题目：</p><pre><code class="hljs quote">给定一个字符串 s，找到 s 中最长的回文子串。你可以假设 s 的最大长度为 1000。</code></pre><p>刚研究些动态规划模板趁热乎热热身<br>这个不是返回最长子串的长度，而是最长子串本身，如果有多个，保留最长一个就行了（一前一后保留后边一个，还可能增长）<br>状态：s中以第i个元素结尾的子串，最长回文子串为dp[i]<br>终结状态为dp[len(s)-1], base case为字符串为空，返回None；字符串为len(1), dp[0] = s[0]<br>每步先择：看看加上i后的尾巴上，是否有&gt;=len(pre)的回文串，有的话就更新pre. <del>这个时候就是看s[i-len(pre):i+1]是否是回文串，是的话替换pre。比pre长1，不可能更长了，更长的话之前pre的值都错了</del><br>因为dp table每一步都只需保留上一步的值，用pre来保持就行，降维空间复杂度<br>====================================================<br>“这个时候就是看s[i-len(pre):i+1]是否是回文串，是的话替换pre。比pre长1，不可能更长了，更长的话之前pre的值都错了”<br>这个选择错了。以下子串长度，就是从pre到pre+2的。投机取巧失败，重写选择<br>“babad”</p><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span><span class="hljs-params">(object)</span>:</span>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">longestPalindrome</span><span class="hljs-params">(self, s)</span>:</span>        <span class="hljs-string">"""</span><span class="hljs-string">        :type s: str</span><span class="hljs-string">        :rtype: str</span><span class="hljs-string">        """</span>        <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">isPalindrome</span><span class="hljs-params">(str)</span>:</span>            i, j = <span class="hljs-number">0</span>, len(str) - <span class="hljs-number">1</span>            <span class="hljs-keyword">while</span> i &lt;= j:                <span class="hljs-keyword">if</span> str[i] != str[j]:                    <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span>                <span class="hljs-comment">## 作为循环都忘了改变循环条件</span>                i+=<span class="hljs-number">1</span>                j-=<span class="hljs-number">1</span>            <span class="hljs-keyword">return</span> <span class="hljs-literal">True</span>        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> s:            <span class="hljs-keyword">return</span> <span class="hljs-string">""</span>                pre = <span class="hljs-string">""</span>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(<span class="hljs-number">0</span>, len(s), <span class="hljs-number">1</span>):            current_max_palindrome = <span class="hljs-string">""</span>            <span class="hljs-comment">## 这个子串头纠结了好久</span>            <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> range(<span class="hljs-number">0</span>, i-len(pre)+<span class="hljs-number">1</span>, <span class="hljs-number">1</span>):                <span class="hljs-keyword">if</span> isPalindrome(s[j:i+<span class="hljs-number">1</span>]) <span class="hljs-keyword">and</span> len(current_max_palindrome) &lt; len(s[j:i+<span class="hljs-number">1</span>]):                    current_max_palindrome = s[j:i+<span class="hljs-number">1</span>]                    <span class="hljs-keyword">break</span>            <span class="hljs-comment">## 这又忘了取大值了</span>            <span class="hljs-keyword">if</span> len(pre) &lt; len(current_max_palindrome):                pre = current_max_palindrome        <span class="hljs-keyword">return</span> pre</code></pre><p>s比较长的时候超出时间限制了…<br>确实，让我改成了暴力法了<br>看答案了…</p><p>动态规划应该是这样的状态转移公式：s[i,j] = s[i+1, j-1] &amp;&amp; s[i]==s[j]</p><h1 id="之后回来重做"><a href="#之后回来重做" class="headerlink" title="之后回来重做"></a>之后回来重做</h1><p>前几天刚尝试的，没做出来放着了，今天每日一题一定要做了<br>动态规划看这几天有没有沉淀能力下来（貌似并没有）<br>dp[i][j]定义：子串s[i:j+1]是否为回文子串，是为1，否为0<br>状态转换方程（偷看了一眼draft，自己发挥）：<br>(j-i)%2==0 则当前串为奇数；(j-i)%2==1 则当前串为偶数<br>dp[i][j] = 1 if i+1 &lt;= j-1 and dp[i+1][j-1]==1 and s[i]==s[j] else 0<br>计算顺序是从正坐标矩阵右下往左上算；因为j&gt;=i，所以填矩阵的左上角三角形；初始状态是对角线，全为1；循环到左上角<br>最终状态：max(j-i)的s[i:j+1]就是最大串<br>起始状态，不循环状态设定了，让循环变得更可读一些：</p><ol><li>dp[i][i] = 1，只有一个元素肯定是回文串</li><li>dp[i][i+1] = 1 if s[i]==s[i+1] else 0<br>留个变量记最大的max(j-i)</li></ol><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span><span class="hljs-params">(object)</span>:</span>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">longestPalindrome</span><span class="hljs-params">(self, s)</span>:</span>        <span class="hljs-string">"""</span><span class="hljs-string">        :type s: str</span><span class="hljs-string">        :rtype: str</span><span class="hljs-string">        """</span>        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> s:            <span class="hljs-keyword">return</span> <span class="hljs-string">""</span>        max_sub = [<span class="hljs-number">0</span>,<span class="hljs-number">0</span>]        dp = [[<span class="hljs-number">0</span> <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(len(s))] <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> range(len(s))]        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(len(s)):            dp[i][i] = <span class="hljs-number">1</span>            <span class="hljs-keyword">if</span> i+<span class="hljs-number">1</span>&lt;len(s) <span class="hljs-keyword">and</span> s[i]==s[i+<span class="hljs-number">1</span>]:                dp[i][i+<span class="hljs-number">1</span>] = <span class="hljs-number">1</span>                <span class="hljs-keyword">if</span> max_sub[<span class="hljs-number">1</span>] - max_sub[<span class="hljs-number">0</span>] &lt; <span class="hljs-number">1</span>:                    max_sub =[i,i+<span class="hljs-number">1</span>]                <span class="hljs-comment">## 错误的循环方式</span>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(len(s)<span class="hljs-number">-2</span>):            <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> range(len(s)-i, len(s)):                <span class="hljs-keyword">if</span> dp[i+<span class="hljs-number">1</span>][j<span class="hljs-number">-1</span>]==<span class="hljs-number">1</span> <span class="hljs-keyword">and</span> s[i]==s[j]:                    dp[i][j] = <span class="hljs-number">1</span>                    <span class="hljs-keyword">if</span> max_sub[<span class="hljs-number">1</span>] - max_sub[<span class="hljs-number">0</span>] &lt; j-i:                        max_sub =[i,j]        <span class="hljs-keyword">return</span> s[i:j+<span class="hljs-number">1</span>]</code></pre><p>上边答案错了，明知道是应该按从右下到左上斜着遍历，结果成了从左上开始一列一列向右遍历了，这样答案对不了，重写<br>斜着遍历写法不熟，再看看小抄</p><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span><span class="hljs-params">(object)</span>:</span>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">longestPalindrome</span><span class="hljs-params">(self, s)</span>:</span>        <span class="hljs-string">"""</span><span class="hljs-string">        :type s: str</span><span class="hljs-string">        :rtype: str</span><span class="hljs-string">        """</span>        <span class="hljs-comment"># 排除异常情况也重写了</span>        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> s:            <span class="hljs-keyword">return</span> <span class="hljs-string">""</span>        <span class="hljs-keyword">if</span> len(s) == <span class="hljs-number">1</span>:            <span class="hljs-keyword">return</span> s        <span class="hljs-keyword">if</span> len(s) == <span class="hljs-number">2</span>:            <span class="hljs-keyword">return</span> s <span class="hljs-keyword">if</span> s[<span class="hljs-number">0</span>] == s[<span class="hljs-number">1</span>] <span class="hljs-keyword">else</span> s[<span class="hljs-number">0</span>]        max_sub = [<span class="hljs-number">0</span>,<span class="hljs-number">0</span>]        dp = [[<span class="hljs-number">0</span> <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(len(s))] <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> range(len(s))]        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(len(s)):            dp[i][i] = <span class="hljs-number">1</span>            <span class="hljs-keyword">if</span> i+<span class="hljs-number">1</span>&lt;len(s) <span class="hljs-keyword">and</span> s[i]==s[i+<span class="hljs-number">1</span>]:                dp[i][i+<span class="hljs-number">1</span>] = <span class="hljs-number">1</span>                <span class="hljs-keyword">if</span> max_sub[<span class="hljs-number">1</span>] - max_sub[<span class="hljs-number">0</span>] &lt; <span class="hljs-number">1</span>:                    max_sub =[i,i+<span class="hljs-number">1</span>]                <span class="hljs-comment"># 从对角线起，向左上角斜着遍历</span>        <span class="hljs-comment"># n为斜向上j-i的差，因为要算左上三角，j肯定&gt;i，而且斜向前两行做了初始值，从j-i=2开始</span>        <span class="hljs-comment"># 即j=i+n，j本身不用存在</span>        <span class="hljs-comment"># 初始化可以根据n=0或n=1合并到for循环里</span>        <span class="hljs-keyword">for</span> n <span class="hljs-keyword">in</span> range(<span class="hljs-number">2</span>, len(s)):            <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(len(s)<span class="hljs-number">-2</span>):                <span class="hljs-comment">## j=i+n首先不能溢出数组才又算的意义</span>                <span class="hljs-keyword">if</span> i+n &lt; len(s) <span class="hljs-keyword">and</span> dp[i+<span class="hljs-number">1</span>][i+n<span class="hljs-number">-1</span>]==<span class="hljs-number">1</span> <span class="hljs-keyword">and</span> s[i]==s[i+n]:                    dp[i][i+n] = <span class="hljs-number">1</span>                    <span class="hljs-keyword">if</span> max_sub[<span class="hljs-number">1</span>] - max_sub[<span class="hljs-number">0</span>] &lt; n:                        max_sub =[i,i+n]        <span class="hljs-keyword">return</span> s[max_sub[<span class="hljs-number">0</span>]:max_sub[<span class="hljs-number">1</span>]+<span class="hljs-number">1</span>]</code></pre><p>答案还包括中心扩展法，把所有长度为1或2的回文串作为最小中心向外极力延申，只保留最大子串，因为不用二维数组了，空间复杂度降到1了</p><p>manacher法，时间复杂度n，空间复杂度n，没看放以后吧</p>]]></content>
    
    
    <categories>
      
      <category>Leetcode</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Leetcode 1371 - 每个元音包含偶数次的最长子字符串</title>
    <link href="/2020/05/20/leetcode-1371/"/>
    <url>/2020/05/20/leetcode-1371/</url>
    
    <content type="html"><![CDATA[<p>题目：</p><pre><code class="hljs quote">给你一个字符串 s ，请你返回满足以下条件的最长子字符串的长度：每个元音字母，即 &#39;a&#39;，&#39;e&#39;，&#39;i&#39;，&#39;o&#39;，&#39;u&#39; ，在子字符串中都恰好出现了偶数次。</code></pre><p>元音可以为0个<br>没有元音的s，最大长度为len(s)<br>以5位二进制串00000来保存aeiou元音在某个状态是奇数还是偶数</p><p>状态：s的子串s, 其二进制串的值<br>选择：下一个子串<br>dp定义：dp[i][j], s的子串[i,j],其二进制串的值, 串为00000则该子串满足条件，记录到当前max<br>状态转移方程：<br>dp[i][j] = dp[i][j-1]^s[j]对应二进制数 , i&lt;=j  异或运算<br>初始状态： dp[0][0] = dict[s[0]] if dict[s[0]]<br>终结状态： 全部穷举完，max(j-i) and dp[i][j] = 00000<br>怎么感觉用不出动态规划套不进去，变成了两层循环，不过可以压到nlogn的样子</p><p>不过二进制转换命令我也不会啊，这只能看答案了</p><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span><span class="hljs-params">(object)</span>:</span>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">findTheLongestSubstring</span><span class="hljs-params">(self, s)</span>:</span>        <span class="hljs-string">"""</span><span class="hljs-string">        :type s: str</span><span class="hljs-string">        :rtype: int</span><span class="hljs-string">        """</span>        dict = &#123;            <span class="hljs-string">'a'</span>: <span class="hljs-number">10000</span>,            <span class="hljs-string">'e'</span>: <span class="hljs-number">01000</span>,            <span class="hljs-string">'i'</span>: <span class="hljs-number">00100</span>,            <span class="hljs-string">'o'</span>: <span class="hljs-number">00010</span>,            <span class="hljs-string">'u'</span>: <span class="hljs-number">00001</span>        &#125;        res = <span class="hljs-number">0</span>        dp = [[<span class="hljs-number">00000</span> <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(s)] <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> range(s)]        <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> range(s):            <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(j):</code></pre><p>前缀和+二进制压缩，5位2进制数的十进制区间为[0,31], 所以建立一个包括32个[-1]list备用<br>我想到了用二进制代表元音，但没想到前缀和解法<br>前缀和：串[i,j] = 串[0,j] - 串[0,i]<br>我想到的是把五位二进制数作为二维数组值，但解法是把二进制数化为十进制作为数组坐标，数组值为特定元音组合的最小串长度</p><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span>:</span>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">findTheLongestSubstring</span><span class="hljs-params">(self, s)</span>:</span>        ans, status, n = <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, len(s)        <span class="hljs-comment"># &lt;&lt; 是位运算，把1向前移动5位，就是32</span>        pos = [<span class="hljs-number">-1</span>] * (<span class="hljs-number">1</span> &lt;&lt; <span class="hljs-number">5</span>)        <span class="hljs-comment"># 初始化，默认最小值[00000]=0.开始第一位时候非元音，则答案就是1了。循环没法往pos[0]设置0</span>        pos[<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(n):            <span class="hljs-keyword">if</span> s[i] == <span class="hljs-string">'a'</span>:                <span class="hljs-comment"># ^ 异或运算，对应位不相等时结果为1，相等为0，status记录上一步元音出现的奇偶次数 </span>                status ^= <span class="hljs-number">1</span> &lt;&lt; <span class="hljs-number">0</span>            <span class="hljs-keyword">elif</span> s[i] == <span class="hljs-string">'e'</span>:                status ^= <span class="hljs-number">1</span> &lt;&lt; <span class="hljs-number">1</span>            <span class="hljs-keyword">elif</span> s[i] == <span class="hljs-string">'i'</span>:                status ^= <span class="hljs-number">1</span> &lt;&lt; <span class="hljs-number">2</span>            <span class="hljs-keyword">elif</span> s[i] == <span class="hljs-string">'o'</span>:                status ^= <span class="hljs-number">1</span> &lt;&lt; <span class="hljs-number">3</span>            <span class="hljs-keyword">elif</span> s[i] == <span class="hljs-string">'u'</span>:                status ^= <span class="hljs-number">1</span> &lt;&lt; <span class="hljs-number">4</span>            <span class="hljs-comment"># 某前缀情况已经写入</span>            <span class="hljs-keyword">if</span> pos[status] != <span class="hljs-number">-1</span>:                <span class="hljs-comment"># 当前长度减去该情况最小长度。因为偶数-偶数=偶数，奇数-奇数=偶数，所以不用区别元音奇偶具体组成</span>                <span class="hljs-comment"># 把相同的奇偶组成情况相减，剩下的子串各元音个数必为偶数</span>                ans = max(ans, i + <span class="hljs-number">1</span> - pos[status])            <span class="hljs-comment"># 第一次遇见某前缀情况</span>            <span class="hljs-keyword">else</span>:                <span class="hljs-comment"># 记录该前缀情况作为该情况最小值就行，后边无需更新，因为要求最大值，就是最大值-最小值</span>                pos[status] = i + <span class="hljs-number">1</span>        <span class="hljs-keyword">return</span> ans</code></pre>]]></content>
    
    
    <categories>
      
      <category>Leetcode</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Leetcode 198 - 打家劫舍</title>
    <link href="/2020/05/19/leetcode-198/"/>
    <url>/2020/05/19/leetcode-198/</url>
    
    <content type="html"><![CDATA[<p>题目：</p><pre><code class="hljs quote">你是一个专业的小偷，计划偷窃沿街的房屋。每间房内都藏有一定的现金，影响你偷窃的唯一制约因素就是相邻的房屋装有相互连通的防盗系统，如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警。给定一个代表每个房屋存放金额的非负整数数组，计算你在不触动警报装置的情况下，能够偷窃到的最高金额。</code></pre><p>状态：当前屋号i 0&lt;=i&lt;len(nums)<br>选择：选择偷下一间屋子<br>dp定义：dp[i] 偷包括i号屋在内，能偷到的最大金额<br>状态转移方程：dp[i] = dp[i-2] + nums[i]   dp[i-1]不要，因为必须隔着来偷<br>终结状态两个：dp[len(nums)-1], dp[len(nums)-2]里边大的，因为nums长度不确定<br>起始状态：dp[0]=nums[0] dp[1]=max(nums[0], nums[1])</p><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span><span class="hljs-params">(object)</span>:</span>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">rob</span><span class="hljs-params">(self, nums)</span>:</span>        <span class="hljs-string">"""</span><span class="hljs-string">        :type nums: List[int]</span><span class="hljs-string">        :rtype: int</span><span class="hljs-string">        """</span>        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> nums:            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>        <span class="hljs-keyword">if</span> len(nums) == <span class="hljs-number">1</span>:            <span class="hljs-keyword">return</span> nums[<span class="hljs-number">0</span>]        <span class="hljs-keyword">if</span> len(nums) == <span class="hljs-number">2</span>:            <span class="hljs-keyword">return</span> max(nums[<span class="hljs-number">0</span>], nums[<span class="hljs-number">1</span>])        dp = [<span class="hljs-number">0</span> <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(len(nums))]        <span class="hljs-comment">## 上边写下边忘</span>        dp[<span class="hljs-number">0</span>]=nums[<span class="hljs-number">0</span>]        dp[<span class="hljs-number">1</span>]=max(nums[<span class="hljs-number">0</span>], nums[<span class="hljs-number">1</span>])        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(<span class="hljs-number">2</span>, len(nums), <span class="hljs-number">1</span>):            dp[i] = dp[i<span class="hljs-number">-2</span>] + nums[i]        <span class="hljs-keyword">return</span> max(dp[len(nums)<span class="hljs-number">-1</span>], dp[len(nums)<span class="hljs-number">-2</span>])</code></pre><p>这写法只能应付交错排布，不能解决其它问题。比如：<br>[1,3,1,3,100]<br>重写算法</p><p>状态：当前屋号i 0&lt;=i&lt;len(nums)<br>选择：选择偷下一间屋子<br>dp定义：dp[i] 偷包括i号屋在内，能偷到的最大金额<br>状态转移方程：dp[i] = max(dp[i-2], dp[i-3]) + nums[i]   dp[i-1]不要，因为必须隔着来偷<br>终结状态两个：dp[len(nums)-1], dp[len(nums)-2]里边大的，因为nums长度不确定, 大值不一定落到哪个上了<br>起始状态：dp[0]=nums[0] dp[1]=max(nums[0], nums[1]) dp[2]=max(nums[0]+nums[2], nums[1])</p><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span><span class="hljs-params">(object)</span>:</span>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">rob</span><span class="hljs-params">(self, nums)</span>:</span>        <span class="hljs-string">"""</span><span class="hljs-string">        :type nums: List[int]</span><span class="hljs-string">        :rtype: int</span><span class="hljs-string">        """</span>        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> nums:            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>        <span class="hljs-keyword">if</span> len(nums) == <span class="hljs-number">1</span>:            <span class="hljs-keyword">return</span> nums[<span class="hljs-number">0</span>]        <span class="hljs-keyword">if</span> len(nums) == <span class="hljs-number">2</span>:            <span class="hljs-keyword">return</span> max(nums[<span class="hljs-number">0</span>], nums[<span class="hljs-number">1</span>])        <span class="hljs-keyword">if</span> len(nums) == <span class="hljs-number">3</span>:            <span class="hljs-comment"># 下边的官方推导公式我已经写出来了，但是没意识到</span>            <span class="hljs-keyword">return</span> max(nums[<span class="hljs-number">0</span>]+nums[<span class="hljs-number">2</span>], nums[<span class="hljs-number">1</span>])        dp = [<span class="hljs-number">0</span> <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(len(nums))]        dp[<span class="hljs-number">0</span>]=nums[<span class="hljs-number">0</span>]        dp[<span class="hljs-number">1</span>]=max(nums[<span class="hljs-number">0</span>], nums[<span class="hljs-number">1</span>])        dp[<span class="hljs-number">2</span>]=max(nums[<span class="hljs-number">0</span>]+nums[<span class="hljs-number">2</span>], nums[<span class="hljs-number">1</span>])        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(<span class="hljs-number">3</span>, len(nums), <span class="hljs-number">1</span>):            dp[i] = max(dp[i<span class="hljs-number">-2</span>], dp[i<span class="hljs-number">-3</span>]) + nums[i]        <span class="hljs-keyword">return</span> max(dp[len(nums)<span class="hljs-number">-1</span>], dp[len(nums)<span class="hljs-number">-2</span>])</code></pre><p>官方的推导公式 dp[i] = max(dp[i-2] + nums[i], dp[i-1]), 试试<br>这个dp[i]的定义是偷到i屋的最大价值，不一定包括i屋在内<br>终结状态：dp[i]<br>起始状态：dp[0]=nums[0] dp[1]=max(nums[0], nums[1])</p><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span><span class="hljs-params">(object)</span>:</span>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">rob</span><span class="hljs-params">(self, nums)</span>:</span>        <span class="hljs-string">"""</span><span class="hljs-string">        :type nums: List[int]</span><span class="hljs-string">        :rtype: int</span><span class="hljs-string">        """</span>        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> nums:            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>        <span class="hljs-keyword">if</span> len(nums) == <span class="hljs-number">1</span>:            <span class="hljs-keyword">return</span> nums[<span class="hljs-number">0</span>]        <span class="hljs-keyword">if</span> len(nums) == <span class="hljs-number">2</span>:            <span class="hljs-keyword">return</span> max(nums[<span class="hljs-number">0</span>], nums[<span class="hljs-number">1</span>])        dp = [<span class="hljs-number">0</span> <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(len(nums))]        dp[<span class="hljs-number">0</span>]=nums[<span class="hljs-number">0</span>]        dp[<span class="hljs-number">1</span>]=max(nums[<span class="hljs-number">0</span>], nums[<span class="hljs-number">1</span>])        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(<span class="hljs-number">2</span>, len(nums), <span class="hljs-number">1</span>):            dp[i] = max(dp[i<span class="hljs-number">-2</span>] + nums[i], dp[i<span class="hljs-number">-1</span>])        <span class="hljs-keyword">return</span> dp[i]</code></pre>]]></content>
    
    
    <categories>
      
      <category>Leetcode</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Leetcode 121 - 买卖股票的最佳时机</title>
    <link href="/2020/05/19/leetcode-121/"/>
    <url>/2020/05/19/leetcode-121/</url>
    
    <content type="html"><![CDATA[<p>题目：</p><pre><code class="hljs quote">给定一个数组，它的第 i 个元素是一支给定股票第 i 天的价格。如果你最多只允许完成一笔交易（即买入和卖出一支股票一次），设计一个算法来计算你所能获取的最大利润。注意：你不能在买入股票前卖出股票。</code></pre><p>碰上了刚看的股票买卖问题啦，做这道最简单的<br>状态：当前是第i天，是否持有股票<br>dp定义：dp[i][0,1] 第i天持有(不持有)股票的最大利润<br>选择：dp[i][0] 可以选择买入；dp[i][1] 可以选择卖出<br>状态转换方程 :</p><ol><li>dp[i][0] = max(dp[i-1][0], dp[i-1][1] + prices[i]) 继续保持之前的最大利润，或尝试卖出之前股票获得的最大利润</li><li>dp[i][1] = max(dp[i-1][1], - prices[i]) 继续保持之前买股票的支出，或者这一天的支出小于之前天的，就更新<br>终结状态：dp[len(prices)-1][0]<br>base case:</li><li>dp[0][0,1] = 0 这里没有第0天的概念，不该有值</li><li>dp[1][0] = 0 第一天不可能有利润的，不够时间买卖；dp[1][1]=-prices[0] 第一天直接卖钱</li></ol><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span><span class="hljs-params">(object)</span>:</span>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">maxProfit</span><span class="hljs-params">(self, prices)</span>:</span>        <span class="hljs-string">"""</span><span class="hljs-string">        :type prices: List[int]</span><span class="hljs-string">        :rtype: int</span><span class="hljs-string">        """</span>                <span class="hljs-keyword">if</span> len(prices) &lt;= <span class="hljs-number">1</span>:            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>        <span class="hljs-comment">## 二维数组全部初始化为0的写法</span>        <span class="hljs-comment">## dp = [[0,0]*(len(prices)+1)]</span>        <span class="hljs-comment">## 这个写法导致dp为 [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]]</span>        <span class="hljs-comment">## 这个写法导致内部所有的[0,0]元素，指向了一个地址，下边迭代会一改全改</span>        <span class="hljs-comment">## dp = [[0,0]]*(len(prices)+1)</span>        <span class="hljs-comment">## 要通过循环来创建</span>        dp = [[<span class="hljs-number">0</span> <span class="hljs-keyword">for</span> t <span class="hljs-keyword">in</span> range(<span class="hljs-number">2</span>)] <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(len(prices)+<span class="hljs-number">1</span>)]        <span class="hljs-comment">## 第一天直接卖钱</span>        dp[<span class="hljs-number">1</span>][<span class="hljs-number">1</span>]=-prices[<span class="hljs-number">0</span>]        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(<span class="hljs-number">2</span>, len(prices)+<span class="hljs-number">1</span>, <span class="hljs-number">1</span>):            <span class="hljs-comment">## prices状态搞错了。当前状态为上一个状态转换来的</span>            <span class="hljs-comment"># dp[i][0] = max(dp[i-1][0], dp[i-1][1] + prices[i])</span>            <span class="hljs-comment"># dp[i][1] = max(dp[i-1][1], dp[i-1][0] - prices[i])</span>            dp[i][<span class="hljs-number">0</span>] = max(dp[i<span class="hljs-number">-1</span>][<span class="hljs-number">0</span>], dp[i<span class="hljs-number">-1</span>][<span class="hljs-number">1</span>] + prices[i<span class="hljs-number">-1</span>])            <span class="hljs-comment">## k最大交易次数忘了，这里k属于[0,1],不能进行多次交易的。死抄答案要死。 dp[i-1][0] - prices[i-1]不需要，是因为只交易一次，没有二次交易存在，所以不需在老利润基础上搞事情</span>            <span class="hljs-comment">## dp[i][1] = max(dp[i-1][1], dp[i-1][0] - prices[i-1])</span>            dp[i][<span class="hljs-number">1</span>] = max(dp[i<span class="hljs-number">-1</span>][<span class="hljs-number">1</span>], - prices[i<span class="hljs-number">-1</span>])        <span class="hljs-keyword">return</span> dp[<span class="hljs-number">-1</span>][<span class="hljs-number">0</span>]</code></pre><p>做个题艰难得要命<br><a href="https://blog.csdn.net/qq_32799915/article/details/86520438" target="_blank" rel="noopener">同样被初始化坑了的同学</a></p>]]></content>
    
    
    <categories>
      
      <category>Leetcode</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Leetcode 70 - 爬楼梯</title>
    <link href="/2020/05/19/leetcode-70/"/>
    <url>/2020/05/19/leetcode-70/</url>
    
    <content type="html"><![CDATA[<p>题目：</p><pre><code class="hljs quote">假设你正在爬楼梯。需要 n 阶你才能到达楼顶。每次你可以爬 1 或 2 个台阶。你有多少种不同的方法可以爬到楼顶呢？注意：给定 n 是一个正整数。</code></pre><p>现在有点挫败感，动态规划的模板不好套啊。还是从简单的搞起来，过几道，不会的跳过做出两个再说<br>状态：当前在第i阶，0&lt;=i&lt;=n<br>选择：向上1或2阶<br>dp(i)含义：到第i阶时的走法总和<br>终结态：dp(n-1)<br>状态转换方程：dp(i) = dp(i-2) + dp(i-1)，两种状态再进一步就到新状态，所以新状态的总走法就是前两状态的总走法和。这么像斐波那契数列呢<br>初始态：dp(0) = 1 本来不存在的，帮助迭代；dp(1) = 1 有一个台阶，只有1种走法</p><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span><span class="hljs-params">(object)</span>:</span>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">climbStairs</span><span class="hljs-params">(self, n)</span>:</span>        <span class="hljs-string">"""</span><span class="hljs-string">        :type n: int</span><span class="hljs-string">        :rtype: int</span><span class="hljs-string">        """</span>        <span class="hljs-keyword">if</span> n == <span class="hljs-number">1</span>:            <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>        dp = [<span class="hljs-number">1</span>]*(n+<span class="hljs-number">1</span>)                <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(<span class="hljs-number">2</span>, n+<span class="hljs-number">1</span>, <span class="hljs-number">1</span>):            dp[i] = dp[i<span class="hljs-number">-2</span>]+dp[i<span class="hljs-number">-1</span>]        <span class="hljs-keyword">return</span> dp[n]</code></pre><p>简化空间，每步只要记住前两个就行了</p><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span><span class="hljs-params">(object)</span>:</span>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">climbStairs</span><span class="hljs-params">(self, n)</span>:</span>        <span class="hljs-string">"""</span><span class="hljs-string">        :type n: int</span><span class="hljs-string">        :rtype: int</span><span class="hljs-string">        """</span>        <span class="hljs-keyword">if</span> n == <span class="hljs-number">1</span>:            <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>        pre1 = <span class="hljs-number">1</span>        pre2 = <span class="hljs-number">1</span>                <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(<span class="hljs-number">2</span>, n+<span class="hljs-number">1</span>, <span class="hljs-number">1</span>):            cur = pre2 + pre1            pre1 = pre2            pre2 = cur        <span class="hljs-keyword">return</span> pre2</code></pre>]]></content>
    
    
    <categories>
      
      <category>Leetcode</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Leetcode 680 - 验证回文字符串 Ⅱ</title>
    <link href="/2020/05/19/leetcode-680/"/>
    <url>/2020/05/19/leetcode-680/</url>
    
    <content type="html"><![CDATA[<p>题目：</p><pre><code class="hljs quote">给定一个非空字符串 s，最多删除一个字符。判断是否能成为回文字符串。</code></pre><p>双指针玩法，从两头向中间走，最多跳过一个字符。为什么不从中间往两头走，因为这个串的二分查找中点起始状态有点难判断</p><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span><span class="hljs-params">(object)</span>:</span>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">validPalindrome</span><span class="hljs-params">(self, s)</span>:</span>        <span class="hljs-string">"""</span><span class="hljs-string">        :type s: str</span><span class="hljs-string">        :rtype: bool</span><span class="hljs-string">        """</span>        pointer = <span class="hljs-number">0</span>        delete_times = <span class="hljs-number">0</span>        offset_right = <span class="hljs-number">0</span>        offset_left = <span class="hljs-number">0</span>        <span class="hljs-comment"># 这个判断条件不用管奇偶了。用的下标所以多减1</span>        <span class="hljs-keyword">while</span> pointer &lt;= len(s)<span class="hljs-number">-1</span>-pointer:            <span class="hljs-keyword">if</span> s[pointer+offset_left] != s[len(s)<span class="hljs-number">-1</span>-pointer+offset_right]:                delete_times += <span class="hljs-number">1</span>                <span class="hljs-keyword">if</span> s[pointer] == s[len(s)<span class="hljs-number">-1</span>-pointer<span class="hljs-number">-1</span>]:                    offset_right = <span class="hljs-number">-1</span>                <span class="hljs-keyword">elif</span> s[pointer+<span class="hljs-number">1</span>] == s[len(s)<span class="hljs-number">-1</span>-pointer]:                    offset_left = <span class="hljs-number">1</span>                <span class="hljs-keyword">else</span>:                    <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span>            <span class="hljs-keyword">if</span> delete_times &gt; <span class="hljs-number">1</span>:                <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span>            pointer += <span class="hljs-number">1</span>        <span class="hljs-keyword">return</span> <span class="hljs-literal">True</span></code></pre><p>以上解法错误。漏了情况。像下边的字串应该删左边的e，而不是右边的c。代码逻辑要大改<br>“ececabbacec”</p><p>改造一下。两头走，找到不相同的位置，尝试左右两种删除方式的折半对比，都不行，就返回False，其它情况是True</p><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span><span class="hljs-params">(object)</span>:</span>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">validPalindrome</span><span class="hljs-params">(self, s)</span>:</span>        <span class="hljs-string">"""</span><span class="hljs-string">        :type s: str</span><span class="hljs-string">        :rtype: bool</span><span class="hljs-string">        """</span>        pointer = <span class="hljs-number">0</span>        checkpoint = <span class="hljs-literal">None</span>        <span class="hljs-keyword">while</span> pointer &lt;= len(s)<span class="hljs-number">-1</span>-pointer:            <span class="hljs-keyword">if</span> s[pointer] != s[len(s)<span class="hljs-number">-1</span>-pointer]:                checkpoint = pointer                <span class="hljs-keyword">break</span>            pointer += <span class="hljs-number">1</span>        <span class="hljs-keyword">if</span> checkpoint == <span class="hljs-literal">None</span>:            <span class="hljs-keyword">return</span> <span class="hljs-literal">True</span>        <span class="hljs-keyword">else</span>:            <span class="hljs-comment"># 开始实验两种删除方法后，能否对比到底</span>            <span class="hljs-comment">## [:]闭开区间，闭区间是可以取的，开区间不包括端点</span>            try1 = list(s)[checkpoint:(len(s)<span class="hljs-number">-1</span>-checkpoint)]            try2 = list(s)[(checkpoint+<span class="hljs-number">1</span>):(len(s)-checkpoint)]            <span class="hljs-comment">## reverse()是没法进行这种计较的，用[::-1]反转列表</span>            <span class="hljs-comment"># if try1 == try1.reverse() or try2 == try2.reverse():</span>            <span class="hljs-keyword">if</span> try1 == try1[::<span class="hljs-number">-1</span>] <span class="hljs-keyword">or</span> try2 == try2[::<span class="hljs-number">-1</span>]:                <span class="hljs-keyword">return</span> <span class="hljs-literal">True</span>            <span class="hljs-keyword">else</span>:                <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span></code></pre><p>我的答案速度才击败12%<br>正确答案和我思路一样。原来这种思考方式属于贪心算法。<br>看了之后的感觉：</p><ol><li>想到双指针了，还用单指针实现，啰嗦</li><li>代码写的比较繁琐难读，像最后4行可以合并的</li><li>后半去反转列表，当然效率低</li></ol><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span>:</span>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">validPalindrome</span><span class="hljs-params">(self, s: str)</span> -&gt; bool:</span>        <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">checkPalindrome</span><span class="hljs-params">(low, high)</span>:</span>            i, j = low, high            <span class="hljs-keyword">while</span> i &lt; j:                <span class="hljs-keyword">if</span> s[i] != s[j]:                    <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span>                i += <span class="hljs-number">1</span>                j -= <span class="hljs-number">1</span>            <span class="hljs-keyword">return</span> <span class="hljs-literal">True</span>        low, high = <span class="hljs-number">0</span>, len(s) - <span class="hljs-number">1</span>        <span class="hljs-keyword">while</span> low &lt; high:            <span class="hljs-keyword">if</span> s[low] == s[high]:                 low += <span class="hljs-number">1</span>                high -= <span class="hljs-number">1</span>            <span class="hljs-keyword">else</span>:                <span class="hljs-keyword">return</span> checkPalindrome(low + <span class="hljs-number">1</span>, high) <span class="hljs-keyword">or</span> checkPalindrome(low, high - <span class="hljs-number">1</span>)        <span class="hljs-keyword">return</span> <span class="hljs-literal">True</span></code></pre>]]></content>
    
    
    <categories>
      
      <category>Leetcode</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Leetcode 152 - 乘积最大子数组</title>
    <link href="/2020/05/18/leetcode-152/"/>
    <url>/2020/05/18/leetcode-152/</url>
    
    <content type="html"><![CDATA[<p>题目：</p><pre><code class="hljs quote">给你一个整数数组 nums ，请你找出数组中乘积最大的连续子数组（该子数组中至少包含一个数字），并返回该子数组所对应的乘积。</code></pre><p>前几天有做过一道和为k的字符串字串个数的题，已经模糊了回忆一下。用的前缀和创建的字典来降维的。这里是否是用前缀乘积？好像不是，因为这是极值，不是求个数<br>子数组可能不止一个，不过乘积相同返回结果就行，也没差</p><p>每轮迭代，nums[:i+1]中所有可能组合的最大值<br>reduce忘了用法，再记一次：reduce(lambda x, y: x+y, nums[slow_pointer:fast_pointer+1])</p><p>暴力法，时间超出限制，意料之中：</p><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span><span class="hljs-params">(object)</span>:</span>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">maxProduct</span><span class="hljs-params">(self, nums)</span>:</span>        <span class="hljs-string">"""</span><span class="hljs-string">        :type nums: List[int]</span><span class="hljs-string">        :rtype: int</span><span class="hljs-string">        """</span>        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> nums:            <span class="hljs-keyword">return</span>        res = float(<span class="hljs-string">"-inf"</span>)        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(<span class="hljs-number">0</span>, len(nums), <span class="hljs-number">1</span>):            <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> range(<span class="hljs-number">0</span>, i+<span class="hljs-number">1</span>, <span class="hljs-number">1</span>):                <span class="hljs-comment"># res = max(res, reduce(m*n for m, n in nums[j:i+1])) 忘了怎么用reduce了</span>                res = max(res, reduce(<span class="hljs-keyword">lambda</span> m, n: m*n, nums[j:i+<span class="hljs-number">1</span>]))        <span class="hljs-keyword">return</span> res</code></pre><p>看答案前，想到了正负值情况要分别处理，因为当前值如果是负的，则乘积会把之前循环的最小值变成最大的<br>也想到了，当前最大值，为前一循环最大值*当前值和当前值两个里边大的那个。但是其实里边是两层逻辑，这里少考虑了一层<br>正确思考方向是：</p><ol><li>当前循环求的是以包括当前值在内(作为子数组尾部)的最大子数组，该数组是前一循环最大子数组*当前值，和当前值两个中大的那一个；</li><li>要求的最终结果，是当前循环最大子数组的结果，和之前所有循环最大子数组结果里最大那个，两个中大的</li></ol><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span><span class="hljs-params">(object)</span>:</span>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">maxProduct</span><span class="hljs-params">(self, nums)</span>:</span>        <span class="hljs-string">"""</span><span class="hljs-string">        :type nums: List[int]</span><span class="hljs-string">        :rtype: int</span><span class="hljs-string">        """</span>        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> nums:            <span class="hljs-keyword">return</span>        res = float(<span class="hljs-string">"-inf"</span>)        imax = <span class="hljs-number">1</span>        imin = <span class="hljs-number">1</span>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(<span class="hljs-number">0</span>, len(nums), <span class="hljs-number">1</span>):            <span class="hljs-keyword">if</span> nums[i] &lt; <span class="hljs-number">0</span>:                imax, imin = imin, imax                        <span class="hljs-comment"># 这里纠结了好一会儿，没想明白前一循环imax就是一定包含nums[i-1]的，和nums[i]一定相邻</span>            imax = max(imax*nums[i], nums[i])            imin = min(imin*nums[i], nums[i])            res = max(res, imax)        <span class="hljs-keyword">return</span> res</code></pre>]]></content>
    
    
    <categories>
      
      <category>Leetcode</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Leetcode 496 - 下一个更大元素 I</title>
    <link href="/2020/05/15/leetcode-496/"/>
    <url>/2020/05/15/leetcode-496/</url>
    
    <content type="html"><![CDATA[<p>题目：</p><pre><code class="hljs quote">给定两个 没有重复元素 的数组 nums1 和 nums2 ，其中nums1 是 nums2 的子集。找到 nums1 中每个元素在 nums2 中的下一个比其大的值。nums1 中数字 x 的下一个更大元素是指 x 在 nums2 中对应位置的右边的第一个比 x 大的元素。如果不存在，对应位置输出 -1 。</code></pre><p>遍历一遍nums2，肯定走了一遍nums1的元素了。先处理一下nums1的元素，方便遍历nums2时候好找</p><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span><span class="hljs-params">(object)</span>:</span>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">nextGreaterElement</span><span class="hljs-params">(self, nums1, nums2)</span>:</span>        <span class="hljs-string">"""</span><span class="hljs-string">        :type nums1: List[int]</span><span class="hljs-string">        :type nums2: List[int]</span><span class="hljs-string">        :rtype: List[int]</span><span class="hljs-string">        """</span>        <span class="hljs-comment"># 元素做k，位置做v</span>        dic = &#123;nums1[i]:i <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(<span class="hljs-number">0</span>, len(nums1), <span class="hljs-number">1</span>)&#125;        res =[<span class="hljs-number">-1</span>]*len(nums1)        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(<span class="hljs-number">0</span>, len(nums2), <span class="hljs-number">1</span>):            <span class="hljs-keyword">if</span> nums2[i] <span class="hljs-keyword">in</span> dic:                <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> range(i+<span class="hljs-number">1</span>, len(nums2), <span class="hljs-number">1</span>):                    <span class="hljs-keyword">if</span> nums2[i] &lt; nums2[j]:                        res[dic[nums2[i]]] = nums2[j]                        <span class="hljs-comment"># 刚还想着却忘了，继续往下算就错了</span>                        <span class="hljs-keyword">break</span>        <span class="hljs-keyword">return</span> res</code></pre><p>可算自己作对了一道，不过时间复杂度O(n^2)，官方答案用栈O(m+n)，研究一下<br>看懂思路了，不管nums1，只处理nums2<br>用单调递增栈（从顶到底）中间处理，生成一个所有nums2元素的字典，k为元素值，v为该元素对应的下一个比其大数的数。如没有就最后出栈，v设为-1<br>然后过一遍nums1，对应到字典就行。自己写一个<br>看起来和我的复杂性差不多啊。但就是比我的快</p><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span><span class="hljs-params">(object)</span>:</span>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">nextGreaterElement</span><span class="hljs-params">(self, nums1, nums2)</span>:</span>        <span class="hljs-string">"""</span><span class="hljs-string">        :type nums1: List[int]</span><span class="hljs-string">        :type nums2: List[int]</span><span class="hljs-string">        :rtype: List[int]</span><span class="hljs-string">        """</span>        stack = []        map = &#123;&#125;        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> nums2:            <span class="hljs-keyword">while</span> stack:                pre = stack.pop()                <span class="hljs-keyword">if</span> pre &lt; i:                    map[pre] = i                <span class="hljs-keyword">else</span>:                    stack.append(pre)                    <span class="hljs-keyword">break</span>            stack.append(i)        <span class="hljs-keyword">while</span> stack:            map[stack.pop()] = <span class="hljs-number">-1</span>        <span class="hljs-keyword">return</span> [map[i] <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> nums1]</code></pre><p>抄一个更好的代码块</p><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span>:</span>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">nextGreaterElement</span><span class="hljs-params">(self, nums1, nums2)</span>:</span>        stack, hash = [], &#123;&#125;        <span class="hljs-keyword">for</span> n <span class="hljs-keyword">in</span> nums2:            <span class="hljs-comment"># stack[-1]用来作栈顶判断，如果满足条件再pop，我命名为懒pop，这样也少了一堆无效pop和append，代码也容易看了</span>            <span class="hljs-keyword">while</span> stack <span class="hljs-keyword">and</span> stack[<span class="hljs-number">-1</span>] &lt; n:                hash[stack.pop()] = n            stack.append(n)                <span class="hljs-comment"># 这块比我写的简洁，顶我后4行</span>        <span class="hljs-keyword">return</span> [hash.get(x, <span class="hljs-number">-1</span>) <span class="hljs-keyword">for</span> x <span class="hljs-keyword">in</span> nums1]</code></pre>]]></content>
    
    
    <categories>
      
      <category>Leetcode</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Leetcode 560 - 和为K的子数组</title>
    <link href="/2020/05/15/leetcode-560/"/>
    <url>/2020/05/15/leetcode-560/</url>
    
    <content type="html"><![CDATA[<p>题目：</p><pre><code class="hljs quote">给定一个整数数组和一个整数 k，你需要找到该数组中和为 k 的连续的子数组的个数。</code></pre><p>先想到快慢指针问题。<br>如果快慢指针区间数和等于k，res+1。慢指针不动快指针动，如果大于k，慢指针动(如果满指针赶上快指针，一块动)，直到再次小于等于k，快指针继续。终结条件是快指针走到头且区间数和&lt;k，结束。</p><p>sums中可能有负数的，这个写法默认所有值为正整数，玩不转。这路子我只能想到O(n^2)全覆盖了，暴力</p><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span><span class="hljs-params">(object)</span>:</span>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">subarraySum</span><span class="hljs-params">(self, nums, k)</span>:</span>        <span class="hljs-string">"""</span><span class="hljs-string">        :type nums: List[int]</span><span class="hljs-string">        :type k: int</span><span class="hljs-string">        :rtype: int</span><span class="hljs-string">        """</span>        fast_pointer = <span class="hljs-number">0</span>        slow_pointer = <span class="hljs-number">0</span>        res = <span class="hljs-number">0</span>        <span class="hljs-keyword">while</span> fast_pointer &lt; len(nums):            current_sum = reduce(<span class="hljs-keyword">lambda</span> x, y: x+y, nums[slow_pointer:fast_pointer+<span class="hljs-number">1</span>])            <span class="hljs-keyword">print</span> str(current_sum) + <span class="hljs-string">"====="</span> + str(slow_pointer) + <span class="hljs-string">"====="</span> + str(fast_pointer)            <span class="hljs-keyword">if</span> current_sum == k:                res += <span class="hljs-number">1</span>                fast_pointer += <span class="hljs-number">1</span>            <span class="hljs-keyword">elif</span> current_sum &gt; k:                slow_pointer += <span class="hljs-number">1</span>                <span class="hljs-keyword">if</span> slow_pointer &gt; fast_pointer:                    fast_pointer += <span class="hljs-number">1</span>            <span class="hljs-keyword">elif</span> current_sum &lt; k:                fast_pointer += <span class="hljs-number">1</span>        <span class="hljs-keyword">return</span> res</code></pre><h2 id="暴力了，大力出奇迹。时间都溢出了"><a href="#暴力了，大力出奇迹。时间都溢出了" class="headerlink" title="暴力了，大力出奇迹。时间都溢出了"></a>暴力了，大力出奇迹。时间都溢出了</h2><p>中间结果会多次计算，独立子问题，动态规划？但是这题又不是求最值的。 问题也不独立啊<br>暴力解超时。还有sum多一维，O(n^3).其实这个也可以用前缀和降维一次，但是leetcode仍然超时，算了</p><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span><span class="hljs-params">(object)</span>:</span>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">subarraySum</span><span class="hljs-params">(self, nums, k)</span>:</span>        <span class="hljs-string">"""</span><span class="hljs-string">        :type nums: List[int]</span><span class="hljs-string">        :type k: int</span><span class="hljs-string">        :rtype: int</span><span class="hljs-string">        """</span>        res = <span class="hljs-number">0</span>        <span class="hljs-keyword">for</span> fast_pointer <span class="hljs-keyword">in</span> range(<span class="hljs-number">0</span>, len(nums), <span class="hljs-number">1</span>):            <span class="hljs-keyword">for</span> slow_pointer <span class="hljs-keyword">in</span> range(<span class="hljs-number">0</span>, fast_pointer + <span class="hljs-number">1</span>, <span class="hljs-number">1</span>):                <span class="hljs-keyword">if</span> sum(nums[slow_pointer:fast_pointer+<span class="hljs-number">1</span>]) == k:                    res += <span class="hljs-number">1</span>        <span class="hljs-keyword">return</span> res</code></pre><p>想不到，看提示了<br>sum(i,j)=sum(0,j)-sum(0,i) 和 dict<br>脑子不灵想不到这一层。隐约知道中间结果可以字典存存，但是想不出怎么用。照着这个思路来试写，改来改去没改对<br>错误解</p><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span><span class="hljs-params">(object)</span>:</span>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">subarraySum</span><span class="hljs-params">(self, nums, k)</span>:</span>        <span class="hljs-string">"""</span><span class="hljs-string">        :type nums: List[int]</span><span class="hljs-string">        :type k: int</span><span class="hljs-string">        :rtype: int</span><span class="hljs-string">        """</span>        res = <span class="hljs-number">0</span>        holder= &#123;&#125;        holder[<span class="hljs-number">-1</span>] = <span class="hljs-number">0</span>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(<span class="hljs-number">0</span>, len(nums), <span class="hljs-number">1</span>):            holder[i] = sum(nums[:i+<span class="hljs-number">1</span>])        <span class="hljs-keyword">print</span> holder        <span class="hljs-keyword">for</span> fast_pointer <span class="hljs-keyword">in</span> range(<span class="hljs-number">0</span>, len(nums), <span class="hljs-number">1</span>):            <span class="hljs-keyword">for</span> slow_pointer <span class="hljs-keyword">in</span> range(<span class="hljs-number">-1</span>, fast_pointer, <span class="hljs-number">1</span>):                <span class="hljs-keyword">print</span> str(slow_pointer) + <span class="hljs-string">"====="</span> + str(fast_pointer)                <span class="hljs-keyword">if</span> holder[fast_pointer]-holder[slow_pointer] == k:                    <span class="hljs-keyword">print</span> <span class="hljs-string">"record: "</span> + str(holder[fast_pointer]) + <span class="hljs-string">"====="</span> + str(holder[slow_pointer])                    res += <span class="hljs-number">1</span>        <span class="hljs-keyword">return</span> res</code></pre><p>只能答案了。答案看了一大顿也半懂不懂的。绕死了，不过当天打卡题，硬着头皮看懂了，大半天哎</p><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span>:</span>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">subarraySum</span><span class="hljs-params">(self, nums: List[int], k: int)</span> -&gt; int:</span>        pre = <span class="hljs-number">0</span>        count = <span class="hljs-number">0</span>        <span class="hljs-comment"># 以前缀和为key，以前缀和key出现的次数为value。比如[1,2,1,-1], 前缀和3的情况次数2，这样再往后的连续字串有两种取法，包括和不包括[1,-1]结果都一样，结果该+2</span>        <span class="hljs-comment"># 初始化的意义是，sum([:n])-k==0, 这样字串从头算到n正好是k的串，结果可以+1.当然后续迭代前缀和又等于0了，dic[0]也要自加1的</span>        dic = &#123;<span class="hljs-number">0</span>:<span class="hljs-number">1</span>&#125;        <span class="hljs-comment"># 每轮统计，以第一个元素开始该轮元素结尾的子串前缀和 - k = 一个值</span>        <span class="hljs-comment"># 这个值在之前轮次计算子串组合中，有几种组合方式，去字典中找。 找到总结果就该加几</span>        <span class="hljs-comment"># 当前轮次的前缀和在字典中的v值+1，如不存在就加个新k</span>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> nums:            <span class="hljs-comment"># 每轮只记录这一轮的前缀和</span>            pre += i            <span class="hljs-keyword">if</span> (pre-k) <span class="hljs-keyword">in</span> dic:                count += dic[pre-k]            dic[pre] = dic.get(pre,<span class="hljs-number">0</span>) + <span class="hljs-number">1</span>        <span class="hljs-keyword">return</span> count</code></pre><p>另外抄一个说明多一点的方便理解</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">subarraySum</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums, <span class="hljs-keyword">int</span> k)</span> </span>&#123;        <span class="hljs-comment">// hash</span>        <span class="hljs-comment">// 记录合适的连续字符串数量</span>        <span class="hljs-keyword">int</span> count=<span class="hljs-number">0</span>;        <span class="hljs-comment">// 记录前面数字相加之和</span>        <span class="hljs-keyword">int</span> pre=<span class="hljs-number">0</span>;        <span class="hljs-comment">// map记录前几个数字之和为K出现相同和的次数为V</span>        HashMap&lt;Integer,Integer&gt; map = <span class="hljs-keyword">new</span> HashMap&lt;&gt;();        <span class="hljs-comment">// 初始化</span>        map.put(<span class="hljs-number">0</span>,<span class="hljs-number">1</span>);        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; nums.length; i++) &#123;            pre+= nums[i];            <span class="hljs-comment">// 如果前面数字之和加上这个数字正好等于K（存在一个数字加上nums[i]结果为K</span>            <span class="hljs-comment">// 说明找到了</span>            <span class="hljs-keyword">if</span> (map.containsKey(pre-k))&#123;                <span class="hljs-comment">// 累计</span>                count+=map.get(pre-k);            &#125;            <span class="hljs-comment">// 计算新的和放入map</span>            map.put(pre,map.getOrDefault(pre,<span class="hljs-number">0</span>)+<span class="hljs-number">1</span>);        &#125;        <span class="hljs-keyword">return</span> count;    &#125;</code></pre><p>抄来一些别人的讲解：</p><pre><code class="hljs quote">前缀和：这个优化主要是用来在O（1）时间内求出一个序列a中,a[i]+a[i+1]+……+a[j]的和。核心就两个字：降维。面对许多高维问题，往往前缀和是最先想到的降维方法。 这样在降维的基础上，许多更进一步的优化才能实现。</code></pre>]]></content>
    
    
    <categories>
      
      <category>Leetcode</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Leetcode 136 - 只出现一次的数字</title>
    <link href="/2020/05/14/leetcode-136/"/>
    <url>/2020/05/14/leetcode-136/</url>
    
    <content type="html"><![CDATA[<p>题目：</p><pre><code class="hljs quote">给定一个非空整数数组，除了某个元素只出现一次以外，其余每个元素均出现两次。找出那个只出现了一次的元素。说明：你的算法应该具有线性时间复杂度。 你可以不使用额外空间来实现吗？</code></pre><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span><span class="hljs-params">(object)</span>:</span>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">singleNumber</span><span class="hljs-params">(self, nums)</span>:</span>        <span class="hljs-string">"""</span><span class="hljs-string">        :type nums: List[int]</span><span class="hljs-string">        :rtype: int</span><span class="hljs-string">        """</span>        <span class="hljs-comment"># sort函数不需要重新赋值了，否则nums会是None。复制空间的函数叫sorted，除了排序list之外还能排元组，字典，更灵活，但消耗内存</span>        <span class="hljs-comment"># nums = nums.sort()</span>        nums.sort()        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(<span class="hljs-number">0</span>, len(nums), <span class="hljs-number">2</span>):            <span class="hljs-keyword">if</span> i == len(nums) - <span class="hljs-number">1</span>:                <span class="hljs-keyword">return</span> nums[<span class="hljs-number">-1</span>]            <span class="hljs-keyword">elif</span> nums[i] != nums[i+<span class="hljs-number">1</span>]:                <span class="hljs-keyword">return</span> nums[i]</code></pre><p>官方答案用的位运算，异或所有列表中的值。异或满足交换律和结合律，相同的数异或后是0，0和单独的数异或是单独的数</p><pre><code class="hljs python3">class Solution:    def singleNumber(self, nums: List[int]) -&gt; int:        return reduce(lambda x, y: x ^ y, nums)</code></pre><p>^ 为异或运算；reduce函数使用如下引用。想想mapreduce是怎么玩的就了解了</p><pre><code class="hljs quote">reduce() 函数会对参数序列中元素进行累积。函数将一个数据集合（链表，元组等）中的所有数据进行下列操作：用传给 reduce 中的函数 function（有两个参数）先对集合中的第 1、2 个元素进行操作，得到的结果再与第三个数据用 function 函数运算，最后得到一个结果。</code></pre>]]></content>
    
    
    <categories>
      
      <category>Leetcode</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Leetcode 105 - 从前序与中序遍历序列构造二叉树</title>
    <link href="/2020/05/13/leetcode-105/"/>
    <url>/2020/05/13/leetcode-105/</url>
    
    <content type="html"><![CDATA[<p>题目：</p><pre><code class="hljs quote">根据一棵树的前序遍历与中序遍历构造二叉树。</code></pre><p>遍历树的逆运算。所谓前中后，就是（左节点，父节点，右节点）中，父节点在前中后位置处理<br>前序第一个值肯定是root<br>两种排序里，右节点的位置不会变。猜想应该从后往前构造树。从子节点开始构造，迭代更好一些的感觉<br>有想了想，如果树右下角没有右叶子，两list最后一位就不一样。所以从后往前推还不如从前往后推的感觉了</p><hr><p>想不到解法，抄了题解中的一步思路试试</p><pre><code class="hljs quote">首先，preorder 中的第一个元素一定是树的根，**这个根又将 inorder 序列分成了左右两棵子树。**现在我们只需要将先序遍历的数组中删除根元素，然后重复上面的过程处理左右两棵子树</code></pre><p>这说法，是将左右子树分治了, 利用preorder拆inorder，然后进入迭代解决子问题。试试</p><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span><span class="hljs-params">(object)</span>:</span>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">buildTree</span><span class="hljs-params">(self, preorder, inorder)</span>:</span>        <span class="hljs-string">"""</span><span class="hljs-string">        :type preorder: List[int]</span><span class="hljs-string">        :type inorder: List[int]</span><span class="hljs-string">        :rtype: TreeNode</span><span class="hljs-string">        """</span>                <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">buildSubTree</span><span class="hljs-params">(preorder, inorder)</span>:</span>            <span class="hljs-comment"># 已经没得计算了</span>            <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> preorder:                <span class="hljs-keyword">return</span>            node = TreeNode(preorder[<span class="hljs-number">0</span>], <span class="hljs-literal">None</span>, <span class="hljs-literal">None</span>)            <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(<span class="hljs-number">0</span>, len(inorder), <span class="hljs-number">1</span>):                <span class="hljs-keyword">if</span> inorder[i] == preorder[<span class="hljs-number">0</span>]:                    <span class="hljs-comment"># 拆分preorder和inorder。中括号里是取数组区段的开闭区间。控制一下i溢出的情况</span>                    <span class="hljs-comment">## 2020/05/22：这个数组切片不会溢出吧</span>                    left_preorder, right_preorder = preorder[<span class="hljs-number">1</span>:i+<span class="hljs-number">1</span>], preorder[i+<span class="hljs-number">1</span>:] <span class="hljs-keyword">if</span> i &lt; len(preorder)<span class="hljs-number">-1</span> <span class="hljs-keyword">else</span> []                    left_inorder, right_inorder = inorder[:i], inorder[i+<span class="hljs-number">1</span>:] <span class="hljs-keyword">if</span> i &lt; len(inorder)<span class="hljs-number">-1</span> <span class="hljs-keyword">else</span> []                    <span class="hljs-keyword">break</span>            node.left = buildSubTree(left_preorder, left_inorder)            node.right = buildSubTree(right_preorder, right_inorder)            <span class="hljs-keyword">return</span> node        <span class="hljs-keyword">return</span> buildSubTree(preorder, inorder)</code></pre><p>迭代里边带循环，效率在后10%。开始抄(精选答案)作业，这个和我思路一致</p><ol><li>list.index可以返回位置，省了一个循环处理</li><li>[:]形式截取字符串不用担心溢出，超出了只会返回空，已自己测试过</li></ol><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span><span class="hljs-params">(object)</span>:</span>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">buildTree</span><span class="hljs-params">(self, preorder, inorder)</span>:</span>        <span class="hljs-string">"""</span><span class="hljs-string">        :type preorder: List[int]</span><span class="hljs-string">        :type inorder: List[int]</span><span class="hljs-string">        :rtype: TreeNode</span><span class="hljs-string">        """</span>        <span class="hljs-keyword">if</span> len(inorder) == <span class="hljs-number">0</span>:            <span class="hljs-keyword">return</span> <span class="hljs-literal">None</span>        <span class="hljs-comment"># 前序遍历第一个值为根节点</span>        root = TreeNode(preorder[<span class="hljs-number">0</span>])        <span class="hljs-comment"># 因为没有重复元素，所以可以直接根据值来查找根节点在中序遍历中的位置</span>        mid = inorder.index(preorder[<span class="hljs-number">0</span>])        <span class="hljs-comment"># 构建左子树</span>        root.left = self.buildTree(preorder[<span class="hljs-number">1</span>:mid+<span class="hljs-number">1</span>], inorder[:mid])        <span class="hljs-comment"># 构建右子树</span>        root.right = self.buildTree(preorder[mid+<span class="hljs-number">1</span>:], inorder[mid+<span class="hljs-number">1</span>:])                <span class="hljs-keyword">return</span> root</code></pre><p>官方还有O(n)时间复杂度的答案，留待以后看吧</p><p>===========================================================================</p><h2 id="2020-05-22："><a href="#2020-05-22：" class="headerlink" title="2020/05/22："></a>2020/05/22：</h2><p>这个每日一题之前写过了，当时没思路看了提示做出来。重新做试试。另外还有时间复杂度O(n)的方法跳过了，试试做下<br>前序遍历的第一个一定是根节点<br>前序树根，在中序里的左边部分是左子树，右边部分全部是右子树。前序遍历也在这个分割点切开，左边是左子树的前序遍历，右边是右子树的前序遍历<br>迭代可行</p><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span><span class="hljs-params">(object)</span>:</span>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">buildTree</span><span class="hljs-params">(self, preorder, inorder)</span>:</span>        <span class="hljs-string">"""</span><span class="hljs-string">        :type preorder: List[int]</span><span class="hljs-string">        :type inorder: List[int]</span><span class="hljs-string">        :rtype: TreeNode</span><span class="hljs-string">        """</span>        <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">buildSubTree</span><span class="hljs-params">(preorder, inorder)</span>:</span>            <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> preorder <span class="hljs-keyword">or</span> <span class="hljs-keyword">not</span> inorder:                <span class="hljs-keyword">return</span> <span class="hljs-literal">None</span>            node = TreeNode(preorder[<span class="hljs-number">0</span>])            <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(len(inorder)):                <span class="hljs-keyword">if</span> preorder[<span class="hljs-number">0</span>] == inorder[i]:                    <span class="hljs-comment">## 数组切片到终点的不用明写出来</span>                    node.left = buildSubTree(preorder[<span class="hljs-number">1</span>:i+<span class="hljs-number">1</span>], inorder[<span class="hljs-number">0</span>:i])                    node.right = buildSubTree(preorder[i+<span class="hljs-number">1</span>:len(preorder)+<span class="hljs-number">1</span>], inorder[i+<span class="hljs-number">1</span>:len(inorder)+<span class="hljs-number">1</span>])                    <span class="hljs-comment">## 效率低，这里少了个break，没必要继续比对到头</span>                    <span class="hljs-keyword">break</span>            <span class="hljs-keyword">return</span> node        <span class="hljs-keyword">return</span> buildSubTree(preorder, inorder)</code></pre><p>一遍搞定不过比原来效率还低好多噢</p><p>正确答案两种，递归和迭代（借助stack）<br>用{值：坐标}来建立中序遍历的字典，空间复杂度增加了，但是可以在常数时间找到前序遍历当前根在中序遍历中的位置了<br>index = {element: i for i, element in enumerate(inorder)}</p><p>要是还有机会回来搞，写个迭代的</p>]]></content>
    
    
    <categories>
      
      <category>Leetcode</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Leetcode 124 - 二叉树中的最大路径和</title>
    <link href="/2020/05/13/leetcode-124/"/>
    <url>/2020/05/13/leetcode-124/</url>
    
    <content type="html"><![CDATA[<p>题目：</p><pre><code class="hljs quote">给定一个非空二叉树，返回其最大路径和。本题中，路径被定义为一条从树中任意节点出发，达到任意节点的序列。该路径至少包含一个节点，且不一定经过根节点。</code></pre><p>尝试后序遍历(失败)</p><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span><span class="hljs-params">(object)</span>:</span>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">maxPathSum</span><span class="hljs-params">(self, root)</span>:</span>        <span class="hljs-string">"""</span><span class="hljs-string">        :type root: TreeNode</span><span class="hljs-string">        :rtype: int</span><span class="hljs-string">        """</span>                <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> root: <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>        <span class="hljs-comment"># 不能给空叶子节点赋0，否则当前节点值为负数的话max就算错了</span>        max_sum_left = self.maxPathSum(root.left) <span class="hljs-keyword">if</span> root.left <span class="hljs-keyword">else</span> <span class="hljs-number">0</span>        max_sum_right = self.maxPathSum(root.right) <span class="hljs-keyword">if</span> root.right <span class="hljs-keyword">else</span> <span class="hljs-number">0</span>        <span class="hljs-keyword">return</span> max(            max_sum_left+root.val+max_sum_right,            max_sum_left+root.val,            root.val+max_sum_right,            <span class="hljs-comment"># 尝试改了这个又通不过别的测试用例，而且这逻辑给我搞的乱糟糟</span>            max_sum_left <span class="hljs-keyword">if</span> root.left <span class="hljs-keyword">else</span> root.val,            max_sum_right <span class="hljs-keyword">if</span> root.right <span class="hljs-keyword">else</span> root.val,            <span class="hljs-comment"># 忘了只有当前节点自己的情况了</span>            root.val            )</code></pre><p>看了正确答案，思考总结如下<br>当前节点路径最大值和递归返回的值不是一个值，因为子树的二叉树分歧递归上去也只能取一路的值给外层循环用<br>2. float(“-inf”)无穷小 float(“inf”)无穷大<br>3. 正确答案里的nonlocal是python 3.2引入的，我这没法用，还是要在方法内部创建方法，而且就像之前总结的，直接用类方法容易导致root名称被滥用错乱。直接外边定义一个变量会导致无法在递归内部访问到变量。 兼容用个dict或list存一下<br>4. 递归返回如果是负的可以取0，这相当与结果舍弃了这一侧的子树。因为负的情况无论怎么加进去都会导致结果总值变小</p><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span><span class="hljs-params">(object)</span>:</span>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">maxPathSum</span><span class="hljs-params">(self, root)</span>:</span>        <span class="hljs-string">"""</span><span class="hljs-string">        :type root: TreeNode</span><span class="hljs-string">        :rtype: int</span><span class="hljs-string">        """</span>        res = &#123;<span class="hljs-string">'res'</span>: float(<span class="hljs-string">'-inf'</span>)&#125;        <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">max_gain</span><span class="hljs-params">(node)</span>:</span>            <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> node:                <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>            max_gain_left = max(max_gain(node.left), <span class="hljs-number">0</span>)            max_gain_right = max(max_gain(node.right), <span class="hljs-number">0</span>)                        <span class="hljs-comment"># 此时以node节点为根的子树能生成的最大路径和, 尝试更新结果</span>            res[<span class="hljs-string">"res"</span>] = max(res[<span class="hljs-string">"res"</span>], max_gain_left + node.val + max_gain_right)            <span class="hljs-comment"># 递归返回当前node不作为结果集根的情况下，能提供的最大路径和贡献。 node.val必须加进来，否则无法联系树上层</span>            <span class="hljs-keyword">return</span> max(max_gain_left, max_gain_right) + node.val        max_gain(root)        <span class="hljs-keyword">return</span> res[<span class="hljs-string">"res"</span>]</code></pre>]]></content>
    
    
    <categories>
      
      <category>Leetcode</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Leetcode 102 - 二叉树的层序遍历</title>
    <link href="/2020/05/13/leetcode-102/"/>
    <url>/2020/05/13/leetcode-102/</url>
    
    <content type="html"><![CDATA[<p>题目：</p><pre><code class="hljs quote">给你一个二叉树，请你返回其按 层序遍历 得到的节点值。 （即逐层地，从左到右访问所有节点）。</code></pre><p>这道题是受层序遍历找二叉树最大深度的启发简单改改而成。真的背点题越做越顺啊</p><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span><span class="hljs-params">(object)</span>:</span>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">levelOrder</span><span class="hljs-params">(self, root)</span>:</span>        <span class="hljs-string">"""</span><span class="hljs-string">        :type root: TreeNode</span><span class="hljs-string">        :rtype: List[List[int]]</span><span class="hljs-string">        """</span>        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> root: <span class="hljs-keyword">return</span> []        nodes, res = [root], []        <span class="hljs-keyword">while</span> nodes:            res_element = []            next_level_nodes = []            <span class="hljs-keyword">for</span> node <span class="hljs-keyword">in</span> nodes:                res_element.append(node.val)                <span class="hljs-keyword">if</span> node.left:                    next_level_nodes.append(node.left)                <span class="hljs-keyword">if</span> node.right:                    next_level_nodes.append(node.right)            nodes = next_level_nodes            res.append(res_element)        <span class="hljs-keyword">return</span> res</code></pre>]]></content>
    
    
    <categories>
      
      <category>Leetcode</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Leetcode 55 - I. 二叉树的深度</title>
    <link href="/2020/05/12/leetcode-55/"/>
    <url>/2020/05/12/leetcode-55/</url>
    
    <content type="html"><![CDATA[<p>这递归解法仿照了另个做不出来的题的答案：返回所有到根节点路线的list<br>共同点是都要对整个树遍历才能判断最值</p><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span><span class="hljs-params">(object)</span>:</span>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">maxDepth</span><span class="hljs-params">(self, root)</span>:</span>        <span class="hljs-string">"""</span><span class="hljs-string">        :type root: TreeNode</span><span class="hljs-string">        :rtype: int</span><span class="hljs-string">        """</span>        depths = []                <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">searchTree</span><span class="hljs-params">(root, depth)</span>:</span>            depth += <span class="hljs-number">1</span>            <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> root.left <span class="hljs-keyword">and</span> <span class="hljs-keyword">not</span> root.right:                depths.append(depth)                <span class="hljs-keyword">return</span>            <span class="hljs-keyword">if</span> root.left:                searchTree(root.left, depth)            <span class="hljs-keyword">if</span> root.right:                searchTree(root.right, depth)        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> root:            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>        searchTree(root, <span class="hljs-number">0</span>)        <span class="hljs-keyword">return</span> max(depths)</code></pre><p>尝试迭代, 也是抄记忆中之前题的逻辑</p><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span><span class="hljs-params">(object)</span>:</span>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">maxDepth</span><span class="hljs-params">(self, root)</span>:</span>        <span class="hljs-string">"""</span><span class="hljs-string">        :type root: TreeNode</span><span class="hljs-string">        :rtype: int</span><span class="hljs-string">        """</span>        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> root:            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>        max_depth = <span class="hljs-number">0</span>        stack = [(root, <span class="hljs-number">0</span>)]        <span class="hljs-keyword">while</span> stack:            (node, depth) = stack.pop()            depth += <span class="hljs-number">1</span>            <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> node.left <span class="hljs-keyword">and</span> <span class="hljs-keyword">not</span> node.right:                max_depth = max(max_depth, depth)                <span class="hljs-comment"># 这个检查了好一会儿，迭代不能return啊！！！</span>                <span class="hljs-comment"># return</span>                <span class="hljs-keyword">continue</span>            <span class="hljs-comment"># 这个地方又检查好久。 从上边递归方法中抄过来的，所以这样容易疏漏的地方还是写成中性化的形式好</span>            <span class="hljs-comment"># if root.left:</span>            <span class="hljs-keyword">if</span> node.left:                stack.append((node.left, depth))            <span class="hljs-keyword">if</span> node.right:                stack.append((node.right, depth))        <span class="hljs-keyword">return</span> max_depth</code></pre><p>题解看了看，原来有想多了。迭代就是上层为下层左右子树大的那个+1。 后序遍历，完全不需要保存所有分支的深度</p><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span>:</span>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">maxDepth</span><span class="hljs-params">(self, root: TreeNode)</span> -&gt; int:</span>        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> root: <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>        <span class="hljs-keyword">return</span> max(self.maxDepth(root.left), self.maxDepth(root.right)) + <span class="hljs-number">1</span></code></pre><p>层序遍历也难不哪去，就看能不能想到意识到</p><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span>:</span>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">maxDepth</span><span class="hljs-params">(self, root: TreeNode)</span> -&gt; int:</span>        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> root: <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>        queue, res = [root], <span class="hljs-number">0</span>        <span class="hljs-keyword">while</span> queue:            tmp = []            <span class="hljs-keyword">for</span> node <span class="hljs-keyword">in</span> queue:                <span class="hljs-keyword">if</span> node.left: tmp.append(node.left)                <span class="hljs-keyword">if</span> node.right: tmp.append(node.right)            queue = tmp            res += <span class="hljs-number">1</span>        <span class="hljs-keyword">return</span> res</code></pre>]]></content>
    
    
    <categories>
      
      <category>Leetcode</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Leetcode 226 -</title>
    <link href="/2020/05/12/leetcode-226/"/>
    <url>/2020/05/12/leetcode-226/</url>
    
    <content type="html"><![CDATA[<p>题目：</p><pre><code class="hljs quote">翻转一棵二叉树。</code></pre><p>自己的递归解法，也有很多可优化的点</p><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span><span class="hljs-params">(object)</span>:</span>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">invertTree</span><span class="hljs-params">(self, root)</span>:</span>        <span class="hljs-string">"""</span><span class="hljs-string">        :type root: TreeNode</span><span class="hljs-string">        :rtype: TreeNode</span><span class="hljs-string">        """</span>        <span class="hljs-comment"># Python要把方法引用放到方法定义后边</span>        <span class="hljs-keyword">return</span> helper(root)    <span class="hljs-comment"># 不需要helper，递归直接调用self.invertTree方法</span>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">helper</span><span class="hljs-params">(root)</span>:</span>        <span class="hljs-comment"># 终结条件忘了</span>        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> root:            <span class="hljs-keyword">return</span> <span class="hljs-literal">None</span>        holder = root.right        root.right = root.left        root.left = holder        <span class="hljs-comment"># 终结条件在内层，这里不用if的</span>        <span class="hljs-keyword">if</span> root.left:            helper(root.left)        <span class="hljs-keyword">if</span> root.right:            helper(root.right)        <span class="hljs-keyword">return</span> root</code></pre><p>想写一个迭代的版本，没思路（愁死了），看一下答案，所谓树的迭代就是用个节点栈取代递归</p><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span><span class="hljs-params">(object)</span>:</span>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">invertTree</span><span class="hljs-params">(self, root)</span>:</span>        <span class="hljs-string">"""</span><span class="hljs-string">        :type root: TreeNode</span><span class="hljs-string">        :rtype: TreeNode</span><span class="hljs-string">        """</span>        <span class="hljs-comment">#递归, 要返回None直接return就完了</span>        <span class="hljs-comment"># if not root:</span>        <span class="hljs-comment">#     return </span>        <span class="hljs-comment"># 这种交换连中间值也不需要</span>        <span class="hljs-comment"># root.left, root.right = root.right, root.left</span>        <span class="hljs-comment"># self.invertTree(root.left)</span>        <span class="hljs-comment"># self.invertTree(root.right)</span>        <span class="hljs-comment"># return root</span>        <span class="hljs-comment">#迭代</span>        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> root:            <span class="hljs-keyword">return</span>                stack = [root]        <span class="hljs-keyword">while</span> stack:            node = stack.pop()            <span class="hljs-keyword">if</span> node.left:                stack.append(node.left)            <span class="hljs-keyword">if</span> node.right:                stack.append(node.right)            node.left, node.right = node.right, node.left                <span class="hljs-keyword">return</span> root</code></pre><p>“面试题27. 二叉树的镜像” 和这个是一个题，这次自己写的轻松。 这题前中后序遍历完全一样</p>]]></content>
    
    
    <categories>
      
      <category>Leetcode</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Leetcode 155 - 最小栈</title>
    <link href="/2020/05/12/leetcode-155/"/>
    <url>/2020/05/12/leetcode-155/</url>
    
    <content type="html"><![CDATA[<p>题目：</p><pre><code class="hljs quote">设计一个支持 push ，pop ，top 操作，并能在常数时间内检索到最小元素的栈。push(x) —— 将元素 x 推入栈中。pop() —— 删除栈顶的元素。top() —— 获取栈顶元素。getMin() —— 检索栈中的最小元素。</code></pre><p>这道题的官方解法是用两个栈来实现这个栈，这有微妙</p><p>我自己实现用的链表，其实拿普通列表实现可以的，把节点放在最后一位的位置，记住当前坐标。用另一个列表存当前最小值，一块压栈出栈形式上也更容易些<br>另一点，通过这题训练下python class里self参数怎么用</p><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MinStack</span><span class="hljs-params">(object)</span>:</span>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span><span class="hljs-params">(self)</span>:</span>        <span class="hljs-string">"""</span><span class="hljs-string">        initialize your data structure here.</span><span class="hljs-string">        """</span>        <span class="hljs-comment"># node[0] 当前值value，默认None；node[1] 当前最小值min_value，默认None；node[2] 上一结点指针，默认None；node[3] 下一结点指针，默认None</span>        <span class="hljs-comment"># value = None</span>        <span class="hljs-comment"># min_value = None</span>        <span class="hljs-comment"># prior_node = None</span>        <span class="hljs-comment"># next_node = None</span>        <span class="hljs-comment"># node = [value, min_value, prior_node, next_node]</span>        self.top_node = <span class="hljs-literal">None</span>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">push</span><span class="hljs-params">(self, x)</span>:</span>        <span class="hljs-string">"""</span><span class="hljs-string">        :type x: int</span><span class="hljs-string">        :rtype: None</span><span class="hljs-string">        """</span>        <span class="hljs-keyword">if</span> self.top_node:            <span class="hljs-comment"># 当前存在节点</span>            new_node = [x, min(self.top_node[<span class="hljs-number">1</span>], x), self.top_node, <span class="hljs-literal">None</span>]            self.top_node[<span class="hljs-number">3</span>] = new_node            self.top_node = new_node        <span class="hljs-keyword">else</span>:            <span class="hljs-comment"># 第一个节点</span>            <span class="hljs-comment"># 这个地方查了20分钟的bug，错误写法：new_node = [x, x, None, None]</span>            self.top_node = [x, x, <span class="hljs-literal">None</span>, <span class="hljs-literal">None</span>]    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">pop</span><span class="hljs-params">(self)</span>:</span>        <span class="hljs-string">"""</span><span class="hljs-string">        :rtype: None</span><span class="hljs-string">        """</span>        <span class="hljs-keyword">if</span> self.top_node:            <span class="hljs-keyword">if</span> self.top_node[<span class="hljs-number">2</span>]:                <span class="hljs-comment"># 有节点且有前驱节点</span>                self.top_node = self.top_node[<span class="hljs-number">2</span>]                self.top_node[<span class="hljs-number">3</span>] = <span class="hljs-literal">None</span>            <span class="hljs-keyword">else</span>:                self.top_node = <span class="hljs-literal">None</span>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">top</span><span class="hljs-params">(self)</span>:</span>        <span class="hljs-string">"""</span><span class="hljs-string">        :rtype: int</span><span class="hljs-string">        """</span>        <span class="hljs-keyword">if</span> self.top_node:            <span class="hljs-keyword">return</span> self.top_node[<span class="hljs-number">0</span>]        <span class="hljs-keyword">else</span>:            <span class="hljs-keyword">return</span> <span class="hljs-literal">None</span>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">getMin</span><span class="hljs-params">(self)</span>:</span>        <span class="hljs-string">"""</span><span class="hljs-string">        :rtype: int</span><span class="hljs-string">        """</span>        <span class="hljs-keyword">if</span> self.top_node:            <span class="hljs-keyword">return</span> self.top_node[<span class="hljs-number">1</span>]        <span class="hljs-keyword">else</span>:            <span class="hljs-keyword">return</span> <span class="hljs-literal">None</span><span class="hljs-comment"># Your MinStack object will be instantiated and called as such:</span><span class="hljs-comment"># obj = MinStack()</span><span class="hljs-comment"># obj.push(x)</span><span class="hljs-comment"># obj.pop()</span><span class="hljs-comment"># param_3 = obj.top()</span><span class="hljs-comment"># param_4 = obj.getMin()</span></code></pre><p>========================================================</p><h2 id="2020-05-27-更新："><a href="#2020-05-27-更新：" class="headerlink" title="2020/05/27 更新："></a>2020/05/27 更新：</h2><p>做leetcode探索，又碰到这题，就用双数组做了</p><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MinStack</span><span class="hljs-params">(object)</span>:</span>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span><span class="hljs-params">(self)</span>:</span>        <span class="hljs-string">"""</span><span class="hljs-string">        initialize your data structure here.</span><span class="hljs-string">        """</span>        self.stack = []        self.min = []    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">push</span><span class="hljs-params">(self, x)</span>:</span>        <span class="hljs-string">"""</span><span class="hljs-string">        :type x: int</span><span class="hljs-string">        :rtype: None</span><span class="hljs-string">        """</span>        self.stack.append(x)        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> self.min:            self.min.append(x)        <span class="hljs-keyword">else</span>:            self.min.append(min(self.min[<span class="hljs-number">-1</span>], x))                <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">pop</span><span class="hljs-params">(self)</span>:</span>        <span class="hljs-string">"""</span><span class="hljs-string">        :rtype: None</span><span class="hljs-string">        """</span>        <span class="hljs-keyword">if</span> self.stack <span class="hljs-keyword">and</span> self.min:            self.stack.pop()            self.min.pop()    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">top</span><span class="hljs-params">(self)</span>:</span>        <span class="hljs-string">"""</span><span class="hljs-string">        :rtype: int</span><span class="hljs-string">        """</span>        <span class="hljs-keyword">if</span> self.stack <span class="hljs-keyword">and</span> self.min:            <span class="hljs-keyword">return</span> self.stack[<span class="hljs-number">-1</span>]    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">getMin</span><span class="hljs-params">(self)</span>:</span>        <span class="hljs-string">"""</span><span class="hljs-string">        :rtype: int</span><span class="hljs-string">        """</span>        <span class="hljs-keyword">if</span> self.stack <span class="hljs-keyword">and</span> self.min:            <span class="hljs-keyword">return</span> self.min[<span class="hljs-number">-1</span>]</code></pre>]]></content>
    
    
    <categories>
      
      <category>Leetcode</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Leetcode 50 - Pow(x, n)</title>
    <link href="/2020/05/11/leetcode-50/"/>
    <url>/2020/05/11/leetcode-50/</url>
    
    <content type="html"><![CDATA[<p>题目：</p><pre><code class="hljs quote">实现 pow(x, n) ，即计算 x 的 n 次幂函数。</code></pre><p>前边都是错误解法，想破头。后边才是正确的</p><p>###错误解法1</p><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span><span class="hljs-params">(object)</span>:</span>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">myPow</span><span class="hljs-params">(self, x, n)</span>:</span>        <span class="hljs-string">"""</span><span class="hljs-string">        :type x: float</span><span class="hljs-string">        :type n: int</span><span class="hljs-string">        :rtype: float</span><span class="hljs-string">        """</span>        <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">helper</span><span class="hljs-params">(x, n)</span>:</span>            <span class="hljs-keyword">if</span> n == <span class="hljs-number">0</span>:                <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>            <span class="hljs-keyword">elif</span> n &gt; <span class="hljs-number">0</span>:                <span class="hljs-keyword">return</span> helper(x, n/<span class="hljs-number">2</span>)*helper(x, (n-n/<span class="hljs-number">2</span>))            <span class="hljs-keyword">elif</span> n &lt; <span class="hljs-number">0</span>:                <span class="hljs-keyword">return</span> helper(x, n/<span class="hljs-number">2</span>)/helper(x, (n-n/<span class="hljs-number">2</span>))        <span class="hljs-keyword">return</span> helper(x, n)</code></pre><p>首先想到动态规划，myPow(x, n)=myPow(x, n-m)*myPow(x, m)，状态转换<br>myPow(x, 0) = 1, 这个base case，不论正负值都往这个方向走<br>用迭代试试，分成&gt;0, &lt;0两部分<br>以为写的还行呢，其实是终结条件没判断好，n=1的时候，两个相乘的helper会总有一个以helper(x, 1)深入进去，达到迭代最大值</p><p>###错误解法2</p><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span><span class="hljs-params">(object)</span>:</span>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">myPow</span><span class="hljs-params">(self, x, n)</span>:</span>        <span class="hljs-string">"""</span><span class="hljs-string">        :type x: float</span><span class="hljs-string">        :type n: int</span><span class="hljs-string">        :rtype: float</span><span class="hljs-string">        """</span>            <span class="hljs-comment"># 真正的思路是将奇偶两种情况分开处理，偶数就一直除以2，奇数是先减1再一直除以2</span>            <span class="hljs-keyword">if</span> n == <span class="hljs-number">0</span>:                <span class="hljs-keyword">return</span> <span class="hljs-number">1.0</span>            <span class="hljs-keyword">elif</span> n &gt; <span class="hljs-number">0</span>:                <span class="hljs-keyword">if</span> n%<span class="hljs-number">2</span> == <span class="hljs-number">0</span>:                    <span class="hljs-keyword">return</span> helper(x, n/<span class="hljs-number">2</span>)**<span class="hljs-number">2</span>                <span class="hljs-keyword">elif</span> n%<span class="hljs-number">2</span> == <span class="hljs-number">1</span>:                    <span class="hljs-keyword">return</span> helper(x, n/<span class="hljs-number">2</span>)**<span class="hljs-number">2</span>*x**<span class="hljs-number">1</span>            <span class="hljs-keyword">elif</span> n &lt; <span class="hljs-number">0</span>:                <span class="hljs-keyword">if</span> n%<span class="hljs-number">2</span> == <span class="hljs-number">0</span>:                    <span class="hljs-keyword">print</span> n                    <span class="hljs-keyword">return</span> helper(x, abs(n)/<span class="hljs-number">2</span>)**<span class="hljs-number">-2</span>                <span class="hljs-keyword">elif</span> n%<span class="hljs-number">2</span> == <span class="hljs-number">-1</span>:                    <span class="hljs-keyword">return</span> helper(x, abs(n)/<span class="hljs-number">2</span>)**<span class="hljs-number">-2</span>*x**<span class="hljs-number">-1</span>        <span class="hljs-keyword">return</span> helper(x, n)</code></pre><p>34.00512<br>-3<br>很多测试用例过得去，但是这个过不去报错，搞不懂，估计是负数情况下除的时候是算上0来保留整数的。写的很繁琐，还错</p><pre><code class="hljs code">TypeError: None is not valid value for the expected return type double    raise TypeError(str(ret) + &quot; is not valid value for the expected return type double&quot;);Line 67 in _driver (Solution.py)    _driver()Line 73 in &lt;module&gt; (Solution.py)</code></pre><p>###以下正确答案</p><p>参考了别人答案才会了，可以变形：x的n次方=(1/x)的-n次方，用这个把负数n变正数。另外本不需要helper方法</p><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span><span class="hljs-params">(object)</span>:</span>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">myPow</span><span class="hljs-params">(self, x, n)</span>:</span>        <span class="hljs-string">"""</span><span class="hljs-string">        :type x: float</span><span class="hljs-string">        :type n: int</span><span class="hljs-string">        :rtype: float</span><span class="hljs-string">        """</span>        <span class="hljs-keyword">if</span> n == <span class="hljs-number">0</span>:            <span class="hljs-keyword">return</span> <span class="hljs-number">1.0</span>        <span class="hljs-keyword">if</span> n &lt; <span class="hljs-number">0</span>:            x = <span class="hljs-number">1</span>/x            n = -n        <span class="hljs-keyword">if</span> n%<span class="hljs-number">2</span> == <span class="hljs-number">0</span>:            <span class="hljs-keyword">return</span> self.myPow(x, n/<span class="hljs-number">2</span>)**<span class="hljs-number">2</span>        <span class="hljs-keyword">elif</span> n%<span class="hljs-number">2</span> == <span class="hljs-number">1</span>:            <span class="hljs-keyword">return</span> self.myPow(x, n/<span class="hljs-number">2</span>)**<span class="hljs-number">2</span>*x</code></pre><p>这块还可以优化，进入子迭代前平方，而不要返回时平方，更易读，效率上差不多</p><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span><span class="hljs-params">(object)</span>:</span>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">myPow</span><span class="hljs-params">(self, x, n)</span>:</span>        <span class="hljs-string">"""</span><span class="hljs-string">        :type x: float</span><span class="hljs-string">        :type n: int</span><span class="hljs-string">        :rtype: float</span><span class="hljs-string">        """</span>        <span class="hljs-keyword">if</span> n == <span class="hljs-number">0</span>:            <span class="hljs-keyword">return</span> <span class="hljs-number">1.0</span>        <span class="hljs-keyword">if</span> n &lt; <span class="hljs-number">0</span>:            x = <span class="hljs-number">1</span>/x            n = -n        <span class="hljs-keyword">if</span> n%<span class="hljs-number">2</span> == <span class="hljs-number">0</span>:            <span class="hljs-keyword">return</span> self.myPow(x**<span class="hljs-number">2</span>, n/<span class="hljs-number">2</span>)        <span class="hljs-keyword">elif</span> n%<span class="hljs-number">2</span> == <span class="hljs-number">1</span>:            <span class="hljs-keyword">return</span> self.myPow(x**<span class="hljs-number">2</span>, n/<span class="hljs-number">2</span>)*x</code></pre>]]></content>
    
    
    <categories>
      
      <category>Leetcode</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Leetcode 1287 - 有序数组中出现次数超过25%的元素</title>
    <link href="/2020/05/09/leetcode-1287/"/>
    <url>/2020/05/09/leetcode-1287/</url>
    
    <content type="html"><![CDATA[<p>题目：</p><pre><code class="hljs quote">给你一个非递减的有序整数数组，已知这个数组中恰好有一个整数，它的出现次数超过数组元素总数的 25%。请你找到并返回这个整数</code></pre><p>这道题是解的最顺的，自己的解法如下：</p><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span><span class="hljs-params">(object)</span>:</span>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">findSpecialInteger</span><span class="hljs-params">(self, arr)</span>:</span>        <span class="hljs-string">"""</span><span class="hljs-string">        :type arr: List[int]</span><span class="hljs-string">        :rtype: int</span><span class="hljs-string">        """</span>        map = &#123;key:<span class="hljs-number">0</span> <span class="hljs-keyword">for</span> key <span class="hljs-keyword">in</span> set(arr)&#125;        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(len(arr)):            map[arr[i]] += <span class="hljs-number">1</span>        <span class="hljs-keyword">for</span> k,v <span class="hljs-keyword">in</span> map.items():            <span class="hljs-keyword">if</span> <span class="hljs-number">4</span>*v &gt; len(arr):                <span class="hljs-keyword">return</span> k</code></pre><p>这里边的第二个for循环其实可以不要, 只要在第一个for循环里，每步判断下是否已超过25%就行</p><p><strong>重点</strong>在这里。超过25%，就感觉应该用二分查找，但是没什么直接思路<br><a href="https://leetcode-cn.com/problems/element-appearing-more-than-25-in-sorted-array/solution/" target="_blank" rel="noopener">Leetcode网站</a>提供了解法</p><ol><li>反证法证明解一定出现在开始、1/4，1/2，3/4的指针位置</li><li>python里用了bisect.bisect_left这种方法去寻找指针位置值在左右的范围</li><li>range(x, y, z) 是在[x,y)左开右闭区间内以z步长迭代</li></ol><p>时间复杂度从O(N)降到O(LogN)了<br>回头自己实现一下</p>]]></content>
    
    
    <categories>
      
      <category>Leetcode</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Leetcode 69 - x的平方根</title>
    <link href="/2020/05/09/leetcode-69/"/>
    <url>/2020/05/09/leetcode-69/</url>
    
    <content type="html"><![CDATA[<p>题目：</p><pre><code class="hljs quote">实现 int sqrt(int x) 函数。计算并返回 x 的平方根，其中 x 是非负整数。由于返回类型是整数，结果只保留整数的部分，小数部分将被舍去。来源：力扣（LeetCode）链接：https:&#x2F;&#x2F;leetcode-cn.com&#x2F;problems&#x2F;sqrtx著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</code></pre><p>写了3种方法</p><ol><li><p>单步加1速度太慢, 写的时候根本没想效率的事</p><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span><span class="hljs-params">(object)</span>:</span>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">mySqrt</span><span class="hljs-params">(self, x)</span>:</span>        <span class="hljs-string">"""</span><span class="hljs-string">        :type x: int</span><span class="hljs-string">        :rtype: int</span><span class="hljs-string">        """</span>        y = <span class="hljs-number">0</span>        <span class="hljs-keyword">while</span> y*y &lt;= x:            y+=<span class="hljs-number">1</span>        <span class="hljs-keyword">return</span> y<span class="hljs-number">-1</span></code></pre></li><li><p>二分查找, 自己想了一大顿关联到了，写的过于繁琐，设置四种判断条件人为变得困难</p><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span><span class="hljs-params">(object)</span>:</span>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">mySqrt</span><span class="hljs-params">(self, x)</span>:</span>        <span class="hljs-string">"""</span><span class="hljs-string">        :type x: int</span><span class="hljs-string">        :rtype: int</span><span class="hljs-string">        """</span>        <span class="hljs-comment"># 临界条件设置的好傻</span>        <span class="hljs-keyword">if</span> x == <span class="hljs-number">0</span>:            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>        <span class="hljs-keyword">if</span> x == <span class="hljs-number">1</span>:            <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>            left, right = <span class="hljs-number">0</span>, x         <span class="hljs-keyword">while</span> left &lt;= right:            <span class="hljs-comment"># 取整应该用//</span>            mid = left + (right - left)/<span class="hljs-number">2</span>            <span class="hljs-comment"># 指数是**，不是^（按二进制位异或运算）</span>            <span class="hljs-keyword">if</span> mid**<span class="hljs-number">2</span> &lt;= x <span class="hljs-keyword">and</span> (mid+<span class="hljs-number">1</span>)**<span class="hljs-number">2</span> &gt; x:                <span class="hljs-keyword">return</span> mid            <span class="hljs-keyword">elif</span> mid**<span class="hljs-number">2</span> &lt;= x <span class="hljs-keyword">and</span> (mid+<span class="hljs-number">1</span>)**<span class="hljs-number">2</span> &lt;= x:                left = mid            <span class="hljs-keyword">elif</span> mid**<span class="hljs-number">2</span> &gt; x <span class="hljs-keyword">and</span> (mid<span class="hljs-number">-1</span>)**<span class="hljs-number">2</span> &lt;= x:                <span class="hljs-comment"># 返还忘了减1</span>                <span class="hljs-keyword">return</span> mid<span class="hljs-number">-1</span>            <span class="hljs-keyword">elif</span> mid**<span class="hljs-number">2</span> &gt; x <span class="hljs-keyword">and</span> (mid<span class="hljs-number">-1</span>)**<span class="hljs-number">2</span> &gt; x:                right = mid</code></pre></li><li><p>简单版二分查找，正确答案默写</p><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span><span class="hljs-params">(object)</span>:</span>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">mySqrt</span><span class="hljs-params">(self, x)</span>:</span>        <span class="hljs-string">"""</span><span class="hljs-string">        :type x: int</span><span class="hljs-string">        :rtype: int</span><span class="hljs-string">        """</span>        l, r, res = <span class="hljs-number">0</span>, x, <span class="hljs-number">-1</span>        <span class="hljs-keyword">while</span> l &lt;= r:            mid = l + (r - l)/<span class="hljs-number">2</span>            <span class="hljs-keyword">if</span> mid**<span class="hljs-number">2</span> &lt;= x:                res = mid                l = mid + <span class="hljs-number">1</span>            <span class="hljs-keyword">elif</span> mid**<span class="hljs-number">2</span> &gt; x:                r = mid - <span class="hljs-number">1</span>        <span class="hljs-comment"># 保存唯一正确位置到最后返回就行</span>        <span class="hljs-keyword">return</span> res</code></pre></li></ol>]]></content>
    
    
    <categories>
      
      <category>Leetcode</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Hexo部署</title>
    <link href="/2020/05/09/Hexo-Manual/"/>
    <url>/2020/05/09/Hexo-Manual/</url>
    
    <content type="html"><![CDATA[<p>重新安装Hexo，已经时隔三年。虽然很多事情缠身，不过简单探索的快乐还在。Github Page还能使用，但是Hexo本身已经完全不同了。代码库被我完全的重写掉，使用的<a href="https://github.com/theme-next/hexo-theme-next" target="_blank" rel="noopener">Next主题</a></p><p>通过配置文件向github page库推送需要安装</p><pre><code class="hljs bash">$ npm install hexo-deployer-git --save</code></pre><p>明天再熟悉下Markdown语法，写我自己的好东西</p><h3 id="三天后"><a href="#三天后" class="headerlink" title="三天后"></a>三天后</h3><p>在windows上配置hexo, 才发现github上只有打包好的静态网站，配置、主题、写的文字全没上传。官网说法，想想也对，回头抄一抄别人的hexo文件管理方式。<a href="https://hexo.io/zh-cn/docs/one-command-deployment" target="_blank" rel="noopener">“由于 Hexo 的部署默认使用分支 master，所以如果你同时正在使用 Git 管理你的站点目录，你应当注意你的部署分支应当不同于写作分支。<br>一个好的实践是将站点目录和 Pages 分别存放在两个不同的 Git 仓库中，可以有效避免相互覆盖。<br>Hexo 在部署你的站点生成的文件时并不会更新你的站点目录。因此你应该手动提交并推送你的写作分支。”</a></p><p>Next分支坏了，显示Null。直接换成了<a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="noopener">Fluid高级主题</a></p>]]></content>
    
    
    <categories>
      
      <category>Tools</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Hello World</title>
    <link href="/2020/05/09/hello-world/"/>
    <url>/2020/05/09/hello-world/</url>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><pre><code class="hljs bash">$ hexo new <span class="hljs-string">"My New Post"</span></code></pre><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><pre><code class="hljs bash">$ hexo server</code></pre><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><pre><code class="hljs bash">$ hexo generate</code></pre><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><pre><code class="hljs bash">$ hexo deploy</code></pre><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html" target="_blank" rel="noopener">Deployment</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  
</search>
