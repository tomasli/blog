<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>Leetcode 303 - 区域和检索 - 数组不可变</title>
    <link href="/2020/05/21/leetcode-303/"/>
    <url>/2020/05/21/leetcode-303/</url>
    
    <content type="html"><![CDATA[<p>题目：</p><pre><code class="hljs quote">给定一个整数数组  nums，求出数组从索引 i 到 j  (i ≤ j) 范围内元素的总和，包含 i,  j 两点。1. 你可以假设数组不可变。2. 会多次调用 sumRange 方法。</code></pre><p>isinstance判断类型<br>直接相加超时</p><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">NumArray</span><span class="hljs-params">(object)</span>:</span>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span><span class="hljs-params">(self, nums)</span>:</span>        <span class="hljs-string">"""</span><span class="hljs-string">        :type nums: List[int]</span><span class="hljs-string">        """</span>        self.nums = nums    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">sumRange</span><span class="hljs-params">(self, i, j)</span>:</span>        <span class="hljs-string">"""</span><span class="hljs-string">        :type i: int</span><span class="hljs-string">        :type j: int</span><span class="hljs-string">        :rtype: int</span><span class="hljs-string">        """</span>        <span class="hljs-comment">## 要验证格式</span>        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> isinstance(i, int) <span class="hljs-keyword">or</span> <span class="hljs-keyword">not</span> isinstance(j, int):            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>        <span class="hljs-keyword">if</span> i &lt; <span class="hljs-number">0</span> <span class="hljs-keyword">or</span> j &lt; i <span class="hljs-keyword">or</span> j &gt;=len(self.nums):            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>                <span class="hljs-comment">## reduce又忘了用法了</span>        <span class="hljs-keyword">return</span> reduce(<span class="hljs-keyword">lambda</span> x, y: x+y, self.nums[i:j+<span class="hljs-number">1</span>])</code></pre><p>忘了说明了，这意思是拿空间换时间咯，动态规划重写<br>这个就是前缀和呗<br>sum[i:j] = sum[0:j] - sum[0:i]<br>dp[i]定义：子串[0:i+1]的和<br>选择：加一个元素<br>动态规划方程：dp[i] = dp[i-1] + nums[i]<br>起始状态：dp[0] = nums[0]<br>终结状态：dp[len(nums)-1]</p><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">NumArray</span><span class="hljs-params">(object)</span>:</span>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span><span class="hljs-params">(self, nums)</span>:</span>        <span class="hljs-string">"""</span><span class="hljs-string">        :type nums: List[int]</span><span class="hljs-string">        """</span>        self.nums = nums        self.dp = [<span class="hljs-number">0</span>] * len(nums)        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(len(nums)):            <span class="hljs-keyword">if</span> i == <span class="hljs-number">0</span>:                self.dp[<span class="hljs-number">0</span>] = nums[<span class="hljs-number">0</span>]            <span class="hljs-keyword">else</span>:                self.dp[i] = self.dp[i<span class="hljs-number">-1</span>] + nums[i]    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">sumRange</span><span class="hljs-params">(self, i, j)</span>:</span>        <span class="hljs-string">"""</span><span class="hljs-string">        :type i: int</span><span class="hljs-string">        :type j: int</span><span class="hljs-string">        :rtype: int</span><span class="hljs-string">        """</span>        <span class="hljs-comment">## 要验证格式</span>        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> isinstance(i, int) <span class="hljs-keyword">or</span> <span class="hljs-keyword">not</span> isinstance(j, int):            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>        <span class="hljs-keyword">if</span> i &lt; <span class="hljs-number">0</span> <span class="hljs-keyword">or</span> j &lt; i <span class="hljs-keyword">or</span> j &gt;=len(self.nums):            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>                <span class="hljs-comment">## 闭闭区间，包括j在内的</span>        <span class="hljs-keyword">return</span> self.dp[j]-self.dp[i]</code></pre><p>相减的位置总差一位，改一下起始状态逻辑为：<br>dp[0] = 0<br>原来的问题在于，dp[0]用来存了第一个数组值，这样求[0:2]的和成了dp[2]-dp[0]，多减了sums[0]的值</p><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">NumArray</span><span class="hljs-params">(object)</span>:</span>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span><span class="hljs-params">(self, nums)</span>:</span>        <span class="hljs-string">"""</span><span class="hljs-string">        :type nums: List[int]</span><span class="hljs-string">        """</span>        self.nums = nums        self.dp = [<span class="hljs-number">0</span>] * (len(nums)+<span class="hljs-number">1</span>)        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(len(nums)+<span class="hljs-number">1</span>):            <span class="hljs-keyword">if</span> i == <span class="hljs-number">0</span>:                self.dp[<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>            <span class="hljs-keyword">else</span>:                <span class="hljs-comment"># 这种状态转移也比较自然</span>                self.dp[i] = self.dp[i<span class="hljs-number">-1</span>] + nums[i<span class="hljs-number">-1</span>]    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">sumRange</span><span class="hljs-params">(self, i, j)</span>:</span>        <span class="hljs-string">"""</span><span class="hljs-string">        :type i: int</span><span class="hljs-string">        :type j: int</span><span class="hljs-string">        :rtype: int</span><span class="hljs-string">        """</span>        <span class="hljs-comment">## 要验证格式</span>        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> isinstance(i, int) <span class="hljs-keyword">or</span> <span class="hljs-keyword">not</span> isinstance(j, int):            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>        <span class="hljs-keyword">if</span> i &lt; <span class="hljs-number">0</span> <span class="hljs-keyword">or</span> j &lt; i <span class="hljs-keyword">or</span> j &gt;=len(self.nums):            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>                <span class="hljs-comment">## 闭闭区间，包括j在内的</span>        <span class="hljs-keyword">return</span> self.dp[j+<span class="hljs-number">1</span>]-self.dp[i]</code></pre><p>看似简单，在边界值上纠结了好一会儿</p>]]></content>
    
    
    <categories>
      
      <category>Leetcode</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Leetcode 392 - 判断子序列</title>
    <link href="/2020/05/21/leetcode-392/"/>
    <url>/2020/05/21/leetcode-392/</url>
    
    <content type="html"><![CDATA[<p>题目：</p><pre><code class="hljs quote">给定字符串 s 和 t ，判断 s 是否为 t 的子序列。你可以认为 s 和 t 中仅包含英文小写字母。字符串 t 可能会很长（长度 ~&#x3D; 500,000），而 s 是个短字符串（长度 &lt;&#x3D;100）。字符串的一个子序列是原始字符串删除一些（也可以不删除）字符而不改变剩余字符相对位置形成的新字符串。（例如，&quot;ace&quot;是&quot;abcde&quot;的一个子序列，而&quot;aec&quot;不是）。</code></pre><p>很简单的一个双指针吧，刚做过这个题的高难度版 </p><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span><span class="hljs-params">(object)</span>:</span>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">isSubsequence</span><span class="hljs-params">(self, s, t)</span>:</span>        <span class="hljs-string">"""</span><span class="hljs-string">        :type s: str</span><span class="hljs-string">        :type t: str</span><span class="hljs-string">        :rtype: bool</span><span class="hljs-string">        """</span>        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> s:            <span class="hljs-keyword">return</span> <span class="hljs-literal">True</span>        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> t <span class="hljs-keyword">or</span> len(s) &gt; len(t):            <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span>        i, j = <span class="hljs-number">0</span>, <span class="hljs-number">0</span>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(len(t)):            <span class="hljs-keyword">if</span> t[i] == s[j]:                j += <span class="hljs-number">1</span>                <span class="hljs-comment">## z这个地方写成t了，st混了</span>                <span class="hljs-keyword">if</span> j &gt;= len(s):                    <span class="hljs-keyword">return</span> <span class="hljs-literal">True</span>        <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span></code></pre>]]></content>
    
    
    <categories>
      
      <category>Leetcode</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Leetcode 524 - 通过删除字母匹配到字典里最长单词</title>
    <link href="/2020/05/21/leetcode-524/"/>
    <url>/2020/05/21/leetcode-524/</url>
    
    <content type="html"><![CDATA[<p>题目：</p><pre><code class="hljs quote">给定一个字符串和一个字符串字典，找到字典里面最长的字符串，该字符串可以通过删除给定字符串的某些字符来得到。如果答案不止一个，返回长度最长且字典顺序最小的字符串。如果答案不存在，则返回空字符串。</code></pre><p>首先想法：d中str的元素在s中能按顺序找到，str就满足条件。用两个指针记录位置就能穷举了。<br>不过这题肯定没这么简单，s被刷len(d)遍，时间复杂度在n^2上<br>d中元素之间的关系应该也可以利用的？想不到</p><p>另一个想法：用pointers = [0]*len(d)来保存d上str的指针集，然后开始遍历s，与s相同的str的指针也走，最后pointer走到str头且str最大的就是答案。按这个写了<br>这里边有纠结。从头开始走不知道哪里是具体str底不用走了，决定全部从后往前遍历，这样走到-1就算走完了；还要再判断一遍满足条件str里最长最左的，也是没办法</p><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span><span class="hljs-params">(object)</span>:</span>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">findLongestWord</span><span class="hljs-params">(self, s, d)</span>:</span>        <span class="hljs-string">"""</span><span class="hljs-string">        :type s: str</span><span class="hljs-string">        :type d: List[str]</span><span class="hljs-string">        :rtype: str</span><span class="hljs-string">        """</span>        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> d <span class="hljs-keyword">or</span> <span class="hljs-keyword">not</span> s:            <span class="hljs-keyword">return</span> <span class="hljs-string">""</span>        reverse_pointers = [len(i)<span class="hljs-number">-1</span> <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> d]        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(len(s)<span class="hljs-number">-1</span>, <span class="hljs-number">-1</span>, <span class="hljs-number">-1</span>):            <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> range(len(d)):                <span class="hljs-comment"># d中第j个str,其reverse_pointers[j]为这个str当前位置指针</span>                <span class="hljs-keyword">if</span> reverse_pointers[j] &gt;= <span class="hljs-number">0</span> <span class="hljs-keyword">and</span> d[j][reverse_pointers[j]] == s[i]:                    reverse_pointers[j] -= <span class="hljs-number">1</span>        max_len = <span class="hljs-number">0</span>        res = <span class="hljs-string">""</span>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(len(d)):            <span class="hljs-keyword">if</span> reverse_pointers[i] == <span class="hljs-number">-1</span> <span class="hljs-keyword">and</span> len(d[i]) &gt; max_len:                max_len = max(max_len, len(d[i]))                res = d[i]        <span class="hljs-keyword">return</span> res</code></pre><p>被审题框了，不是”长度最长数组顺序最小”，而是”长度最长字典序最小”。比如</p><pre><code class="hljs quote">解答错误显示详情输入&quot;bab&quot;[&quot;ba&quot;,&quot;ab&quot;,&quot;a&quot;,&quot;b&quot;]输出&quot;ba&quot;预期结果&quot;ab&quot;</code></pre><p>重新改改最后一截</p><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span><span class="hljs-params">(object)</span>:</span>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">findLongestWord</span><span class="hljs-params">(self, s, d)</span>:</span>        <span class="hljs-string">"""</span><span class="hljs-string">        :type s: str</span><span class="hljs-string">        :type d: List[str]</span><span class="hljs-string">        :rtype: str</span><span class="hljs-string">        """</span>        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> d <span class="hljs-keyword">or</span> <span class="hljs-keyword">not</span> s:            <span class="hljs-keyword">return</span> <span class="hljs-string">""</span>        reverse_pointers = [len(i)<span class="hljs-number">-1</span> <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> d]        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(len(s)<span class="hljs-number">-1</span>, <span class="hljs-number">-1</span>, <span class="hljs-number">-1</span>):            <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> range(len(d)):                <span class="hljs-comment"># d中第j个str,其reverse_pointers[j]为这个str当前位置指针</span>                <span class="hljs-keyword">if</span> reverse_pointers[j] &gt;= <span class="hljs-number">0</span> <span class="hljs-keyword">and</span> d[j][reverse_pointers[j]] == s[i]:                    reverse_pointers[j] -= <span class="hljs-number">1</span>        max_len = <span class="hljs-number">0</span>        res = <span class="hljs-string">""</span>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(len(d)):            <span class="hljs-keyword">if</span> reverse_pointers[i] == <span class="hljs-number">-1</span>:                <span class="hljs-keyword">if</span> len(d[i]) &gt; max_len:                    max_len = len(d[i])                    res = d[i]                <span class="hljs-keyword">elif</span> len(d[i]) == max_len <span class="hljs-keyword">and</span> d[i] &gt; res:                    res = d[i]        <span class="hljs-keyword">return</span> res</code></pre><p>答案还挺多的4种，思想差不多，细节跳过不表</p>]]></content>
    
    
    <categories>
      
      <category>Leetcode</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Leetcode 107 - 二叉树的层次遍历 II</title>
    <link href="/2020/05/21/leetcode-107/"/>
    <url>/2020/05/21/leetcode-107/</url>
    
    <content type="html"><![CDATA[<p>题目：</p><pre><code class="hljs quote">给定一个二叉树，返回其节点值自底向上的层次遍历。 （即按从叶子节点所在层到根节点所在的层，逐层从左向右遍历）</code></pre><p>挺久没二叉树了，这道简单正好<br>二叉树先决定前中后序遍历，这个用前序好，从底向上的遍历就是从顶向下遍历反过来[::-1]<br>每层产生了第一个点就append进数组，底二个点就append进对应位置子数组。用个常量记录当前的层数<br>速度击败83%的用户，优化空间没必要看了，过了<br>目前来说做的最顺的一题，随便画画一想很快搞定了</p><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span><span class="hljs-params">(object)</span>:</span>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">levelOrderBottom</span><span class="hljs-params">(self, root)</span>:</span>        <span class="hljs-string">"""</span><span class="hljs-string">        :type root: TreeNode</span><span class="hljs-string">        :rtype: List[List[int]]</span><span class="hljs-string">        """</span>        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> root:            <span class="hljs-keyword">return</span> []        level = <span class="hljs-number">0</span>        list = []        <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">nextLevel</span><span class="hljs-params">(level, node)</span>:</span>            <span class="hljs-keyword">if</span> len(list) &lt; level+<span class="hljs-number">1</span>:                list.append([node.val])            <span class="hljs-keyword">else</span>:                list[level].append(node.val)            <span class="hljs-keyword">if</span> node.left:                nextLevel(level+<span class="hljs-number">1</span>, node.left)            <span class="hljs-keyword">if</span> node.right:                nextLevel(level+<span class="hljs-number">1</span>, node.right)                nextLevel(level, root)        <span class="hljs-keyword">return</span> list[::<span class="hljs-number">-1</span>]</code></pre>]]></content>
    
    
    <categories>
      
      <category>Leetcode</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Leetcode 5 - 最长回文子串</title>
    <link href="/2020/05/21/leetcode-5/"/>
    <url>/2020/05/21/leetcode-5/</url>
    
    <content type="html"><![CDATA[<p>题目：</p><pre><code class="hljs quote">给定一个字符串 s，找到 s 中最长的回文子串。你可以假设 s 的最大长度为 1000。</code></pre><p>刚研究些动态规划模板趁热乎热热身<br>这个不是返回最长子串的长度，而是最长子串本身，如果有多个，保留最长一个就行了（一前一后保留后边一个，还可能增长）<br>状态：s中以第i个元素结尾的子串，最长回文子串为dp[i]<br>终结状态为dp[len(s)-1], base case为字符串为空，返回None；字符串为len(1), dp[0] = s[0]<br>每步先择：看看加上i后的尾巴上，是否有&gt;=len(pre)的回文串，有的话就更新pre. <del>这个时候就是看s[i-len(pre):i+1]是否是回文串，是的话替换pre。比pre长1，不可能更长了，更长的话之前pre的值都错了</del><br>因为dp table每一步都只需保留上一步的值，用pre来保持就行，降维空间复杂度<br>====================================================<br>“这个时候就是看s[i-len(pre):i+1]是否是回文串，是的话替换pre。比pre长1，不可能更长了，更长的话之前pre的值都错了”<br>这个选择错了。以下子串长度，就是从pre到pre+2的。投机取巧失败，重写选择<br>“babad”</p><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span><span class="hljs-params">(object)</span>:</span>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">longestPalindrome</span><span class="hljs-params">(self, s)</span>:</span>        <span class="hljs-string">"""</span><span class="hljs-string">        :type s: str</span><span class="hljs-string">        :rtype: str</span><span class="hljs-string">        """</span>        <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">isPalindrome</span><span class="hljs-params">(str)</span>:</span>            i, j = <span class="hljs-number">0</span>, len(str) - <span class="hljs-number">1</span>            <span class="hljs-keyword">while</span> i &lt;= j:                <span class="hljs-keyword">if</span> str[i] != str[j]:                    <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span>                <span class="hljs-comment">## 作为循环都忘了改变循环条件</span>                i+=<span class="hljs-number">1</span>                j-=<span class="hljs-number">1</span>            <span class="hljs-keyword">return</span> <span class="hljs-literal">True</span>        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> s:            <span class="hljs-keyword">return</span> <span class="hljs-string">""</span>                pre = <span class="hljs-string">""</span>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(<span class="hljs-number">0</span>, len(s), <span class="hljs-number">1</span>):            current_max_palindrome = <span class="hljs-string">""</span>            <span class="hljs-comment">## 这个子串头纠结了好久</span>            <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> range(<span class="hljs-number">0</span>, i-len(pre)+<span class="hljs-number">1</span>, <span class="hljs-number">1</span>):                <span class="hljs-keyword">if</span> isPalindrome(s[j:i+<span class="hljs-number">1</span>]) <span class="hljs-keyword">and</span> len(current_max_palindrome) &lt; len(s[j:i+<span class="hljs-number">1</span>]):                    current_max_palindrome = s[j:i+<span class="hljs-number">1</span>]                    <span class="hljs-keyword">break</span>            <span class="hljs-comment">## 这又忘了取大值了</span>            <span class="hljs-keyword">if</span> len(pre) &lt; len(current_max_palindrome):                pre = current_max_palindrome        <span class="hljs-keyword">return</span> pre</code></pre><p>s比较长的时候超出时间限制了…<br>确实，让我改成了暴力法了<br>看答案了…</p><p>动态规划应该是这样的状态转移公式：s[i,j] = s[i+1, j-1] &amp;&amp; s[i]==s[j]</p><h1 id="之后回来重做"><a href="#之后回来重做" class="headerlink" title="之后回来重做"></a>之后回来重做</h1><p>前几天刚尝试的，没做出来放着了，今天每日一题一定要做了<br>动态规划看这几天有没有沉淀能力下来（貌似并没有）<br>dp[i][j]定义：子串s[i:j+1]是否为回文子串，是为1，否为0<br>状态转换方程（偷看了一眼draft，自己发挥）：<br>(j-i)%2==0 则当前串为奇数；(j-i)%2==1 则当前串为偶数<br>dp[i][j] = 1 if i+1 &lt;= j-1 and dp[i+1][j-1]==1 and s[i]==s[j] else 0<br>计算顺序是从正坐标矩阵右下往左上算；因为j&gt;=i，所以填矩阵的左上角三角形；初始状态是对角线，全为1；循环到左上角<br>最终状态：max(j-i)的s[i:j+1]就是最大串<br>起始状态，不循环状态设定了，让循环变得更可读一些：</p><ol><li>dp[i][i] = 1，只有一个元素肯定是回文串</li><li>dp[i][i+1] = 1 if s[i]==s[i+1] else 0<br>留个变量记最大的max(j-i)</li></ol><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span><span class="hljs-params">(object)</span>:</span>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">longestPalindrome</span><span class="hljs-params">(self, s)</span>:</span>        <span class="hljs-string">"""</span><span class="hljs-string">        :type s: str</span><span class="hljs-string">        :rtype: str</span><span class="hljs-string">        """</span>        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> s:            <span class="hljs-keyword">return</span> <span class="hljs-string">""</span>        max_sub = [<span class="hljs-number">0</span>,<span class="hljs-number">0</span>]        dp = [[<span class="hljs-number">0</span> <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(len(s))] <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> range(len(s))]        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(len(s)):            dp[i][i] = <span class="hljs-number">1</span>            <span class="hljs-keyword">if</span> i+<span class="hljs-number">1</span>&lt;len(s) <span class="hljs-keyword">and</span> s[i]==s[i+<span class="hljs-number">1</span>]:                dp[i][i+<span class="hljs-number">1</span>] = <span class="hljs-number">1</span>                <span class="hljs-keyword">if</span> max_sub[<span class="hljs-number">1</span>] - max_sub[<span class="hljs-number">0</span>] &lt; <span class="hljs-number">1</span>:                    max_sub =[i,i+<span class="hljs-number">1</span>]                <span class="hljs-comment">## 错误的循环方式</span>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(len(s)<span class="hljs-number">-2</span>):            <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> range(len(s)-i, len(s)):                <span class="hljs-keyword">if</span> dp[i+<span class="hljs-number">1</span>][j<span class="hljs-number">-1</span>]==<span class="hljs-number">1</span> <span class="hljs-keyword">and</span> s[i]==s[j]:                    dp[i][j] = <span class="hljs-number">1</span>                    <span class="hljs-keyword">if</span> max_sub[<span class="hljs-number">1</span>] - max_sub[<span class="hljs-number">0</span>] &lt; j-i:                        max_sub =[i,j]        <span class="hljs-keyword">return</span> s[i:j+<span class="hljs-number">1</span>]</code></pre><p>上边答案错了，明知道是应该按从右下到左上斜着遍历，结果成了从左上开始一列一列向右遍历了，这样答案对不了，重写<br>斜着遍历写法不熟，再看看小抄</p><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span><span class="hljs-params">(object)</span>:</span>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">longestPalindrome</span><span class="hljs-params">(self, s)</span>:</span>        <span class="hljs-string">"""</span><span class="hljs-string">        :type s: str</span><span class="hljs-string">        :rtype: str</span><span class="hljs-string">        """</span>        <span class="hljs-comment"># 排除异常情况也重写了</span>        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> s:            <span class="hljs-keyword">return</span> <span class="hljs-string">""</span>        <span class="hljs-keyword">if</span> len(s) == <span class="hljs-number">1</span>:            <span class="hljs-keyword">return</span> s        <span class="hljs-keyword">if</span> len(s) == <span class="hljs-number">2</span>:            <span class="hljs-keyword">return</span> s <span class="hljs-keyword">if</span> s[<span class="hljs-number">0</span>] == s[<span class="hljs-number">1</span>] <span class="hljs-keyword">else</span> s[<span class="hljs-number">0</span>]        max_sub = [<span class="hljs-number">0</span>,<span class="hljs-number">0</span>]        dp = [[<span class="hljs-number">0</span> <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(len(s))] <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> range(len(s))]        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(len(s)):            dp[i][i] = <span class="hljs-number">1</span>            <span class="hljs-keyword">if</span> i+<span class="hljs-number">1</span>&lt;len(s) <span class="hljs-keyword">and</span> s[i]==s[i+<span class="hljs-number">1</span>]:                dp[i][i+<span class="hljs-number">1</span>] = <span class="hljs-number">1</span>                <span class="hljs-keyword">if</span> max_sub[<span class="hljs-number">1</span>] - max_sub[<span class="hljs-number">0</span>] &lt; <span class="hljs-number">1</span>:                    max_sub =[i,i+<span class="hljs-number">1</span>]                <span class="hljs-comment"># 从对角线起，向左上角斜着遍历</span>        <span class="hljs-comment"># n为斜向上j-i的差，因为要算左上三角，j肯定&gt;i，而且斜向前两行做了初始值，从j-i=2开始</span>        <span class="hljs-comment"># 即j=i+n，j本身不用存在</span>        <span class="hljs-comment"># 初始化可以根据n=0或n=1合并到for循环里</span>        <span class="hljs-keyword">for</span> n <span class="hljs-keyword">in</span> range(<span class="hljs-number">2</span>, len(s)):            <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(len(s)<span class="hljs-number">-2</span>):                <span class="hljs-comment">## j=i+n首先不能溢出数组才又算的意义</span>                <span class="hljs-keyword">if</span> i+n &lt; len(s) <span class="hljs-keyword">and</span> dp[i+<span class="hljs-number">1</span>][i+n<span class="hljs-number">-1</span>]==<span class="hljs-number">1</span> <span class="hljs-keyword">and</span> s[i]==s[i+n]:                    dp[i][i+n] = <span class="hljs-number">1</span>                    <span class="hljs-keyword">if</span> max_sub[<span class="hljs-number">1</span>] - max_sub[<span class="hljs-number">0</span>] &lt; n:                        max_sub =[i,i+n]        <span class="hljs-keyword">return</span> s[max_sub[<span class="hljs-number">0</span>]:max_sub[<span class="hljs-number">1</span>]+<span class="hljs-number">1</span>]</code></pre><p>答案还包括中心扩展法，把所有长度为1或2的回文串作为最小中心向外极力延申，只保留最大子串，因为不用二维数组了，空间复杂度降到1了</p><p>manacher法，时间复杂度n，空间复杂度n，没看放以后吧</p>]]></content>
    
    
    <categories>
      
      <category>Leetcode</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Leetcode 1371 - 每个元音包含偶数次的最长子字符串</title>
    <link href="/2020/05/20/leetcode-1371/"/>
    <url>/2020/05/20/leetcode-1371/</url>
    
    <content type="html"><![CDATA[<p>题目：</p><pre><code class="hljs quote">给你一个字符串 s ，请你返回满足以下条件的最长子字符串的长度：每个元音字母，即 &#39;a&#39;，&#39;e&#39;，&#39;i&#39;，&#39;o&#39;，&#39;u&#39; ，在子字符串中都恰好出现了偶数次。</code></pre><p>元音可以为0个<br>没有元音的s，最大长度为len(s)<br>以5位二进制串00000来保存aeiou元音在某个状态是奇数还是偶数</p><p>状态：s的子串s, 其二进制串的值<br>选择：下一个子串<br>dp定义：dp[i][j], s的子串[i,j],其二进制串的值, 串为00000则该子串满足条件，记录到当前max<br>状态转移方程：<br>dp[i][j] = dp[i][j-1]^s[j]对应二进制数 , i&lt;=j  异或运算<br>初始状态： dp[0][0] = dict[s[0]] if dict[s[0]]<br>终结状态： 全部穷举完，max(j-i) and dp[i][j] = 00000<br>怎么感觉用不出动态规划套不进去，变成了两层循环，不过可以压到nlogn的样子</p><p>不过二进制转换命令我也不会啊，这只能看答案了</p><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span><span class="hljs-params">(object)</span>:</span>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">findTheLongestSubstring</span><span class="hljs-params">(self, s)</span>:</span>        <span class="hljs-string">"""</span><span class="hljs-string">        :type s: str</span><span class="hljs-string">        :rtype: int</span><span class="hljs-string">        """</span>        dict = &#123;            <span class="hljs-string">'a'</span>: <span class="hljs-number">10000</span>,            <span class="hljs-string">'e'</span>: <span class="hljs-number">01000</span>,            <span class="hljs-string">'i'</span>: <span class="hljs-number">00100</span>,            <span class="hljs-string">'o'</span>: <span class="hljs-number">00010</span>,            <span class="hljs-string">'u'</span>: <span class="hljs-number">00001</span>        &#125;        res = <span class="hljs-number">0</span>        dp = [[<span class="hljs-number">00000</span> <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(s)] <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> range(s)]        <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> range(s):            <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(j):</code></pre><p>前缀和+二进制压缩，5位2进制数的十进制区间为[0,31], 所以建立一个包括32个[-1]list备用<br>我想到了用二进制代表元音，但没想到前缀和解法<br>前缀和：串[i,j] = 串[0,j] - 串[0,i]<br>我想到的是把五位二进制数作为二维数组值，但解法是把二进制数化为十进制作为数组坐标，数组值为特定元音组合的最小串长度</p><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span>:</span>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">findTheLongestSubstring</span><span class="hljs-params">(self, s)</span>:</span>        ans, status, n = <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, len(s)        <span class="hljs-comment"># &lt;&lt; 是位运算，把1向前移动5位，就是32</span>        pos = [<span class="hljs-number">-1</span>] * (<span class="hljs-number">1</span> &lt;&lt; <span class="hljs-number">5</span>)        <span class="hljs-comment"># 初始化，默认最小值[00000]=0.开始第一位时候非元音，则答案就是1了。循环没法往pos[0]设置0</span>        pos[<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(n):            <span class="hljs-keyword">if</span> s[i] == <span class="hljs-string">'a'</span>:                <span class="hljs-comment"># ^ 异或运算，对应位不相等时结果为1，相等为0，status记录上一步元音出现的奇偶次数 </span>                status ^= <span class="hljs-number">1</span> &lt;&lt; <span class="hljs-number">0</span>            <span class="hljs-keyword">elif</span> s[i] == <span class="hljs-string">'e'</span>:                status ^= <span class="hljs-number">1</span> &lt;&lt; <span class="hljs-number">1</span>            <span class="hljs-keyword">elif</span> s[i] == <span class="hljs-string">'i'</span>:                status ^= <span class="hljs-number">1</span> &lt;&lt; <span class="hljs-number">2</span>            <span class="hljs-keyword">elif</span> s[i] == <span class="hljs-string">'o'</span>:                status ^= <span class="hljs-number">1</span> &lt;&lt; <span class="hljs-number">3</span>            <span class="hljs-keyword">elif</span> s[i] == <span class="hljs-string">'u'</span>:                status ^= <span class="hljs-number">1</span> &lt;&lt; <span class="hljs-number">4</span>            <span class="hljs-comment"># 某前缀情况已经写入</span>            <span class="hljs-keyword">if</span> pos[status] != <span class="hljs-number">-1</span>:                <span class="hljs-comment"># 当前长度减去该情况最小长度。因为偶数-偶数=偶数，奇数-奇数=偶数，所以不用区别元音奇偶具体组成</span>                <span class="hljs-comment"># 把相同的奇偶组成情况相减，剩下的子串各元音个数必为偶数</span>                ans = max(ans, i + <span class="hljs-number">1</span> - pos[status])            <span class="hljs-comment"># 第一次遇见某前缀情况</span>            <span class="hljs-keyword">else</span>:                <span class="hljs-comment"># 记录该前缀情况作为该情况最小值就行，后边无需更新，因为要求最大值，就是最大值-最小值</span>                pos[status] = i + <span class="hljs-number">1</span>        <span class="hljs-keyword">return</span> ans</code></pre>]]></content>
    
    
    <categories>
      
      <category>Leetcode</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Leetcode 198 - 打家劫舍</title>
    <link href="/2020/05/19/leetcode-198/"/>
    <url>/2020/05/19/leetcode-198/</url>
    
    <content type="html"><![CDATA[<p>题目：</p><pre><code class="hljs quote">你是一个专业的小偷，计划偷窃沿街的房屋。每间房内都藏有一定的现金，影响你偷窃的唯一制约因素就是相邻的房屋装有相互连通的防盗系统，如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警。给定一个代表每个房屋存放金额的非负整数数组，计算你在不触动警报装置的情况下，能够偷窃到的最高金额。</code></pre><p>状态：当前屋号i 0&lt;=i&lt;len(nums)<br>选择：选择偷下一间屋子<br>dp定义：dp[i] 偷包括i号屋在内，能偷到的最大金额<br>状态转移方程：dp[i] = dp[i-2] + nums[i]   dp[i-1]不要，因为必须隔着来偷<br>终结状态两个：dp[len(nums)-1], dp[len(nums)-2]里边大的，因为nums长度不确定<br>起始状态：dp[0]=nums[0] dp[1]=max(nums[0], nums[1])</p><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span><span class="hljs-params">(object)</span>:</span>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">rob</span><span class="hljs-params">(self, nums)</span>:</span>        <span class="hljs-string">"""</span><span class="hljs-string">        :type nums: List[int]</span><span class="hljs-string">        :rtype: int</span><span class="hljs-string">        """</span>        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> nums:            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>        <span class="hljs-keyword">if</span> len(nums) == <span class="hljs-number">1</span>:            <span class="hljs-keyword">return</span> nums[<span class="hljs-number">0</span>]        <span class="hljs-keyword">if</span> len(nums) == <span class="hljs-number">2</span>:            <span class="hljs-keyword">return</span> max(nums[<span class="hljs-number">0</span>], nums[<span class="hljs-number">1</span>])        dp = [<span class="hljs-number">0</span> <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(len(nums))]        <span class="hljs-comment">## 上边写下边忘</span>        dp[<span class="hljs-number">0</span>]=nums[<span class="hljs-number">0</span>]        dp[<span class="hljs-number">1</span>]=max(nums[<span class="hljs-number">0</span>], nums[<span class="hljs-number">1</span>])        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(<span class="hljs-number">2</span>, len(nums), <span class="hljs-number">1</span>):            dp[i] = dp[i<span class="hljs-number">-2</span>] + nums[i]        <span class="hljs-keyword">return</span> max(dp[len(nums)<span class="hljs-number">-1</span>], dp[len(nums)<span class="hljs-number">-2</span>])</code></pre><p>这写法只能应付交错排布，不能解决其它问题。比如：<br>[1,3,1,3,100]<br>重写算法</p><p>状态：当前屋号i 0&lt;=i&lt;len(nums)<br>选择：选择偷下一间屋子<br>dp定义：dp[i] 偷包括i号屋在内，能偷到的最大金额<br>状态转移方程：dp[i] = max(dp[i-2], dp[i-3]) + nums[i]   dp[i-1]不要，因为必须隔着来偷<br>终结状态两个：dp[len(nums)-1], dp[len(nums)-2]里边大的，因为nums长度不确定, 大值不一定落到哪个上了<br>起始状态：dp[0]=nums[0] dp[1]=max(nums[0], nums[1]) dp[2]=max(nums[0]+nums[2], nums[1])</p><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span><span class="hljs-params">(object)</span>:</span>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">rob</span><span class="hljs-params">(self, nums)</span>:</span>        <span class="hljs-string">"""</span><span class="hljs-string">        :type nums: List[int]</span><span class="hljs-string">        :rtype: int</span><span class="hljs-string">        """</span>        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> nums:            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>        <span class="hljs-keyword">if</span> len(nums) == <span class="hljs-number">1</span>:            <span class="hljs-keyword">return</span> nums[<span class="hljs-number">0</span>]        <span class="hljs-keyword">if</span> len(nums) == <span class="hljs-number">2</span>:            <span class="hljs-keyword">return</span> max(nums[<span class="hljs-number">0</span>], nums[<span class="hljs-number">1</span>])        <span class="hljs-keyword">if</span> len(nums) == <span class="hljs-number">3</span>:            <span class="hljs-comment"># 下边的官方推导公式我已经写出来了，但是没意识到</span>            <span class="hljs-keyword">return</span> max(nums[<span class="hljs-number">0</span>]+nums[<span class="hljs-number">2</span>], nums[<span class="hljs-number">1</span>])        dp = [<span class="hljs-number">0</span> <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(len(nums))]        dp[<span class="hljs-number">0</span>]=nums[<span class="hljs-number">0</span>]        dp[<span class="hljs-number">1</span>]=max(nums[<span class="hljs-number">0</span>], nums[<span class="hljs-number">1</span>])        dp[<span class="hljs-number">2</span>]=max(nums[<span class="hljs-number">0</span>]+nums[<span class="hljs-number">2</span>], nums[<span class="hljs-number">1</span>])        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(<span class="hljs-number">3</span>, len(nums), <span class="hljs-number">1</span>):            dp[i] = max(dp[i<span class="hljs-number">-2</span>], dp[i<span class="hljs-number">-3</span>]) + nums[i]        <span class="hljs-keyword">return</span> max(dp[len(nums)<span class="hljs-number">-1</span>], dp[len(nums)<span class="hljs-number">-2</span>])</code></pre><p>官方的推导公式 dp[i] = max(dp[i-2] + nums[i], dp[i-1]), 试试<br>这个dp[i]的定义是偷到i屋的最大价值，不一定包括i屋在内<br>终结状态：dp[i]<br>起始状态：dp[0]=nums[0] dp[1]=max(nums[0], nums[1])</p><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span><span class="hljs-params">(object)</span>:</span>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">rob</span><span class="hljs-params">(self, nums)</span>:</span>        <span class="hljs-string">"""</span><span class="hljs-string">        :type nums: List[int]</span><span class="hljs-string">        :rtype: int</span><span class="hljs-string">        """</span>        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> nums:            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>        <span class="hljs-keyword">if</span> len(nums) == <span class="hljs-number">1</span>:            <span class="hljs-keyword">return</span> nums[<span class="hljs-number">0</span>]        <span class="hljs-keyword">if</span> len(nums) == <span class="hljs-number">2</span>:            <span class="hljs-keyword">return</span> max(nums[<span class="hljs-number">0</span>], nums[<span class="hljs-number">1</span>])        dp = [<span class="hljs-number">0</span> <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(len(nums))]        dp[<span class="hljs-number">0</span>]=nums[<span class="hljs-number">0</span>]        dp[<span class="hljs-number">1</span>]=max(nums[<span class="hljs-number">0</span>], nums[<span class="hljs-number">1</span>])        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(<span class="hljs-number">2</span>, len(nums), <span class="hljs-number">1</span>):            dp[i] = max(dp[i<span class="hljs-number">-2</span>] + nums[i], dp[i<span class="hljs-number">-1</span>])        <span class="hljs-keyword">return</span> dp[i]</code></pre>]]></content>
    
    
    <categories>
      
      <category>Leetcode</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Leetcode 121 - 买卖股票的最佳时机</title>
    <link href="/2020/05/19/leetcode-121/"/>
    <url>/2020/05/19/leetcode-121/</url>
    
    <content type="html"><![CDATA[<p>题目：</p><pre><code class="hljs quote">给定一个数组，它的第 i 个元素是一支给定股票第 i 天的价格。如果你最多只允许完成一笔交易（即买入和卖出一支股票一次），设计一个算法来计算你所能获取的最大利润。注意：你不能在买入股票前卖出股票。</code></pre><p>碰上了刚看的股票买卖问题啦，做这道最简单的<br>状态：当前是第i天，是否持有股票<br>dp定义：dp[i][0,1] 第i天持有(不持有)股票的最大利润<br>选择：dp[i][0] 可以选择买入；dp[i][1] 可以选择卖出<br>状态转换方程 :</p><ol><li>dp[i][0] = max(dp[i-1][0], dp[i-1][1] + prices[i]) 继续保持之前的最大利润，或尝试卖出之前股票获得的最大利润</li><li>dp[i][1] = max(dp[i-1][1], - prices[i]) 继续保持之前买股票的支出，或者这一天的支出小于之前天的，就更新<br>终结状态：dp[len(prices)-1][0]<br>base case:</li><li>dp[0][0,1] = 0 这里没有第0天的概念，不该有值</li><li>dp[1][0] = 0 第一天不可能有利润的，不够时间买卖；dp[1][1]=-prices[0] 第一天直接卖钱</li></ol><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span><span class="hljs-params">(object)</span>:</span>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">maxProfit</span><span class="hljs-params">(self, prices)</span>:</span>        <span class="hljs-string">"""</span><span class="hljs-string">        :type prices: List[int]</span><span class="hljs-string">        :rtype: int</span><span class="hljs-string">        """</span>                <span class="hljs-keyword">if</span> len(prices) &lt;= <span class="hljs-number">1</span>:            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>        <span class="hljs-comment">## 二维数组全部初始化为0的写法</span>        <span class="hljs-comment">## dp = [[0,0]*(len(prices)+1)]</span>        <span class="hljs-comment">## 这个写法导致dp为 [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]]</span>        <span class="hljs-comment">## 这个写法导致内部所有的[0,0]元素，指向了一个地址，下边迭代会一改全改</span>        <span class="hljs-comment">## dp = [[0,0]]*(len(prices)+1)</span>        <span class="hljs-comment">## 要通过循环来创建</span>        dp = [[<span class="hljs-number">0</span> <span class="hljs-keyword">for</span> t <span class="hljs-keyword">in</span> range(<span class="hljs-number">2</span>)] <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(len(prices)+<span class="hljs-number">1</span>)]        <span class="hljs-comment">## 第一天直接卖钱</span>        dp[<span class="hljs-number">1</span>][<span class="hljs-number">1</span>]=-prices[<span class="hljs-number">0</span>]        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(<span class="hljs-number">2</span>, len(prices)+<span class="hljs-number">1</span>, <span class="hljs-number">1</span>):            <span class="hljs-comment">## prices状态搞错了。当前状态为上一个状态转换来的</span>            <span class="hljs-comment"># dp[i][0] = max(dp[i-1][0], dp[i-1][1] + prices[i])</span>            <span class="hljs-comment"># dp[i][1] = max(dp[i-1][1], dp[i-1][0] - prices[i])</span>            dp[i][<span class="hljs-number">0</span>] = max(dp[i<span class="hljs-number">-1</span>][<span class="hljs-number">0</span>], dp[i<span class="hljs-number">-1</span>][<span class="hljs-number">1</span>] + prices[i<span class="hljs-number">-1</span>])            <span class="hljs-comment">## k最大交易次数忘了，这里k属于[0,1],不能进行多次交易的。死抄答案要死。 dp[i-1][0] - prices[i-1]不需要，是因为只交易一次，没有二次交易存在，所以不需在老利润基础上搞事情</span>            <span class="hljs-comment">## dp[i][1] = max(dp[i-1][1], dp[i-1][0] - prices[i-1])</span>            dp[i][<span class="hljs-number">1</span>] = max(dp[i<span class="hljs-number">-1</span>][<span class="hljs-number">1</span>], - prices[i<span class="hljs-number">-1</span>])        <span class="hljs-keyword">return</span> dp[<span class="hljs-number">-1</span>][<span class="hljs-number">0</span>]</code></pre><p>做个题艰难得要命<br><a href="https://blog.csdn.net/qq_32799915/article/details/86520438" target="_blank" rel="noopener">同样被初始化坑了的同学</a></p>]]></content>
    
    
    <categories>
      
      <category>Leetcode</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Leetcode 70 - 爬楼梯</title>
    <link href="/2020/05/19/leetcode-70/"/>
    <url>/2020/05/19/leetcode-70/</url>
    
    <content type="html"><![CDATA[<p>题目：</p><pre><code class="hljs quote">假设你正在爬楼梯。需要 n 阶你才能到达楼顶。每次你可以爬 1 或 2 个台阶。你有多少种不同的方法可以爬到楼顶呢？注意：给定 n 是一个正整数。</code></pre><p>现在有点挫败感，动态规划的模板不好套啊。还是从简单的搞起来，过几道，不会的跳过做出两个再说<br>状态：当前在第i阶，0&lt;=i&lt;=n<br>选择：向上1或2阶<br>dp(i)含义：到第i阶时的走法总和<br>终结态：dp(n-1)<br>状态转换方程：dp(i) = dp(i-2) + dp(i-1)，两种状态再进一步就到新状态，所以新状态的总走法就是前两状态的总走法和。这么像斐波那契数列呢<br>初始态：dp(0) = 1 本来不存在的，帮助迭代；dp(1) = 1 有一个台阶，只有1种走法</p><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span><span class="hljs-params">(object)</span>:</span>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">climbStairs</span><span class="hljs-params">(self, n)</span>:</span>        <span class="hljs-string">"""</span><span class="hljs-string">        :type n: int</span><span class="hljs-string">        :rtype: int</span><span class="hljs-string">        """</span>        <span class="hljs-keyword">if</span> n == <span class="hljs-number">1</span>:            <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>        dp = [<span class="hljs-number">1</span>]*(n+<span class="hljs-number">1</span>)                <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(<span class="hljs-number">2</span>, n+<span class="hljs-number">1</span>, <span class="hljs-number">1</span>):            dp[i] = dp[i<span class="hljs-number">-2</span>]+dp[i<span class="hljs-number">-1</span>]        <span class="hljs-keyword">return</span> dp[n]</code></pre><p>简化空间，每步只要记住前两个就行了</p><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span><span class="hljs-params">(object)</span>:</span>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">climbStairs</span><span class="hljs-params">(self, n)</span>:</span>        <span class="hljs-string">"""</span><span class="hljs-string">        :type n: int</span><span class="hljs-string">        :rtype: int</span><span class="hljs-string">        """</span>        <span class="hljs-keyword">if</span> n == <span class="hljs-number">1</span>:            <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>        pre1 = <span class="hljs-number">1</span>        pre2 = <span class="hljs-number">1</span>                <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(<span class="hljs-number">2</span>, n+<span class="hljs-number">1</span>, <span class="hljs-number">1</span>):            cur = pre2 + pre1            pre1 = pre2            pre2 = cur        <span class="hljs-keyword">return</span> pre2</code></pre>]]></content>
    
    
    <categories>
      
      <category>Leetcode</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Leetcode 680 - 验证回文字符串 Ⅱ</title>
    <link href="/2020/05/19/leetcode-680/"/>
    <url>/2020/05/19/leetcode-680/</url>
    
    <content type="html"><![CDATA[<p>题目：</p><pre><code class="hljs quote">给定一个非空字符串 s，最多删除一个字符。判断是否能成为回文字符串。</code></pre><p>双指针玩法，从两头向中间走，最多跳过一个字符。为什么不从中间往两头走，因为这个串的二分查找中点起始状态有点难判断</p><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span><span class="hljs-params">(object)</span>:</span>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">validPalindrome</span><span class="hljs-params">(self, s)</span>:</span>        <span class="hljs-string">"""</span><span class="hljs-string">        :type s: str</span><span class="hljs-string">        :rtype: bool</span><span class="hljs-string">        """</span>        pointer = <span class="hljs-number">0</span>        delete_times = <span class="hljs-number">0</span>        offset_right = <span class="hljs-number">0</span>        offset_left = <span class="hljs-number">0</span>        <span class="hljs-comment"># 这个判断条件不用管奇偶了。用的下标所以多减1</span>        <span class="hljs-keyword">while</span> pointer &lt;= len(s)<span class="hljs-number">-1</span>-pointer:            <span class="hljs-keyword">if</span> s[pointer+offset_left] != s[len(s)<span class="hljs-number">-1</span>-pointer+offset_right]:                delete_times += <span class="hljs-number">1</span>                <span class="hljs-keyword">if</span> s[pointer] == s[len(s)<span class="hljs-number">-1</span>-pointer<span class="hljs-number">-1</span>]:                    offset_right = <span class="hljs-number">-1</span>                <span class="hljs-keyword">elif</span> s[pointer+<span class="hljs-number">1</span>] == s[len(s)<span class="hljs-number">-1</span>-pointer]:                    offset_left = <span class="hljs-number">1</span>                <span class="hljs-keyword">else</span>:                    <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span>            <span class="hljs-keyword">if</span> delete_times &gt; <span class="hljs-number">1</span>:                <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span>            pointer += <span class="hljs-number">1</span>        <span class="hljs-keyword">return</span> <span class="hljs-literal">True</span></code></pre><p>以上解法错误。漏了情况。像下边的字串应该删左边的e，而不是右边的c。代码逻辑要大改<br>“ececabbacec”</p><p>改造一下。两头走，找到不相同的位置，尝试左右两种删除方式的折半对比，都不行，就返回False，其它情况是True</p><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span><span class="hljs-params">(object)</span>:</span>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">validPalindrome</span><span class="hljs-params">(self, s)</span>:</span>        <span class="hljs-string">"""</span><span class="hljs-string">        :type s: str</span><span class="hljs-string">        :rtype: bool</span><span class="hljs-string">        """</span>        pointer = <span class="hljs-number">0</span>        checkpoint = <span class="hljs-literal">None</span>        <span class="hljs-keyword">while</span> pointer &lt;= len(s)<span class="hljs-number">-1</span>-pointer:            <span class="hljs-keyword">if</span> s[pointer] != s[len(s)<span class="hljs-number">-1</span>-pointer]:                checkpoint = pointer                <span class="hljs-keyword">break</span>            pointer += <span class="hljs-number">1</span>        <span class="hljs-keyword">if</span> checkpoint == <span class="hljs-literal">None</span>:            <span class="hljs-keyword">return</span> <span class="hljs-literal">True</span>        <span class="hljs-keyword">else</span>:            <span class="hljs-comment"># 开始实验两种删除方法后，能否对比到底</span>            <span class="hljs-comment">## [:]闭开区间，闭区间是可以取的，开区间不包括端点</span>            try1 = list(s)[checkpoint:(len(s)<span class="hljs-number">-1</span>-checkpoint)]            try2 = list(s)[(checkpoint+<span class="hljs-number">1</span>):(len(s)-checkpoint)]            <span class="hljs-comment">## reverse()是没法进行这种计较的，用[::-1]反转列表</span>            <span class="hljs-comment"># if try1 == try1.reverse() or try2 == try2.reverse():</span>            <span class="hljs-keyword">if</span> try1 == try1[::<span class="hljs-number">-1</span>] <span class="hljs-keyword">or</span> try2 == try2[::<span class="hljs-number">-1</span>]:                <span class="hljs-keyword">return</span> <span class="hljs-literal">True</span>            <span class="hljs-keyword">else</span>:                <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span></code></pre><p>我的答案速度才击败12%<br>正确答案和我思路一样。原来这种思考方式属于贪心算法。<br>看了之后的感觉：</p><ol><li>想到双指针了，还用单指针实现，啰嗦</li><li>代码写的比较繁琐难读，像最后4行可以合并的</li><li>后半去反转列表，当然效率低</li></ol><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span>:</span>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">validPalindrome</span><span class="hljs-params">(self, s: str)</span> -&gt; bool:</span>        <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">checkPalindrome</span><span class="hljs-params">(low, high)</span>:</span>            i, j = low, high            <span class="hljs-keyword">while</span> i &lt; j:                <span class="hljs-keyword">if</span> s[i] != s[j]:                    <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span>                i += <span class="hljs-number">1</span>                j -= <span class="hljs-number">1</span>            <span class="hljs-keyword">return</span> <span class="hljs-literal">True</span>        low, high = <span class="hljs-number">0</span>, len(s) - <span class="hljs-number">1</span>        <span class="hljs-keyword">while</span> low &lt; high:            <span class="hljs-keyword">if</span> s[low] == s[high]:                 low += <span class="hljs-number">1</span>                high -= <span class="hljs-number">1</span>            <span class="hljs-keyword">else</span>:                <span class="hljs-keyword">return</span> checkPalindrome(low + <span class="hljs-number">1</span>, high) <span class="hljs-keyword">or</span> checkPalindrome(low, high - <span class="hljs-number">1</span>)        <span class="hljs-keyword">return</span> <span class="hljs-literal">True</span></code></pre>]]></content>
    
    
    <categories>
      
      <category>Leetcode</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Leetcode 152 - 乘积最大子数组</title>
    <link href="/2020/05/18/leetcode-152/"/>
    <url>/2020/05/18/leetcode-152/</url>
    
    <content type="html"><![CDATA[<p>题目：</p><pre><code class="hljs quote">给你一个整数数组 nums ，请你找出数组中乘积最大的连续子数组（该子数组中至少包含一个数字），并返回该子数组所对应的乘积。</code></pre><p>前几天有做过一道和为k的字符串字串个数的题，已经模糊了回忆一下。用的前缀和创建的字典来降维的。这里是否是用前缀乘积？好像不是，因为这是极值，不是求个数<br>子数组可能不止一个，不过乘积相同返回结果就行，也没差</p><p>每轮迭代，nums[:i+1]中所有可能组合的最大值<br>reduce忘了用法，再记一次：reduce(lambda x, y: x+y, nums[slow_pointer:fast_pointer+1])</p><p>暴力法，时间超出限制，意料之中：</p><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span><span class="hljs-params">(object)</span>:</span>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">maxProduct</span><span class="hljs-params">(self, nums)</span>:</span>        <span class="hljs-string">"""</span><span class="hljs-string">        :type nums: List[int]</span><span class="hljs-string">        :rtype: int</span><span class="hljs-string">        """</span>        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> nums:            <span class="hljs-keyword">return</span>        res = float(<span class="hljs-string">"-inf"</span>)        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(<span class="hljs-number">0</span>, len(nums), <span class="hljs-number">1</span>):            <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> range(<span class="hljs-number">0</span>, i+<span class="hljs-number">1</span>, <span class="hljs-number">1</span>):                <span class="hljs-comment"># res = max(res, reduce(m*n for m, n in nums[j:i+1])) 忘了怎么用reduce了</span>                res = max(res, reduce(<span class="hljs-keyword">lambda</span> m, n: m*n, nums[j:i+<span class="hljs-number">1</span>]))        <span class="hljs-keyword">return</span> res</code></pre><p>看答案前，想到了正负值情况要分别处理，因为当前值如果是负的，则乘积会把之前循环的最小值变成最大的<br>也想到了，当前最大值，为前一循环最大值*当前值和当前值两个里边大的那个。但是其实里边是两层逻辑，这里少考虑了一层<br>正确思考方向是：</p><ol><li>当前循环求的是以包括当前值在内(作为子数组尾部)的最大子数组，该数组是前一循环最大子数组*当前值，和当前值两个中大的那一个；</li><li>要求的最终结果，是当前循环最大子数组的结果，和之前所有循环最大子数组结果里最大那个，两个中大的</li></ol><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span><span class="hljs-params">(object)</span>:</span>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">maxProduct</span><span class="hljs-params">(self, nums)</span>:</span>        <span class="hljs-string">"""</span><span class="hljs-string">        :type nums: List[int]</span><span class="hljs-string">        :rtype: int</span><span class="hljs-string">        """</span>        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> nums:            <span class="hljs-keyword">return</span>        res = float(<span class="hljs-string">"-inf"</span>)        imax = <span class="hljs-number">1</span>        imin = <span class="hljs-number">1</span>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(<span class="hljs-number">0</span>, len(nums), <span class="hljs-number">1</span>):            <span class="hljs-keyword">if</span> nums[i] &lt; <span class="hljs-number">0</span>:                imax, imin = imin, imax                        <span class="hljs-comment"># 这里纠结了好一会儿，没想明白前一循环imax就是一定包含nums[i-1]的，和nums[i]一定相邻</span>            imax = max(imax*nums[i], nums[i])            imin = min(imin*nums[i], nums[i])            res = max(res, imax)        <span class="hljs-keyword">return</span> res</code></pre>]]></content>
    
    
    <categories>
      
      <category>Leetcode</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Leetcode 496 - 下一个更大元素 I</title>
    <link href="/2020/05/15/leetcode-496/"/>
    <url>/2020/05/15/leetcode-496/</url>
    
    <content type="html"><![CDATA[<p>题目：</p><pre><code class="hljs quote">给定两个 没有重复元素 的数组 nums1 和 nums2 ，其中nums1 是 nums2 的子集。找到 nums1 中每个元素在 nums2 中的下一个比其大的值。nums1 中数字 x 的下一个更大元素是指 x 在 nums2 中对应位置的右边的第一个比 x 大的元素。如果不存在，对应位置输出 -1 。</code></pre><p>遍历一遍nums2，肯定走了一遍nums1的元素了。先处理一下nums1的元素，方便遍历nums2时候好找</p><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span><span class="hljs-params">(object)</span>:</span>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">nextGreaterElement</span><span class="hljs-params">(self, nums1, nums2)</span>:</span>        <span class="hljs-string">"""</span><span class="hljs-string">        :type nums1: List[int]</span><span class="hljs-string">        :type nums2: List[int]</span><span class="hljs-string">        :rtype: List[int]</span><span class="hljs-string">        """</span>        <span class="hljs-comment"># 元素做k，位置做v</span>        dic = &#123;nums1[i]:i <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(<span class="hljs-number">0</span>, len(nums1), <span class="hljs-number">1</span>)&#125;        res =[<span class="hljs-number">-1</span>]*len(nums1)        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(<span class="hljs-number">0</span>, len(nums2), <span class="hljs-number">1</span>):            <span class="hljs-keyword">if</span> nums2[i] <span class="hljs-keyword">in</span> dic:                <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> range(i+<span class="hljs-number">1</span>, len(nums2), <span class="hljs-number">1</span>):                    <span class="hljs-keyword">if</span> nums2[i] &lt; nums2[j]:                        res[dic[nums2[i]]] = nums2[j]                        <span class="hljs-comment"># 刚还想着却忘了，继续往下算就错了</span>                        <span class="hljs-keyword">break</span>        <span class="hljs-keyword">return</span> res</code></pre><p>可算自己作对了一道，不过时间复杂度O(n^2)，官方答案用栈O(m+n)，研究一下<br>看懂思路了，不管nums1，只处理nums2<br>用单调递增栈（从顶到底）中间处理，生成一个所有nums2元素的字典，k为元素值，v为该元素对应的下一个比其大数的数。如没有就最后出栈，v设为-1<br>然后过一遍nums1，对应到字典就行。自己写一个<br>看起来和我的复杂性差不多啊。但就是比我的快</p><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span><span class="hljs-params">(object)</span>:</span>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">nextGreaterElement</span><span class="hljs-params">(self, nums1, nums2)</span>:</span>        <span class="hljs-string">"""</span><span class="hljs-string">        :type nums1: List[int]</span><span class="hljs-string">        :type nums2: List[int]</span><span class="hljs-string">        :rtype: List[int]</span><span class="hljs-string">        """</span>        stack = []        map = &#123;&#125;        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> nums2:            <span class="hljs-keyword">while</span> stack:                pre = stack.pop()                <span class="hljs-keyword">if</span> pre &lt; i:                    map[pre] = i                <span class="hljs-keyword">else</span>:                    stack.append(pre)                    <span class="hljs-keyword">break</span>            stack.append(i)        <span class="hljs-keyword">while</span> stack:            map[stack.pop()] = <span class="hljs-number">-1</span>        <span class="hljs-keyword">return</span> [map[i] <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> nums1]</code></pre><p>抄一个更好的代码块</p><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span>:</span>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">nextGreaterElement</span><span class="hljs-params">(self, nums1, nums2)</span>:</span>        stack, hash = [], &#123;&#125;        <span class="hljs-keyword">for</span> n <span class="hljs-keyword">in</span> nums2:            <span class="hljs-comment"># stack[-1]用来作栈顶判断，如果满足条件再pop，我命名为懒pop，这样也少了一堆无效pop和append，代码也容易看了</span>            <span class="hljs-keyword">while</span> stack <span class="hljs-keyword">and</span> stack[<span class="hljs-number">-1</span>] &lt; n:                hash[stack.pop()] = n            stack.append(n)                <span class="hljs-comment"># 这块比我写的简洁，顶我后4行</span>        <span class="hljs-keyword">return</span> [hash.get(x, <span class="hljs-number">-1</span>) <span class="hljs-keyword">for</span> x <span class="hljs-keyword">in</span> nums1]</code></pre>]]></content>
    
    
    <categories>
      
      <category>Leetcode</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Leetcode 560 - 和为K的子数组</title>
    <link href="/2020/05/15/leetcode-560/"/>
    <url>/2020/05/15/leetcode-560/</url>
    
    <content type="html"><![CDATA[<p>题目：</p><pre><code class="hljs quote">给定一个整数数组和一个整数 k，你需要找到该数组中和为 k 的连续的子数组的个数。</code></pre><p>先想到快慢指针问题。<br>如果快慢指针区间数和等于k，res+1。慢指针不动快指针动，如果大于k，慢指针动(如果满指针赶上快指针，一块动)，直到再次小于等于k，快指针继续。终结条件是快指针走到头且区间数和&lt;k，结束。</p><p>sums中可能有负数的，这个写法默认所有值为正整数，玩不转。这路子我只能想到O(n^2)全覆盖了，暴力</p><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span><span class="hljs-params">(object)</span>:</span>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">subarraySum</span><span class="hljs-params">(self, nums, k)</span>:</span>        <span class="hljs-string">"""</span><span class="hljs-string">        :type nums: List[int]</span><span class="hljs-string">        :type k: int</span><span class="hljs-string">        :rtype: int</span><span class="hljs-string">        """</span>        fast_pointer = <span class="hljs-number">0</span>        slow_pointer = <span class="hljs-number">0</span>        res = <span class="hljs-number">0</span>        <span class="hljs-keyword">while</span> fast_pointer &lt; len(nums):            current_sum = reduce(<span class="hljs-keyword">lambda</span> x, y: x+y, nums[slow_pointer:fast_pointer+<span class="hljs-number">1</span>])            <span class="hljs-keyword">print</span> str(current_sum) + <span class="hljs-string">"====="</span> + str(slow_pointer) + <span class="hljs-string">"====="</span> + str(fast_pointer)            <span class="hljs-keyword">if</span> current_sum == k:                res += <span class="hljs-number">1</span>                fast_pointer += <span class="hljs-number">1</span>            <span class="hljs-keyword">elif</span> current_sum &gt; k:                slow_pointer += <span class="hljs-number">1</span>                <span class="hljs-keyword">if</span> slow_pointer &gt; fast_pointer:                    fast_pointer += <span class="hljs-number">1</span>            <span class="hljs-keyword">elif</span> current_sum &lt; k:                fast_pointer += <span class="hljs-number">1</span>        <span class="hljs-keyword">return</span> res</code></pre><h2 id="暴力了，大力出奇迹。时间都溢出了"><a href="#暴力了，大力出奇迹。时间都溢出了" class="headerlink" title="暴力了，大力出奇迹。时间都溢出了"></a>暴力了，大力出奇迹。时间都溢出了</h2><p>中间结果会多次计算，独立子问题，动态规划？但是这题又不是求最值的。 问题也不独立啊<br>暴力解超时。还有sum多一维，O(n^3).其实这个也可以用前缀和降维一次，但是leetcode仍然超时，算了</p><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span><span class="hljs-params">(object)</span>:</span>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">subarraySum</span><span class="hljs-params">(self, nums, k)</span>:</span>        <span class="hljs-string">"""</span><span class="hljs-string">        :type nums: List[int]</span><span class="hljs-string">        :type k: int</span><span class="hljs-string">        :rtype: int</span><span class="hljs-string">        """</span>        res = <span class="hljs-number">0</span>        <span class="hljs-keyword">for</span> fast_pointer <span class="hljs-keyword">in</span> range(<span class="hljs-number">0</span>, len(nums), <span class="hljs-number">1</span>):            <span class="hljs-keyword">for</span> slow_pointer <span class="hljs-keyword">in</span> range(<span class="hljs-number">0</span>, fast_pointer + <span class="hljs-number">1</span>, <span class="hljs-number">1</span>):                <span class="hljs-keyword">if</span> sum(nums[slow_pointer:fast_pointer+<span class="hljs-number">1</span>]) == k:                    res += <span class="hljs-number">1</span>        <span class="hljs-keyword">return</span> res</code></pre><p>想不到，看提示了<br>sum(i,j)=sum(0,j)-sum(0,i) 和 dict<br>脑子不灵想不到这一层。隐约知道中间结果可以字典存存，但是想不出怎么用。照着这个思路来试写，改来改去没改对<br>错误解</p><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span><span class="hljs-params">(object)</span>:</span>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">subarraySum</span><span class="hljs-params">(self, nums, k)</span>:</span>        <span class="hljs-string">"""</span><span class="hljs-string">        :type nums: List[int]</span><span class="hljs-string">        :type k: int</span><span class="hljs-string">        :rtype: int</span><span class="hljs-string">        """</span>        res = <span class="hljs-number">0</span>        holder= &#123;&#125;        holder[<span class="hljs-number">-1</span>] = <span class="hljs-number">0</span>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(<span class="hljs-number">0</span>, len(nums), <span class="hljs-number">1</span>):            holder[i] = sum(nums[:i+<span class="hljs-number">1</span>])        <span class="hljs-keyword">print</span> holder        <span class="hljs-keyword">for</span> fast_pointer <span class="hljs-keyword">in</span> range(<span class="hljs-number">0</span>, len(nums), <span class="hljs-number">1</span>):            <span class="hljs-keyword">for</span> slow_pointer <span class="hljs-keyword">in</span> range(<span class="hljs-number">-1</span>, fast_pointer, <span class="hljs-number">1</span>):                <span class="hljs-keyword">print</span> str(slow_pointer) + <span class="hljs-string">"====="</span> + str(fast_pointer)                <span class="hljs-keyword">if</span> holder[fast_pointer]-holder[slow_pointer] == k:                    <span class="hljs-keyword">print</span> <span class="hljs-string">"record: "</span> + str(holder[fast_pointer]) + <span class="hljs-string">"====="</span> + str(holder[slow_pointer])                    res += <span class="hljs-number">1</span>        <span class="hljs-keyword">return</span> res</code></pre><p>只能答案了。答案看了一大顿也半懂不懂的。绕死了，不过当天打卡题，硬着头皮看懂了，大半天哎</p><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span>:</span>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">subarraySum</span><span class="hljs-params">(self, nums: List[int], k: int)</span> -&gt; int:</span>        pre = <span class="hljs-number">0</span>        count = <span class="hljs-number">0</span>        <span class="hljs-comment"># 以前缀和为key，以前缀和key出现的次数为value。比如[1,2,1,-1], 前缀和3的情况次数2，这样再往后的连续字串有两种取法，包括和不包括[1,-1]结果都一样，结果该+2</span>        <span class="hljs-comment"># 初始化的意义是，sum([:n])-k==0, 这样字串从头算到n正好是k的串，结果可以+1.当然后续迭代前缀和又等于0了，dic[0]也要自加1的</span>        dic = &#123;<span class="hljs-number">0</span>:<span class="hljs-number">1</span>&#125;        <span class="hljs-comment"># 每轮统计，以第一个元素开始该轮元素结尾的子串前缀和 - k = 一个值</span>        <span class="hljs-comment"># 这个值在之前轮次计算子串组合中，有几种组合方式，去字典中找。 找到总结果就该加几</span>        <span class="hljs-comment"># 当前轮次的前缀和在字典中的v值+1，如不存在就加个新k</span>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> nums:            <span class="hljs-comment"># 每轮只记录这一轮的前缀和</span>            pre += i            <span class="hljs-keyword">if</span> (pre-k) <span class="hljs-keyword">in</span> dic:                count += dic[pre-k]            dic[pre] = dic.get(pre,<span class="hljs-number">0</span>) + <span class="hljs-number">1</span>        <span class="hljs-keyword">return</span> count</code></pre><p>另外抄一个说明多一点的方便理解</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">subarraySum</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums, <span class="hljs-keyword">int</span> k)</span> </span>&#123;        <span class="hljs-comment">// hash</span>        <span class="hljs-comment">// 记录合适的连续字符串数量</span>        <span class="hljs-keyword">int</span> count=<span class="hljs-number">0</span>;        <span class="hljs-comment">// 记录前面数字相加之和</span>        <span class="hljs-keyword">int</span> pre=<span class="hljs-number">0</span>;        <span class="hljs-comment">// map记录前几个数字之和为K出现相同和的次数为V</span>        HashMap&lt;Integer,Integer&gt; map = <span class="hljs-keyword">new</span> HashMap&lt;&gt;();        <span class="hljs-comment">// 初始化</span>        map.put(<span class="hljs-number">0</span>,<span class="hljs-number">1</span>);        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; nums.length; i++) &#123;            pre+= nums[i];            <span class="hljs-comment">// 如果前面数字之和加上这个数字正好等于K（存在一个数字加上nums[i]结果为K</span>            <span class="hljs-comment">// 说明找到了</span>            <span class="hljs-keyword">if</span> (map.containsKey(pre-k))&#123;                <span class="hljs-comment">// 累计</span>                count+=map.get(pre-k);            &#125;            <span class="hljs-comment">// 计算新的和放入map</span>            map.put(pre,map.getOrDefault(pre,<span class="hljs-number">0</span>)+<span class="hljs-number">1</span>);        &#125;        <span class="hljs-keyword">return</span> count;    &#125;</code></pre><p>抄来一些别人的讲解：</p><pre><code class="hljs quote">前缀和：这个优化主要是用来在O（1）时间内求出一个序列a中,a[i]+a[i+1]+……+a[j]的和。核心就两个字：降维。面对许多高维问题，往往前缀和是最先想到的降维方法。 这样在降维的基础上，许多更进一步的优化才能实现。</code></pre>]]></content>
    
    
    <categories>
      
      <category>Leetcode</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Leetcode 136 - 只出现一次的数字</title>
    <link href="/2020/05/14/leetcode-136/"/>
    <url>/2020/05/14/leetcode-136/</url>
    
    <content type="html"><![CDATA[<p>题目：</p><pre><code class="hljs quote">给定一个非空整数数组，除了某个元素只出现一次以外，其余每个元素均出现两次。找出那个只出现了一次的元素。说明：你的算法应该具有线性时间复杂度。 你可以不使用额外空间来实现吗？</code></pre><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span><span class="hljs-params">(object)</span>:</span>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">singleNumber</span><span class="hljs-params">(self, nums)</span>:</span>        <span class="hljs-string">"""</span><span class="hljs-string">        :type nums: List[int]</span><span class="hljs-string">        :rtype: int</span><span class="hljs-string">        """</span>        <span class="hljs-comment"># sort函数不需要重新赋值了，否则nums会是None。复制空间的函数叫sorted，除了排序list之外还能排元组，字典，更灵活，但消耗内存</span>        <span class="hljs-comment"># nums = nums.sort()</span>        nums.sort()        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(<span class="hljs-number">0</span>, len(nums), <span class="hljs-number">2</span>):            <span class="hljs-keyword">if</span> i == len(nums) - <span class="hljs-number">1</span>:                <span class="hljs-keyword">return</span> nums[<span class="hljs-number">-1</span>]            <span class="hljs-keyword">elif</span> nums[i] != nums[i+<span class="hljs-number">1</span>]:                <span class="hljs-keyword">return</span> nums[i]</code></pre><p>官方答案用的位运算，异或所有列表中的值。异或满足交换律和结合律，相同的数异或后是0，0和单独的数异或是单独的数</p><pre><code class="hljs python3">class Solution:    def singleNumber(self, nums: List[int]) -&gt; int:        return reduce(lambda x, y: x ^ y, nums)</code></pre><p>^ 为异或运算；reduce函数使用如下引用。想想mapreduce是怎么玩的就了解了</p><pre><code class="hljs quote">reduce() 函数会对参数序列中元素进行累积。函数将一个数据集合（链表，元组等）中的所有数据进行下列操作：用传给 reduce 中的函数 function（有两个参数）先对集合中的第 1、2 个元素进行操作，得到的结果再与第三个数据用 function 函数运算，最后得到一个结果。</code></pre>]]></content>
    
    
    <categories>
      
      <category>Leetcode</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Leetcode 105 - 从前序与中序遍历序列构造二叉树</title>
    <link href="/2020/05/13/leetcode-105/"/>
    <url>/2020/05/13/leetcode-105/</url>
    
    <content type="html"><![CDATA[<p>题目：</p><pre><code class="hljs quote">根据一棵树的前序遍历与中序遍历构造二叉树。</code></pre><p>遍历树的逆运算。所谓前中后，就是（左节点，父节点，右节点）中，父节点在前中后位置处理<br>前序第一个值肯定是root<br>两种排序里，右节点的位置不会变。猜想应该从后往前构造树。从子节点开始构造，迭代更好一些的感觉<br>有想了想，如果树右下角没有右叶子，两list最后一位就不一样。所以从后往前推还不如从前往后推的感觉了</p><hr><p>想不到解法，抄了题解中的一步思路试试</p><pre><code class="hljs quote">首先，preorder 中的第一个元素一定是树的根，**这个根又将 inorder 序列分成了左右两棵子树。**现在我们只需要将先序遍历的数组中删除根元素，然后重复上面的过程处理左右两棵子树</code></pre><p>这说法，是将左右子树分治了, 利用preorder拆inorder，然后进入迭代解决子问题。试试</p><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span><span class="hljs-params">(object)</span>:</span>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">buildTree</span><span class="hljs-params">(self, preorder, inorder)</span>:</span>        <span class="hljs-string">"""</span><span class="hljs-string">        :type preorder: List[int]</span><span class="hljs-string">        :type inorder: List[int]</span><span class="hljs-string">        :rtype: TreeNode</span><span class="hljs-string">        """</span>                <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">buildSubTree</span><span class="hljs-params">(preorder, inorder)</span>:</span>            <span class="hljs-comment"># 已经没得计算了</span>            <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> preorder:                <span class="hljs-keyword">return</span>            node = TreeNode(preorder[<span class="hljs-number">0</span>], <span class="hljs-literal">None</span>, <span class="hljs-literal">None</span>)            <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(<span class="hljs-number">0</span>, len(inorder), <span class="hljs-number">1</span>):                <span class="hljs-keyword">if</span> inorder[i] == preorder[<span class="hljs-number">0</span>]:                    <span class="hljs-comment"># 拆分preorder和inorder。中括号里是取数组区段的开闭区间。控制一下i溢出的情况</span>                    left_preorder, right_preorder = preorder[<span class="hljs-number">1</span>:i+<span class="hljs-number">1</span>], preorder[i+<span class="hljs-number">1</span>:] <span class="hljs-keyword">if</span> i &lt; len(preorder)<span class="hljs-number">-1</span> <span class="hljs-keyword">else</span> []                    left_inorder, right_inorder = inorder[:i], inorder[i+<span class="hljs-number">1</span>:] <span class="hljs-keyword">if</span> i &lt; len(inorder)<span class="hljs-number">-1</span> <span class="hljs-keyword">else</span> []                    <span class="hljs-keyword">break</span>            node.left = buildSubTree(left_preorder, left_inorder)            node.right = buildSubTree(right_preorder, right_inorder)            <span class="hljs-keyword">return</span> node        <span class="hljs-keyword">return</span> buildSubTree(preorder, inorder)</code></pre><p>迭代里边带循环，效率在后10%。开始抄(精选答案)作业，这个和我思路一致</p><ol><li>list.index可以返回位置，省了一个循环处理</li><li>[:]形式截取字符串不用担心溢出，超出了只会返回空，已自己测试过</li></ol><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span><span class="hljs-params">(object)</span>:</span>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">buildTree</span><span class="hljs-params">(self, preorder, inorder)</span>:</span>        <span class="hljs-string">"""</span><span class="hljs-string">        :type preorder: List[int]</span><span class="hljs-string">        :type inorder: List[int]</span><span class="hljs-string">        :rtype: TreeNode</span><span class="hljs-string">        """</span>        <span class="hljs-keyword">if</span> len(inorder) == <span class="hljs-number">0</span>:            <span class="hljs-keyword">return</span> <span class="hljs-literal">None</span>        <span class="hljs-comment"># 前序遍历第一个值为根节点</span>        root = TreeNode(preorder[<span class="hljs-number">0</span>])        <span class="hljs-comment"># 因为没有重复元素，所以可以直接根据值来查找根节点在中序遍历中的位置</span>        mid = inorder.index(preorder[<span class="hljs-number">0</span>])        <span class="hljs-comment"># 构建左子树</span>        root.left = self.buildTree(preorder[<span class="hljs-number">1</span>:mid+<span class="hljs-number">1</span>], inorder[:mid])        <span class="hljs-comment"># 构建右子树</span>        root.right = self.buildTree(preorder[mid+<span class="hljs-number">1</span>:], inorder[mid+<span class="hljs-number">1</span>:])                <span class="hljs-keyword">return</span> root</code></pre><p>官方还有O(n)时间复杂度的答案，留待以后看吧</p>]]></content>
    
    
    <categories>
      
      <category>Leetcode</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Leetcode 124 - 二叉树中的最大路径和</title>
    <link href="/2020/05/13/leetcode-124/"/>
    <url>/2020/05/13/leetcode-124/</url>
    
    <content type="html"><![CDATA[<p>题目：</p><pre><code class="hljs quote">给定一个非空二叉树，返回其最大路径和。本题中，路径被定义为一条从树中任意节点出发，达到任意节点的序列。该路径至少包含一个节点，且不一定经过根节点。</code></pre><p>尝试后序遍历(失败)</p><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span><span class="hljs-params">(object)</span>:</span>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">maxPathSum</span><span class="hljs-params">(self, root)</span>:</span>        <span class="hljs-string">"""</span><span class="hljs-string">        :type root: TreeNode</span><span class="hljs-string">        :rtype: int</span><span class="hljs-string">        """</span>                <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> root: <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>        <span class="hljs-comment"># 不能给空叶子节点赋0，否则当前节点值为负数的话max就算错了</span>        max_sum_left = self.maxPathSum(root.left) <span class="hljs-keyword">if</span> root.left <span class="hljs-keyword">else</span> <span class="hljs-number">0</span>        max_sum_right = self.maxPathSum(root.right) <span class="hljs-keyword">if</span> root.right <span class="hljs-keyword">else</span> <span class="hljs-number">0</span>        <span class="hljs-keyword">return</span> max(            max_sum_left+root.val+max_sum_right,            max_sum_left+root.val,            root.val+max_sum_right,            <span class="hljs-comment"># 尝试改了这个又通不过别的测试用例，而且这逻辑给我搞的乱糟糟</span>            max_sum_left <span class="hljs-keyword">if</span> root.left <span class="hljs-keyword">else</span> root.val,            max_sum_right <span class="hljs-keyword">if</span> root.right <span class="hljs-keyword">else</span> root.val,            <span class="hljs-comment"># 忘了只有当前节点自己的情况了</span>            root.val            )</code></pre><p>看了正确答案，思考总结如下<br>当前节点路径最大值和递归返回的值不是一个值，因为子树的二叉树分歧递归上去也只能取一路的值给外层循环用<br>2. float(“-inf”)无穷小 float(“inf”)无穷大<br>3. 正确答案里的nonlocal是python 3.2引入的，我这没法用，还是要在方法内部创建方法，而且就像之前总结的，直接用类方法容易导致root名称被滥用错乱。直接外边定义一个变量会导致无法在递归内部访问到变量。 兼容用个dict或list存一下<br>4. 递归返回如果是负的可以取0，这相当与结果舍弃了这一侧的子树。因为负的情况无论怎么加进去都会导致结果总值变小</p><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span><span class="hljs-params">(object)</span>:</span>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">maxPathSum</span><span class="hljs-params">(self, root)</span>:</span>        <span class="hljs-string">"""</span><span class="hljs-string">        :type root: TreeNode</span><span class="hljs-string">        :rtype: int</span><span class="hljs-string">        """</span>        res = &#123;<span class="hljs-string">'res'</span>: float(<span class="hljs-string">'-inf'</span>)&#125;        <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">max_gain</span><span class="hljs-params">(node)</span>:</span>            <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> node:                <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>            max_gain_left = max(max_gain(node.left), <span class="hljs-number">0</span>)            max_gain_right = max(max_gain(node.right), <span class="hljs-number">0</span>)                        <span class="hljs-comment"># 此时以node节点为根的子树能生成的最大路径和, 尝试更新结果</span>            res[<span class="hljs-string">"res"</span>] = max(res[<span class="hljs-string">"res"</span>], max_gain_left + node.val + max_gain_right)            <span class="hljs-comment"># 递归返回当前node不作为结果集根的情况下，能提供的最大路径和贡献。 node.val必须加进来，否则无法联系树上层</span>            <span class="hljs-keyword">return</span> max(max_gain_left, max_gain_right) + node.val        max_gain(root)        <span class="hljs-keyword">return</span> res[<span class="hljs-string">"res"</span>]</code></pre>]]></content>
    
    
    <categories>
      
      <category>Leetcode</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Leetcode 102 - 二叉树的层序遍历</title>
    <link href="/2020/05/13/leetcode-102/"/>
    <url>/2020/05/13/leetcode-102/</url>
    
    <content type="html"><![CDATA[<p>题目：</p><pre><code class="hljs quote">给你一个二叉树，请你返回其按 层序遍历 得到的节点值。 （即逐层地，从左到右访问所有节点）。</code></pre><p>这道题是受层序遍历找二叉树最大深度的启发简单改改而成。真的背点题越做越顺啊</p><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span><span class="hljs-params">(object)</span>:</span>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">levelOrder</span><span class="hljs-params">(self, root)</span>:</span>        <span class="hljs-string">"""</span><span class="hljs-string">        :type root: TreeNode</span><span class="hljs-string">        :rtype: List[List[int]]</span><span class="hljs-string">        """</span>        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> root: <span class="hljs-keyword">return</span> []        nodes, res = [root], []        <span class="hljs-keyword">while</span> nodes:            res_element = []            next_level_nodes = []            <span class="hljs-keyword">for</span> node <span class="hljs-keyword">in</span> nodes:                res_element.append(node.val)                <span class="hljs-keyword">if</span> node.left:                    next_level_nodes.append(node.left)                <span class="hljs-keyword">if</span> node.right:                    next_level_nodes.append(node.right)            nodes = next_level_nodes            res.append(res_element)        <span class="hljs-keyword">return</span> res</code></pre>]]></content>
    
    
    <categories>
      
      <category>Leetcode</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Leetcode 55 - I. 二叉树的深度</title>
    <link href="/2020/05/12/leetcode-55/"/>
    <url>/2020/05/12/leetcode-55/</url>
    
    <content type="html"><![CDATA[<p>这递归解法仿照了另个做不出来的题的答案：返回所有到根节点路线的list<br>共同点是都要对整个树遍历才能判断最值</p><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span><span class="hljs-params">(object)</span>:</span>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">maxDepth</span><span class="hljs-params">(self, root)</span>:</span>        <span class="hljs-string">"""</span><span class="hljs-string">        :type root: TreeNode</span><span class="hljs-string">        :rtype: int</span><span class="hljs-string">        """</span>        depths = []                <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">searchTree</span><span class="hljs-params">(root, depth)</span>:</span>            depth += <span class="hljs-number">1</span>            <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> root.left <span class="hljs-keyword">and</span> <span class="hljs-keyword">not</span> root.right:                depths.append(depth)                <span class="hljs-keyword">return</span>            <span class="hljs-keyword">if</span> root.left:                searchTree(root.left, depth)            <span class="hljs-keyword">if</span> root.right:                searchTree(root.right, depth)        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> root:            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>        searchTree(root, <span class="hljs-number">0</span>)        <span class="hljs-keyword">return</span> max(depths)</code></pre><p>尝试迭代, 也是抄记忆中之前题的逻辑</p><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span><span class="hljs-params">(object)</span>:</span>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">maxDepth</span><span class="hljs-params">(self, root)</span>:</span>        <span class="hljs-string">"""</span><span class="hljs-string">        :type root: TreeNode</span><span class="hljs-string">        :rtype: int</span><span class="hljs-string">        """</span>        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> root:            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>        max_depth = <span class="hljs-number">0</span>        stack = [(root, <span class="hljs-number">0</span>)]        <span class="hljs-keyword">while</span> stack:            (node, depth) = stack.pop()            depth += <span class="hljs-number">1</span>            <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> node.left <span class="hljs-keyword">and</span> <span class="hljs-keyword">not</span> node.right:                max_depth = max(max_depth, depth)                <span class="hljs-comment"># 这个检查了好一会儿，迭代不能return啊！！！</span>                <span class="hljs-comment"># return</span>                <span class="hljs-keyword">continue</span>            <span class="hljs-comment"># 这个地方又检查好久。 从上边递归方法中抄过来的，所以这样容易疏漏的地方还是写成中性化的形式好</span>            <span class="hljs-comment"># if root.left:</span>            <span class="hljs-keyword">if</span> node.left:                stack.append((node.left, depth))            <span class="hljs-keyword">if</span> node.right:                stack.append((node.right, depth))        <span class="hljs-keyword">return</span> max_depth</code></pre><p>题解看了看，原来有想多了。迭代就是上层为下层左右子树大的那个+1。 后序遍历，完全不需要保存所有分支的深度</p><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span>:</span>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">maxDepth</span><span class="hljs-params">(self, root: TreeNode)</span> -&gt; int:</span>        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> root: <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>        <span class="hljs-keyword">return</span> max(self.maxDepth(root.left), self.maxDepth(root.right)) + <span class="hljs-number">1</span></code></pre><p>层序遍历也难不哪去，就看能不能想到意识到</p><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span>:</span>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">maxDepth</span><span class="hljs-params">(self, root: TreeNode)</span> -&gt; int:</span>        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> root: <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>        queue, res = [root], <span class="hljs-number">0</span>        <span class="hljs-keyword">while</span> queue:            tmp = []            <span class="hljs-keyword">for</span> node <span class="hljs-keyword">in</span> queue:                <span class="hljs-keyword">if</span> node.left: tmp.append(node.left)                <span class="hljs-keyword">if</span> node.right: tmp.append(node.right)            queue = tmp            res += <span class="hljs-number">1</span>        <span class="hljs-keyword">return</span> res</code></pre>]]></content>
    
    
    <categories>
      
      <category>Leetcode</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Leetcode 226 -</title>
    <link href="/2020/05/12/leetcode-226/"/>
    <url>/2020/05/12/leetcode-226/</url>
    
    <content type="html"><![CDATA[<p>题目：</p><pre><code class="hljs quote">翻转一棵二叉树。</code></pre><p>自己的递归解法，也有很多可优化的点</p><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span><span class="hljs-params">(object)</span>:</span>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">invertTree</span><span class="hljs-params">(self, root)</span>:</span>        <span class="hljs-string">"""</span><span class="hljs-string">        :type root: TreeNode</span><span class="hljs-string">        :rtype: TreeNode</span><span class="hljs-string">        """</span>        <span class="hljs-comment"># Python要把方法引用放到方法定义后边</span>        <span class="hljs-keyword">return</span> helper(root)    <span class="hljs-comment"># 不需要helper，递归直接调用self.invertTree方法</span>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">helper</span><span class="hljs-params">(root)</span>:</span>        <span class="hljs-comment"># 终结条件忘了</span>        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> root:            <span class="hljs-keyword">return</span> <span class="hljs-literal">None</span>        holder = root.right        root.right = root.left        root.left = holder        <span class="hljs-comment"># 终结条件在内层，这里不用if的</span>        <span class="hljs-keyword">if</span> root.left:            helper(root.left)        <span class="hljs-keyword">if</span> root.right:            helper(root.right)        <span class="hljs-keyword">return</span> root</code></pre><p>想写一个迭代的版本，没思路（愁死了），看一下答案，所谓树的迭代就是用个节点栈取代递归</p><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span><span class="hljs-params">(object)</span>:</span>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">invertTree</span><span class="hljs-params">(self, root)</span>:</span>        <span class="hljs-string">"""</span><span class="hljs-string">        :type root: TreeNode</span><span class="hljs-string">        :rtype: TreeNode</span><span class="hljs-string">        """</span>        <span class="hljs-comment">#递归, 要返回None直接return就完了</span>        <span class="hljs-comment"># if not root:</span>        <span class="hljs-comment">#     return </span>        <span class="hljs-comment"># 这种交换连中间值也不需要</span>        <span class="hljs-comment"># root.left, root.right = root.right, root.left</span>        <span class="hljs-comment"># self.invertTree(root.left)</span>        <span class="hljs-comment"># self.invertTree(root.right)</span>        <span class="hljs-comment"># return root</span>        <span class="hljs-comment">#迭代</span>        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> root:            <span class="hljs-keyword">return</span>                stack = [root]        <span class="hljs-keyword">while</span> stack:            node = stack.pop()            <span class="hljs-keyword">if</span> node.left:                stack.append(node.left)            <span class="hljs-keyword">if</span> node.right:                stack.append(node.right)            node.left, node.right = node.right, node.left                <span class="hljs-keyword">return</span> root</code></pre><p>“面试题27. 二叉树的镜像” 和这个是一个题，这次自己写的轻松。 这题前中后序遍历完全一样</p>]]></content>
    
    
    <categories>
      
      <category>Leetcode</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Leetcode 155 - 最小栈</title>
    <link href="/2020/05/12/leetcode-155/"/>
    <url>/2020/05/12/leetcode-155/</url>
    
    <content type="html"><![CDATA[<p>题目：</p><pre><code class="hljs quote">设计一个支持 push ，pop ，top 操作，并能在常数时间内检索到最小元素的栈。push(x) —— 将元素 x 推入栈中。pop() —— 删除栈顶的元素。top() —— 获取栈顶元素。getMin() —— 检索栈中的最小元素。</code></pre><p>这道题的官方解法是用两个栈来实现这个栈，这有微妙</p><p>我自己实现用的链表，其实拿普通列表实现可以的，把节点放在最后一位的位置，记住当前坐标。用另一个列表存当前最小值，一块压栈出栈形式上也更容易些<br>另一点，通过这题训练下python class里self参数怎么用</p><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MinStack</span><span class="hljs-params">(object)</span>:</span>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span><span class="hljs-params">(self)</span>:</span>        <span class="hljs-string">"""</span><span class="hljs-string">        initialize your data structure here.</span><span class="hljs-string">        """</span>        <span class="hljs-comment"># node[0] 当前值value，默认None；node[1] 当前最小值min_value，默认None；node[2] 上一结点指针，默认None；node[3] 下一结点指针，默认None</span>        <span class="hljs-comment"># value = None</span>        <span class="hljs-comment"># min_value = None</span>        <span class="hljs-comment"># prior_node = None</span>        <span class="hljs-comment"># next_node = None</span>        <span class="hljs-comment"># node = [value, min_value, prior_node, next_node]</span>        self.top_node = <span class="hljs-literal">None</span>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">push</span><span class="hljs-params">(self, x)</span>:</span>        <span class="hljs-string">"""</span><span class="hljs-string">        :type x: int</span><span class="hljs-string">        :rtype: None</span><span class="hljs-string">        """</span>        <span class="hljs-keyword">if</span> self.top_node:            <span class="hljs-comment"># 当前存在节点</span>            new_node = [x, min(self.top_node[<span class="hljs-number">1</span>], x), self.top_node, <span class="hljs-literal">None</span>]            self.top_node[<span class="hljs-number">3</span>] = new_node            self.top_node = new_node        <span class="hljs-keyword">else</span>:            <span class="hljs-comment"># 第一个节点</span>            <span class="hljs-comment"># 这个地方查了20分钟的bug，错误写法：new_node = [x, x, None, None]</span>            self.top_node = [x, x, <span class="hljs-literal">None</span>, <span class="hljs-literal">None</span>]    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">pop</span><span class="hljs-params">(self)</span>:</span>        <span class="hljs-string">"""</span><span class="hljs-string">        :rtype: None</span><span class="hljs-string">        """</span>        <span class="hljs-keyword">if</span> self.top_node:            <span class="hljs-keyword">if</span> self.top_node[<span class="hljs-number">2</span>]:                <span class="hljs-comment"># 有节点且有前驱节点</span>                self.top_node = self.top_node[<span class="hljs-number">2</span>]                self.top_node[<span class="hljs-number">3</span>] = <span class="hljs-literal">None</span>            <span class="hljs-keyword">else</span>:                self.top_node = <span class="hljs-literal">None</span>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">top</span><span class="hljs-params">(self)</span>:</span>        <span class="hljs-string">"""</span><span class="hljs-string">        :rtype: int</span><span class="hljs-string">        """</span>        <span class="hljs-keyword">if</span> self.top_node:            <span class="hljs-keyword">return</span> self.top_node[<span class="hljs-number">0</span>]        <span class="hljs-keyword">else</span>:            <span class="hljs-keyword">return</span> <span class="hljs-literal">None</span>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">getMin</span><span class="hljs-params">(self)</span>:</span>        <span class="hljs-string">"""</span><span class="hljs-string">        :rtype: int</span><span class="hljs-string">        """</span>        <span class="hljs-keyword">if</span> self.top_node:            <span class="hljs-keyword">return</span> self.top_node[<span class="hljs-number">1</span>]        <span class="hljs-keyword">else</span>:            <span class="hljs-keyword">return</span> <span class="hljs-literal">None</span><span class="hljs-comment"># Your MinStack object will be instantiated and called as such:</span><span class="hljs-comment"># obj = MinStack()</span><span class="hljs-comment"># obj.push(x)</span><span class="hljs-comment"># obj.pop()</span><span class="hljs-comment"># param_3 = obj.top()</span><span class="hljs-comment"># param_4 = obj.getMin()</span></code></pre>]]></content>
    
    
    <categories>
      
      <category>Leetcode</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Leetcode 50 - Pow(x, n)</title>
    <link href="/2020/05/11/leetcode-50/"/>
    <url>/2020/05/11/leetcode-50/</url>
    
    <content type="html"><![CDATA[<p>题目：</p><pre><code class="hljs quote">实现 pow(x, n) ，即计算 x 的 n 次幂函数。</code></pre><p>前边都是错误解法，想破头。后边才是正确的</p><p>###错误解法1</p><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span><span class="hljs-params">(object)</span>:</span>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">myPow</span><span class="hljs-params">(self, x, n)</span>:</span>        <span class="hljs-string">"""</span><span class="hljs-string">        :type x: float</span><span class="hljs-string">        :type n: int</span><span class="hljs-string">        :rtype: float</span><span class="hljs-string">        """</span>        <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">helper</span><span class="hljs-params">(x, n)</span>:</span>            <span class="hljs-keyword">if</span> n == <span class="hljs-number">0</span>:                <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>            <span class="hljs-keyword">elif</span> n &gt; <span class="hljs-number">0</span>:                <span class="hljs-keyword">return</span> helper(x, n/<span class="hljs-number">2</span>)*helper(x, (n-n/<span class="hljs-number">2</span>))            <span class="hljs-keyword">elif</span> n &lt; <span class="hljs-number">0</span>:                <span class="hljs-keyword">return</span> helper(x, n/<span class="hljs-number">2</span>)/helper(x, (n-n/<span class="hljs-number">2</span>))        <span class="hljs-keyword">return</span> helper(x, n)</code></pre><p>首先想到动态规划，myPow(x, n)=myPow(x, n-m)*myPow(x, m)，状态转换<br>myPow(x, 0) = 1, 这个base case，不论正负值都往这个方向走<br>用迭代试试，分成&gt;0, &lt;0两部分<br>以为写的还行呢，其实是终结条件没判断好，n=1的时候，两个相乘的helper会总有一个以helper(x, 1)深入进去，达到迭代最大值</p><p>###错误解法2</p><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span><span class="hljs-params">(object)</span>:</span>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">myPow</span><span class="hljs-params">(self, x, n)</span>:</span>        <span class="hljs-string">"""</span><span class="hljs-string">        :type x: float</span><span class="hljs-string">        :type n: int</span><span class="hljs-string">        :rtype: float</span><span class="hljs-string">        """</span>            <span class="hljs-comment"># 真正的思路是将奇偶两种情况分开处理，偶数就一直除以2，奇数是先减1再一直除以2</span>            <span class="hljs-keyword">if</span> n == <span class="hljs-number">0</span>:                <span class="hljs-keyword">return</span> <span class="hljs-number">1.0</span>            <span class="hljs-keyword">elif</span> n &gt; <span class="hljs-number">0</span>:                <span class="hljs-keyword">if</span> n%<span class="hljs-number">2</span> == <span class="hljs-number">0</span>:                    <span class="hljs-keyword">return</span> helper(x, n/<span class="hljs-number">2</span>)**<span class="hljs-number">2</span>                <span class="hljs-keyword">elif</span> n%<span class="hljs-number">2</span> == <span class="hljs-number">1</span>:                    <span class="hljs-keyword">return</span> helper(x, n/<span class="hljs-number">2</span>)**<span class="hljs-number">2</span>*x**<span class="hljs-number">1</span>            <span class="hljs-keyword">elif</span> n &lt; <span class="hljs-number">0</span>:                <span class="hljs-keyword">if</span> n%<span class="hljs-number">2</span> == <span class="hljs-number">0</span>:                    <span class="hljs-keyword">print</span> n                    <span class="hljs-keyword">return</span> helper(x, abs(n)/<span class="hljs-number">2</span>)**<span class="hljs-number">-2</span>                <span class="hljs-keyword">elif</span> n%<span class="hljs-number">2</span> == <span class="hljs-number">-1</span>:                    <span class="hljs-keyword">return</span> helper(x, abs(n)/<span class="hljs-number">2</span>)**<span class="hljs-number">-2</span>*x**<span class="hljs-number">-1</span>        <span class="hljs-keyword">return</span> helper(x, n)</code></pre><p>34.00512<br>-3<br>很多测试用例过得去，但是这个过不去报错，搞不懂，估计是负数情况下除的时候是算上0来保留整数的。写的很繁琐，还错</p><pre><code class="hljs code">TypeError: None is not valid value for the expected return type double    raise TypeError(str(ret) + &quot; is not valid value for the expected return type double&quot;);Line 67 in _driver (Solution.py)    _driver()Line 73 in &lt;module&gt; (Solution.py)</code></pre><p>###以下正确答案</p><p>参考了别人答案才会了，可以变形：x的n次方=(1/x)的-n次方，用这个把负数n变正数。另外本不需要helper方法</p><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span><span class="hljs-params">(object)</span>:</span>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">myPow</span><span class="hljs-params">(self, x, n)</span>:</span>        <span class="hljs-string">"""</span><span class="hljs-string">        :type x: float</span><span class="hljs-string">        :type n: int</span><span class="hljs-string">        :rtype: float</span><span class="hljs-string">        """</span>        <span class="hljs-keyword">if</span> n == <span class="hljs-number">0</span>:            <span class="hljs-keyword">return</span> <span class="hljs-number">1.0</span>        <span class="hljs-keyword">if</span> n &lt; <span class="hljs-number">0</span>:            x = <span class="hljs-number">1</span>/x            n = -n        <span class="hljs-keyword">if</span> n%<span class="hljs-number">2</span> == <span class="hljs-number">0</span>:            <span class="hljs-keyword">return</span> self.myPow(x, n/<span class="hljs-number">2</span>)**<span class="hljs-number">2</span>        <span class="hljs-keyword">elif</span> n%<span class="hljs-number">2</span> == <span class="hljs-number">1</span>:            <span class="hljs-keyword">return</span> self.myPow(x, n/<span class="hljs-number">2</span>)**<span class="hljs-number">2</span>*x</code></pre><p>这块还可以优化，进入子迭代前平方，而不要返回时平方，更易读，效率上差不多</p><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span><span class="hljs-params">(object)</span>:</span>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">myPow</span><span class="hljs-params">(self, x, n)</span>:</span>        <span class="hljs-string">"""</span><span class="hljs-string">        :type x: float</span><span class="hljs-string">        :type n: int</span><span class="hljs-string">        :rtype: float</span><span class="hljs-string">        """</span>        <span class="hljs-keyword">if</span> n == <span class="hljs-number">0</span>:            <span class="hljs-keyword">return</span> <span class="hljs-number">1.0</span>        <span class="hljs-keyword">if</span> n &lt; <span class="hljs-number">0</span>:            x = <span class="hljs-number">1</span>/x            n = -n        <span class="hljs-keyword">if</span> n%<span class="hljs-number">2</span> == <span class="hljs-number">0</span>:            <span class="hljs-keyword">return</span> self.myPow(x**<span class="hljs-number">2</span>, n/<span class="hljs-number">2</span>)        <span class="hljs-keyword">elif</span> n%<span class="hljs-number">2</span> == <span class="hljs-number">1</span>:            <span class="hljs-keyword">return</span> self.myPow(x**<span class="hljs-number">2</span>, n/<span class="hljs-number">2</span>)*x</code></pre>]]></content>
    
    
    <categories>
      
      <category>Leetcode</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Leetcode 1287 - 有序数组中出现次数超过25%的元素</title>
    <link href="/2020/05/09/leetcode-1287/"/>
    <url>/2020/05/09/leetcode-1287/</url>
    
    <content type="html"><![CDATA[<p>题目：</p><pre><code class="hljs quote">给你一个非递减的有序整数数组，已知这个数组中恰好有一个整数，它的出现次数超过数组元素总数的 25%。请你找到并返回这个整数</code></pre><p>这道题是解的最顺的，自己的解法如下：</p><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span><span class="hljs-params">(object)</span>:</span>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">findSpecialInteger</span><span class="hljs-params">(self, arr)</span>:</span>        <span class="hljs-string">"""</span><span class="hljs-string">        :type arr: List[int]</span><span class="hljs-string">        :rtype: int</span><span class="hljs-string">        """</span>        map = &#123;key:<span class="hljs-number">0</span> <span class="hljs-keyword">for</span> key <span class="hljs-keyword">in</span> set(arr)&#125;        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(len(arr)):            map[arr[i]] += <span class="hljs-number">1</span>        <span class="hljs-keyword">for</span> k,v <span class="hljs-keyword">in</span> map.items():            <span class="hljs-keyword">if</span> <span class="hljs-number">4</span>*v &gt; len(arr):                <span class="hljs-keyword">return</span> k</code></pre><p>这里边的第二个for循环其实可以不要, 只要在第一个for循环里，每步判断下是否已超过25%就行</p><p><strong>重点</strong>在这里。超过25%，就感觉应该用二分查找，但是没什么直接思路<br><a href="https://leetcode-cn.com/problems/element-appearing-more-than-25-in-sorted-array/solution/" target="_blank" rel="noopener">Leetcode网站</a>提供了解法</p><ol><li>反证法证明解一定出现在开始、1/4，1/2，3/4的指针位置</li><li>python里用了bisect.bisect_left这种方法去寻找指针位置值在左右的范围</li><li>range(x, y, z) 是在[x,y)左开右闭区间内以z步长迭代</li></ol><p>时间复杂度从O(N)降到O(LogN)了<br>回头自己实现一下</p>]]></content>
    
    
    <categories>
      
      <category>Leetcode</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Leetcode 69 - x的平方根</title>
    <link href="/2020/05/09/leetcode-69/"/>
    <url>/2020/05/09/leetcode-69/</url>
    
    <content type="html"><![CDATA[<p>题目：</p><pre><code class="hljs quote">实现 int sqrt(int x) 函数。计算并返回 x 的平方根，其中 x 是非负整数。由于返回类型是整数，结果只保留整数的部分，小数部分将被舍去。来源：力扣（LeetCode）链接：https:&#x2F;&#x2F;leetcode-cn.com&#x2F;problems&#x2F;sqrtx著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</code></pre><p>写了3种方法</p><ol><li><p>单步加1速度太慢, 写的时候根本没想效率的事</p><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span><span class="hljs-params">(object)</span>:</span>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">mySqrt</span><span class="hljs-params">(self, x)</span>:</span>        <span class="hljs-string">"""</span><span class="hljs-string">        :type x: int</span><span class="hljs-string">        :rtype: int</span><span class="hljs-string">        """</span>        y = <span class="hljs-number">0</span>        <span class="hljs-keyword">while</span> y*y &lt;= x:            y+=<span class="hljs-number">1</span>        <span class="hljs-keyword">return</span> y<span class="hljs-number">-1</span></code></pre></li><li><p>二分查找, 自己想了一大顿关联到了，写的过于繁琐，设置四种判断条件人为变得困难</p><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span><span class="hljs-params">(object)</span>:</span>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">mySqrt</span><span class="hljs-params">(self, x)</span>:</span>        <span class="hljs-string">"""</span><span class="hljs-string">        :type x: int</span><span class="hljs-string">        :rtype: int</span><span class="hljs-string">        """</span>        <span class="hljs-comment"># 临界条件设置的好傻</span>        <span class="hljs-keyword">if</span> x == <span class="hljs-number">0</span>:            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>        <span class="hljs-keyword">if</span> x == <span class="hljs-number">1</span>:            <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>            left, right = <span class="hljs-number">0</span>, x         <span class="hljs-keyword">while</span> left &lt;= right:            <span class="hljs-comment"># 取整应该用//</span>            mid = left + (right - left)/<span class="hljs-number">2</span>            <span class="hljs-comment"># 指数是**，不是^（按二进制位异或运算）</span>            <span class="hljs-keyword">if</span> mid**<span class="hljs-number">2</span> &lt;= x <span class="hljs-keyword">and</span> (mid+<span class="hljs-number">1</span>)**<span class="hljs-number">2</span> &gt; x:                <span class="hljs-keyword">return</span> mid            <span class="hljs-keyword">elif</span> mid**<span class="hljs-number">2</span> &lt;= x <span class="hljs-keyword">and</span> (mid+<span class="hljs-number">1</span>)**<span class="hljs-number">2</span> &lt;= x:                left = mid            <span class="hljs-keyword">elif</span> mid**<span class="hljs-number">2</span> &gt; x <span class="hljs-keyword">and</span> (mid<span class="hljs-number">-1</span>)**<span class="hljs-number">2</span> &lt;= x:                <span class="hljs-comment"># 返还忘了减1</span>                <span class="hljs-keyword">return</span> mid<span class="hljs-number">-1</span>            <span class="hljs-keyword">elif</span> mid**<span class="hljs-number">2</span> &gt; x <span class="hljs-keyword">and</span> (mid<span class="hljs-number">-1</span>)**<span class="hljs-number">2</span> &gt; x:                right = mid</code></pre></li><li><p>简单版二分查找，正确答案默写</p><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span><span class="hljs-params">(object)</span>:</span>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">mySqrt</span><span class="hljs-params">(self, x)</span>:</span>        <span class="hljs-string">"""</span><span class="hljs-string">        :type x: int</span><span class="hljs-string">        :rtype: int</span><span class="hljs-string">        """</span>        l, r, res = <span class="hljs-number">0</span>, x, <span class="hljs-number">-1</span>        <span class="hljs-keyword">while</span> l &lt;= r:            mid = l + (r - l)/<span class="hljs-number">2</span>            <span class="hljs-keyword">if</span> mid**<span class="hljs-number">2</span> &lt;= x:                res = mid                l = mid + <span class="hljs-number">1</span>            <span class="hljs-keyword">elif</span> mid**<span class="hljs-number">2</span> &gt; x:                r = mid - <span class="hljs-number">1</span>        <span class="hljs-comment"># 保存唯一正确位置到最后返回就行</span>        <span class="hljs-keyword">return</span> res</code></pre></li></ol>]]></content>
    
    
    <categories>
      
      <category>Leetcode</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Hexo部署</title>
    <link href="/2020/05/09/Hexo-Manual/"/>
    <url>/2020/05/09/Hexo-Manual/</url>
    
    <content type="html"><![CDATA[<p>重新安装Hexo，已经时隔三年。虽然很多事情缠身，不过简单探索的快乐还在。Github Page还能使用，但是Hexo本身已经完全不同了。代码库被我完全的重写掉，使用的<a href="https://github.com/theme-next/hexo-theme-next" target="_blank" rel="noopener">Next主题</a></p><p>通过配置文件向github page库推送需要安装</p><pre><code class="hljs bash">$ npm install hexo-deployer-git --save</code></pre><p>明天再熟悉下Markdown语法，写我自己的好东西</p><h3 id="三天后"><a href="#三天后" class="headerlink" title="三天后"></a>三天后</h3><p>在windows上配置hexo, 才发现github上只有打包好的静态网站，配置、主题、写的文字全没上传。官网说法，想想也对，回头抄一抄别人的hexo文件管理方式。<a href="https://hexo.io/zh-cn/docs/one-command-deployment" target="_blank" rel="noopener">“由于 Hexo 的部署默认使用分支 master，所以如果你同时正在使用 Git 管理你的站点目录，你应当注意你的部署分支应当不同于写作分支。<br>一个好的实践是将站点目录和 Pages 分别存放在两个不同的 Git 仓库中，可以有效避免相互覆盖。<br>Hexo 在部署你的站点生成的文件时并不会更新你的站点目录。因此你应该手动提交并推送你的写作分支。”</a></p><p>Next分支坏了，显示Null。直接换成了<a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="noopener">Fluid高级主题</a></p>]]></content>
    
    
    <categories>
      
      <category>Tools</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Hello World</title>
    <link href="/2020/05/09/hello-world/"/>
    <url>/2020/05/09/hello-world/</url>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><pre><code class="hljs bash">$ hexo new <span class="hljs-string">"My New Post"</span></code></pre><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><pre><code class="hljs bash">$ hexo server</code></pre><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><pre><code class="hljs bash">$ hexo generate</code></pre><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><pre><code class="hljs bash">$ hexo deploy</code></pre><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html" target="_blank" rel="noopener">Deployment</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  
</search>
