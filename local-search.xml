<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>Leetcode 55 - I. 二叉树的深度(未完待续)</title>
    <link href="/2020/05/12/leetcode-55/"/>
    <url>/2020/05/12/leetcode-55/</url>
    
    <content type="html"><![CDATA[<p>这递归解法仿照了另个做不出来的题的答案：返回所有到根节点路线的list<br>共同点是都要对整个树遍历才能判断最值</p><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span><span class="hljs-params">(object)</span>:</span>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">maxDepth</span><span class="hljs-params">(self, root)</span>:</span>        <span class="hljs-string">"""</span><span class="hljs-string">        :type root: TreeNode</span><span class="hljs-string">        :rtype: int</span><span class="hljs-string">        """</span>        depths = []                <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">searchTree</span><span class="hljs-params">(root, depth)</span>:</span>            depth += <span class="hljs-number">1</span>            <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> root.left <span class="hljs-keyword">and</span> <span class="hljs-keyword">not</span> root.right:                depths.append(depth)                <span class="hljs-keyword">return</span>            <span class="hljs-keyword">if</span> root.left:                searchTree(root.left, depth)            <span class="hljs-keyword">if</span> root.right:                searchTree(root.right, depth)        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> root:            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>        searchTree(root, <span class="hljs-number">0</span>)        <span class="hljs-keyword">return</span> max(depths)</code></pre><p>尝试迭代, 也是抄记忆中之前题的逻辑</p><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span><span class="hljs-params">(object)</span>:</span>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">maxDepth</span><span class="hljs-params">(self, root)</span>:</span>        <span class="hljs-string">"""</span><span class="hljs-string">        :type root: TreeNode</span><span class="hljs-string">        :rtype: int</span><span class="hljs-string">        """</span>        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> root:            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>        max_depth = <span class="hljs-number">0</span>        stack = [(root, <span class="hljs-number">0</span>)]        <span class="hljs-keyword">while</span> stack:            (node, depth) = stack.pop()            depth += <span class="hljs-number">1</span>            <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> node.left <span class="hljs-keyword">and</span> <span class="hljs-keyword">not</span> node.right:                max_depth = max(max_depth, depth)                <span class="hljs-comment"># 这个检查了好一会儿，迭代不能return啊！！！</span>                <span class="hljs-comment"># return</span>                <span class="hljs-keyword">continue</span>            <span class="hljs-comment"># 这个地方又检查好久。 从上边递归方法中抄过来的，所以这样容易疏漏的地方还是写成中性化的形式好</span>            <span class="hljs-comment"># if root.left:</span>            <span class="hljs-keyword">if</span> node.left:                stack.append((node.left, depth))            <span class="hljs-keyword">if</span> node.right:                stack.append((node.right, depth))        <span class="hljs-keyword">return</span> max_depth</code></pre><p>题解看了看，原来有想多了。迭代就是上层为下层左右子树大的那个+1</p>]]></content>
    
    
    <categories>
      
      <category>Leetcode</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Leetcode 226 -</title>
    <link href="/2020/05/12/leetcode-226/"/>
    <url>/2020/05/12/leetcode-226/</url>
    
    <content type="html"><![CDATA[<p>题目：</p><pre><code class="hljs quote">翻转一棵二叉树。</code></pre><p>自己的递归解法，也有很多可优化的点</p><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span><span class="hljs-params">(object)</span>:</span>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">invertTree</span><span class="hljs-params">(self, root)</span>:</span>        <span class="hljs-string">"""</span><span class="hljs-string">        :type root: TreeNode</span><span class="hljs-string">        :rtype: TreeNode</span><span class="hljs-string">        """</span>        <span class="hljs-comment"># Python要把方法引用放到方法定义后边</span>        <span class="hljs-keyword">return</span> helper(root)    <span class="hljs-comment"># 不需要helper，递归直接调用self.invertTree方法</span>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">helper</span><span class="hljs-params">(root)</span>:</span>        <span class="hljs-comment"># 终结条件忘了</span>        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> root:            <span class="hljs-keyword">return</span> <span class="hljs-literal">None</span>        holder = root.right        root.right = root.left        root.left = holder        <span class="hljs-comment"># 终结条件在内层，这里不用if的</span>        <span class="hljs-keyword">if</span> root.left:            helper(root.left)        <span class="hljs-keyword">if</span> root.right:            helper(root.right)        <span class="hljs-keyword">return</span> root</code></pre><p>想写一个迭代的版本，没思路（愁死了），看一下答案，所谓树的迭代就是用个节点栈取代递归</p><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span><span class="hljs-params">(object)</span>:</span>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">invertTree</span><span class="hljs-params">(self, root)</span>:</span>        <span class="hljs-string">"""</span><span class="hljs-string">        :type root: TreeNode</span><span class="hljs-string">        :rtype: TreeNode</span><span class="hljs-string">        """</span>        <span class="hljs-comment">#递归, 要返回None直接return就完了</span>        <span class="hljs-comment"># if not root:</span>        <span class="hljs-comment">#     return </span>        <span class="hljs-comment"># 这种交换连中间值也不需要</span>        <span class="hljs-comment"># root.left, root.right = root.right, root.left</span>        <span class="hljs-comment"># self.invertTree(root.left)</span>        <span class="hljs-comment"># self.invertTree(root.right)</span>        <span class="hljs-comment"># return root</span>        <span class="hljs-comment">#迭代</span>        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> root:            <span class="hljs-keyword">return</span>                stack = [root]        <span class="hljs-keyword">while</span> stack:            node = stack.pop()            <span class="hljs-keyword">if</span> node.left:                stack.append(node.left)            <span class="hljs-keyword">if</span> node.right:                stack.append(node.right)            node.left, node.right = node.right, node.left                <span class="hljs-keyword">return</span> root</code></pre><p>“面试题27. 二叉树的镜像” 和这个是一个题，这次自己写的轻松。 这题前中后序遍历完全一样</p>]]></content>
    
    
    <categories>
      
      <category>Leetcode</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Leetcode 155 - 最小栈</title>
    <link href="/2020/05/12/leetcode-155/"/>
    <url>/2020/05/12/leetcode-155/</url>
    
    <content type="html"><![CDATA[<p>题目：</p><pre><code class="hljs quote">设计一个支持 push ，pop ，top 操作，并能在常数时间内检索到最小元素的栈。push(x) —— 将元素 x 推入栈中。pop() —— 删除栈顶的元素。top() —— 获取栈顶元素。getMin() —— 检索栈中的最小元素。</code></pre><p>这道题的官方解法是用两个栈来实现这个栈，这有微妙</p><p>我自己实现用的链表，其实拿普通列表实现可以的，把节点放在最后一位的位置，记住当前坐标。用另一个列表存当前最小值，一块压栈出栈形式上也更容易些<br>另一点，通过这题训练下python class里self参数怎么用</p><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MinStack</span><span class="hljs-params">(object)</span>:</span>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span><span class="hljs-params">(self)</span>:</span>        <span class="hljs-string">"""</span><span class="hljs-string">        initialize your data structure here.</span><span class="hljs-string">        """</span>        <span class="hljs-comment"># node[0] 当前值value，默认None；node[1] 当前最小值min_value，默认None；node[2] 上一结点指针，默认None；node[3] 下一结点指针，默认None</span>        <span class="hljs-comment"># value = None</span>        <span class="hljs-comment"># min_value = None</span>        <span class="hljs-comment"># prior_node = None</span>        <span class="hljs-comment"># next_node = None</span>        <span class="hljs-comment"># node = [value, min_value, prior_node, next_node]</span>        self.top_node = <span class="hljs-literal">None</span>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">push</span><span class="hljs-params">(self, x)</span>:</span>        <span class="hljs-string">"""</span><span class="hljs-string">        :type x: int</span><span class="hljs-string">        :rtype: None</span><span class="hljs-string">        """</span>        <span class="hljs-keyword">if</span> self.top_node:            <span class="hljs-comment"># 当前存在节点</span>            new_node = [x, min(self.top_node[<span class="hljs-number">1</span>], x), self.top_node, <span class="hljs-literal">None</span>]            self.top_node[<span class="hljs-number">3</span>] = new_node            self.top_node = new_node        <span class="hljs-keyword">else</span>:            <span class="hljs-comment"># 第一个节点</span>            <span class="hljs-comment"># 这个地方查了20分钟的bug，错误写法：new_node = [x, x, None, None]</span>            self.top_node = [x, x, <span class="hljs-literal">None</span>, <span class="hljs-literal">None</span>]    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">pop</span><span class="hljs-params">(self)</span>:</span>        <span class="hljs-string">"""</span><span class="hljs-string">        :rtype: None</span><span class="hljs-string">        """</span>        <span class="hljs-keyword">if</span> self.top_node:            <span class="hljs-keyword">if</span> self.top_node[<span class="hljs-number">2</span>]:                <span class="hljs-comment"># 有节点且有前驱节点</span>                self.top_node = self.top_node[<span class="hljs-number">2</span>]                self.top_node[<span class="hljs-number">3</span>] = <span class="hljs-literal">None</span>            <span class="hljs-keyword">else</span>:                self.top_node = <span class="hljs-literal">None</span>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">top</span><span class="hljs-params">(self)</span>:</span>        <span class="hljs-string">"""</span><span class="hljs-string">        :rtype: int</span><span class="hljs-string">        """</span>        <span class="hljs-keyword">if</span> self.top_node:            <span class="hljs-keyword">return</span> self.top_node[<span class="hljs-number">0</span>]        <span class="hljs-keyword">else</span>:            <span class="hljs-keyword">return</span> <span class="hljs-literal">None</span>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">getMin</span><span class="hljs-params">(self)</span>:</span>        <span class="hljs-string">"""</span><span class="hljs-string">        :rtype: int</span><span class="hljs-string">        """</span>        <span class="hljs-keyword">if</span> self.top_node:            <span class="hljs-keyword">return</span> self.top_node[<span class="hljs-number">1</span>]        <span class="hljs-keyword">else</span>:            <span class="hljs-keyword">return</span> <span class="hljs-literal">None</span><span class="hljs-comment"># Your MinStack object will be instantiated and called as such:</span><span class="hljs-comment"># obj = MinStack()</span><span class="hljs-comment"># obj.push(x)</span><span class="hljs-comment"># obj.pop()</span><span class="hljs-comment"># param_3 = obj.top()</span><span class="hljs-comment"># param_4 = obj.getMin()</span></code></pre>]]></content>
    
    
    <categories>
      
      <category>Leetcode</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Leetcode 50 - Pow(x, n)</title>
    <link href="/2020/05/11/leetcode-50/"/>
    <url>/2020/05/11/leetcode-50/</url>
    
    <content type="html"><![CDATA[<p>题目：</p><pre><code class="hljs quote">实现 pow(x, n) ，即计算 x 的 n 次幂函数。</code></pre><p>前边都是错误解法，想破头。后边才是正确的</p><p>###错误解法1</p><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span><span class="hljs-params">(object)</span>:</span>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">myPow</span><span class="hljs-params">(self, x, n)</span>:</span>        <span class="hljs-string">"""</span><span class="hljs-string">        :type x: float</span><span class="hljs-string">        :type n: int</span><span class="hljs-string">        :rtype: float</span><span class="hljs-string">        """</span>        <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">helper</span><span class="hljs-params">(x, n)</span>:</span>            <span class="hljs-keyword">if</span> n == <span class="hljs-number">0</span>:                <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>            <span class="hljs-keyword">elif</span> n &gt; <span class="hljs-number">0</span>:                <span class="hljs-keyword">return</span> helper(x, n/<span class="hljs-number">2</span>)*helper(x, (n-n/<span class="hljs-number">2</span>))            <span class="hljs-keyword">elif</span> n &lt; <span class="hljs-number">0</span>:                <span class="hljs-keyword">return</span> helper(x, n/<span class="hljs-number">2</span>)/helper(x, (n-n/<span class="hljs-number">2</span>))        <span class="hljs-keyword">return</span> helper(x, n)</code></pre><p>首先想到动态规划，myPow(x, n)=myPow(x, n-m)*myPow(x, m)，状态转换<br>myPow(x, 0) = 1, 这个base case，不论正负值都往这个方向走<br>用迭代试试，分成&gt;0, &lt;0两部分<br>以为写的还行呢，其实是终结条件没判断好，n=1的时候，两个相乘的helper会总有一个以helper(x, 1)深入进去，达到迭代最大值</p><p>###错误解法2</p><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span><span class="hljs-params">(object)</span>:</span>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">myPow</span><span class="hljs-params">(self, x, n)</span>:</span>        <span class="hljs-string">"""</span><span class="hljs-string">        :type x: float</span><span class="hljs-string">        :type n: int</span><span class="hljs-string">        :rtype: float</span><span class="hljs-string">        """</span>            <span class="hljs-comment"># 真正的思路是将奇偶两种情况分开处理，偶数就一直除以2，奇数是先减1再一直除以2</span>            <span class="hljs-keyword">if</span> n == <span class="hljs-number">0</span>:                <span class="hljs-keyword">return</span> <span class="hljs-number">1.0</span>            <span class="hljs-keyword">elif</span> n &gt; <span class="hljs-number">0</span>:                <span class="hljs-keyword">if</span> n%<span class="hljs-number">2</span> == <span class="hljs-number">0</span>:                    <span class="hljs-keyword">return</span> helper(x, n/<span class="hljs-number">2</span>)**<span class="hljs-number">2</span>                <span class="hljs-keyword">elif</span> n%<span class="hljs-number">2</span> == <span class="hljs-number">1</span>:                    <span class="hljs-keyword">return</span> helper(x, n/<span class="hljs-number">2</span>)**<span class="hljs-number">2</span>*x**<span class="hljs-number">1</span>            <span class="hljs-keyword">elif</span> n &lt; <span class="hljs-number">0</span>:                <span class="hljs-keyword">if</span> n%<span class="hljs-number">2</span> == <span class="hljs-number">0</span>:                    <span class="hljs-keyword">print</span> n                    <span class="hljs-keyword">return</span> helper(x, abs(n)/<span class="hljs-number">2</span>)**<span class="hljs-number">-2</span>                <span class="hljs-keyword">elif</span> n%<span class="hljs-number">2</span> == <span class="hljs-number">-1</span>:                    <span class="hljs-keyword">return</span> helper(x, abs(n)/<span class="hljs-number">2</span>)**<span class="hljs-number">-2</span>*x**<span class="hljs-number">-1</span>        <span class="hljs-keyword">return</span> helper(x, n)</code></pre><p>34.00512<br>-3<br>很多测试用例过得去，但是这个过不去报错，搞不懂，估计是负数情况下除的时候是算上0来保留整数的。写的很繁琐，还错</p><pre><code class="hljs code">TypeError: None is not valid value for the expected return type double    raise TypeError(str(ret) + &quot; is not valid value for the expected return type double&quot;);Line 67 in _driver (Solution.py)    _driver()Line 73 in &lt;module&gt; (Solution.py)</code></pre><p>###以下正确答案</p><p>参考了别人答案才会了，可以变形：x的n次方=(1/x)的-n次方，用这个把负数n变正数。另外本不需要helper方法</p><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span><span class="hljs-params">(object)</span>:</span>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">myPow</span><span class="hljs-params">(self, x, n)</span>:</span>        <span class="hljs-string">"""</span><span class="hljs-string">        :type x: float</span><span class="hljs-string">        :type n: int</span><span class="hljs-string">        :rtype: float</span><span class="hljs-string">        """</span>        <span class="hljs-keyword">if</span> n == <span class="hljs-number">0</span>:            <span class="hljs-keyword">return</span> <span class="hljs-number">1.0</span>        <span class="hljs-keyword">if</span> n &lt; <span class="hljs-number">0</span>:            x = <span class="hljs-number">1</span>/x            n = -n        <span class="hljs-keyword">if</span> n%<span class="hljs-number">2</span> == <span class="hljs-number">0</span>:            <span class="hljs-keyword">return</span> self.myPow(x, n/<span class="hljs-number">2</span>)**<span class="hljs-number">2</span>        <span class="hljs-keyword">elif</span> n%<span class="hljs-number">2</span> == <span class="hljs-number">1</span>:            <span class="hljs-keyword">return</span> self.myPow(x, n/<span class="hljs-number">2</span>)**<span class="hljs-number">2</span>*x</code></pre><p>这块还可以优化，进入子迭代前平方，而不要返回时平方，更易读，效率上差不多</p><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span><span class="hljs-params">(object)</span>:</span>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">myPow</span><span class="hljs-params">(self, x, n)</span>:</span>        <span class="hljs-string">"""</span><span class="hljs-string">        :type x: float</span><span class="hljs-string">        :type n: int</span><span class="hljs-string">        :rtype: float</span><span class="hljs-string">        """</span>        <span class="hljs-keyword">if</span> n == <span class="hljs-number">0</span>:            <span class="hljs-keyword">return</span> <span class="hljs-number">1.0</span>        <span class="hljs-keyword">if</span> n &lt; <span class="hljs-number">0</span>:            x = <span class="hljs-number">1</span>/x            n = -n        <span class="hljs-keyword">if</span> n%<span class="hljs-number">2</span> == <span class="hljs-number">0</span>:            <span class="hljs-keyword">return</span> self.myPow(x**<span class="hljs-number">2</span>, n/<span class="hljs-number">2</span>)        <span class="hljs-keyword">elif</span> n%<span class="hljs-number">2</span> == <span class="hljs-number">1</span>:            <span class="hljs-keyword">return</span> self.myPow(x**<span class="hljs-number">2</span>, n/<span class="hljs-number">2</span>)*x</code></pre>]]></content>
    
    
    <categories>
      
      <category>Leetcode</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Leetcode 1287 - 有序数组中出现次数超过25%的元素</title>
    <link href="/2020/05/09/leetcode-1287/"/>
    <url>/2020/05/09/leetcode-1287/</url>
    
    <content type="html"><![CDATA[<p>题目：</p><pre><code class="hljs quote">给你一个非递减的有序整数数组，已知这个数组中恰好有一个整数，它的出现次数超过数组元素总数的 25%。请你找到并返回这个整数</code></pre><p>这道题是解的最顺的，自己的解法如下：</p><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span><span class="hljs-params">(object)</span>:</span>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">findSpecialInteger</span><span class="hljs-params">(self, arr)</span>:</span>        <span class="hljs-string">"""</span><span class="hljs-string">        :type arr: List[int]</span><span class="hljs-string">        :rtype: int</span><span class="hljs-string">        """</span>        map = &#123;key:<span class="hljs-number">0</span> <span class="hljs-keyword">for</span> key <span class="hljs-keyword">in</span> set(arr)&#125;        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(len(arr)):            map[arr[i]] += <span class="hljs-number">1</span>        <span class="hljs-keyword">for</span> k,v <span class="hljs-keyword">in</span> map.items():            <span class="hljs-keyword">if</span> <span class="hljs-number">4</span>*v &gt; len(arr):                <span class="hljs-keyword">return</span> k</code></pre><p>这里边的第二个for循环其实可以不要, 只要在第一个for循环里，每步判断下是否已超过25%就行</p><p><strong>重点</strong>在这里。超过25%，就感觉应该用二分查找，但是没什么直接思路<br><a href="https://leetcode-cn.com/problems/element-appearing-more-than-25-in-sorted-array/solution/" target="_blank" rel="noopener">Leetcode网站</a>提供了解法</p><ol><li>反证法证明解一定出现在开始、1/4，1/2，3/4的指针位置</li><li>python里用了bisect.bisect_left这种方法去寻找指针位置值在左右的范围</li><li>range(x, y, z) 是在[x,y)左开右闭区间内以z步长迭代</li></ol><p>时间复杂度从O(N)降到O(LogN)了<br>回头自己实现一下</p>]]></content>
    
    
    <categories>
      
      <category>Leetcode</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Leetcode 69 - x的平方根</title>
    <link href="/2020/05/09/leetcode-69/"/>
    <url>/2020/05/09/leetcode-69/</url>
    
    <content type="html"><![CDATA[<p>题目：</p><pre><code class="hljs quote">实现 int sqrt(int x) 函数。计算并返回 x 的平方根，其中 x 是非负整数。由于返回类型是整数，结果只保留整数的部分，小数部分将被舍去。来源：力扣（LeetCode）链接：https:&#x2F;&#x2F;leetcode-cn.com&#x2F;problems&#x2F;sqrtx著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</code></pre><p>写了3种方法</p><ol><li><p>单步加1速度太慢, 写的时候根本没想效率的事</p><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span><span class="hljs-params">(object)</span>:</span>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">mySqrt</span><span class="hljs-params">(self, x)</span>:</span>        <span class="hljs-string">"""</span><span class="hljs-string">        :type x: int</span><span class="hljs-string">        :rtype: int</span><span class="hljs-string">        """</span>        y = <span class="hljs-number">0</span>        <span class="hljs-keyword">while</span> y*y &lt;= x:            y+=<span class="hljs-number">1</span>        <span class="hljs-keyword">return</span> y<span class="hljs-number">-1</span></code></pre></li><li><p>二分查找, 自己想了一大顿关联到了，写的过于繁琐，设置四种判断条件人为变得困难</p><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span><span class="hljs-params">(object)</span>:</span>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">mySqrt</span><span class="hljs-params">(self, x)</span>:</span>        <span class="hljs-string">"""</span><span class="hljs-string">        :type x: int</span><span class="hljs-string">        :rtype: int</span><span class="hljs-string">        """</span>        <span class="hljs-comment"># 临界条件设置的好傻</span>        <span class="hljs-keyword">if</span> x == <span class="hljs-number">0</span>:            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>        <span class="hljs-keyword">if</span> x == <span class="hljs-number">1</span>:            <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>            left, right = <span class="hljs-number">0</span>, x         <span class="hljs-keyword">while</span> left &lt;= right:            <span class="hljs-comment"># 取整应该用//</span>            mid = left + (right - left)/<span class="hljs-number">2</span>            <span class="hljs-comment"># 指数是**，不是^（按二进制位异或运算）</span>            <span class="hljs-keyword">if</span> mid**<span class="hljs-number">2</span> &lt;= x <span class="hljs-keyword">and</span> (mid+<span class="hljs-number">1</span>)**<span class="hljs-number">2</span> &gt; x:                <span class="hljs-keyword">return</span> mid            <span class="hljs-keyword">elif</span> mid**<span class="hljs-number">2</span> &lt;= x <span class="hljs-keyword">and</span> (mid+<span class="hljs-number">1</span>)**<span class="hljs-number">2</span> &lt;= x:                left = mid            <span class="hljs-keyword">elif</span> mid**<span class="hljs-number">2</span> &gt; x <span class="hljs-keyword">and</span> (mid<span class="hljs-number">-1</span>)**<span class="hljs-number">2</span> &lt;= x:                <span class="hljs-comment"># 返还忘了减1</span>                <span class="hljs-keyword">return</span> mid<span class="hljs-number">-1</span>            <span class="hljs-keyword">elif</span> mid**<span class="hljs-number">2</span> &gt; x <span class="hljs-keyword">and</span> (mid<span class="hljs-number">-1</span>)**<span class="hljs-number">2</span> &gt; x:                right = mid</code></pre></li><li><p>简单版二分查找，正确答案默写</p><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span><span class="hljs-params">(object)</span>:</span>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">mySqrt</span><span class="hljs-params">(self, x)</span>:</span>        <span class="hljs-string">"""</span><span class="hljs-string">        :type x: int</span><span class="hljs-string">        :rtype: int</span><span class="hljs-string">        """</span>        l, r, res = <span class="hljs-number">0</span>, x, <span class="hljs-number">-1</span>        <span class="hljs-keyword">while</span> l &lt;= r:            mid = l + (r - l)/<span class="hljs-number">2</span>            <span class="hljs-keyword">if</span> mid**<span class="hljs-number">2</span> &lt;= x:                res = mid                l = mid + <span class="hljs-number">1</span>            <span class="hljs-keyword">elif</span> mid**<span class="hljs-number">2</span> &gt; x:                r = mid - <span class="hljs-number">1</span>        <span class="hljs-comment"># 保存唯一正确位置到最后返回就行</span>        <span class="hljs-keyword">return</span> res</code></pre></li></ol>]]></content>
    
    
    <categories>
      
      <category>Leetcode</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Hexo部署</title>
    <link href="/2020/05/09/Hexo-Manual/"/>
    <url>/2020/05/09/Hexo-Manual/</url>
    
    <content type="html"><![CDATA[<p>重新安装Hexo，已经时隔三年。虽然很多事情缠身，不过简单探索的快乐还在。Github Page还能使用，但是Hexo本身已经完全不同了。代码库被我完全的重写掉，使用的<a href="https://github.com/theme-next/hexo-theme-next" target="_blank" rel="noopener">Next主题</a></p><p>通过配置文件向github page库推送需要安装</p><pre><code class="hljs bash">$ npm install hexo-deployer-git --save</code></pre><p>明天再熟悉下Markdown语法，写我自己的好东西</p><h3 id="三天后"><a href="#三天后" class="headerlink" title="三天后"></a>三天后</h3><p>在windows上配置hexo, 才发现github上只有打包好的静态网站，配置、主题、写的文字全没上传。官网说法，想想也对，回头抄一抄别人的hexo文件管理方式。<a href="https://hexo.io/zh-cn/docs/one-command-deployment" target="_blank" rel="noopener">“由于 Hexo 的部署默认使用分支 master，所以如果你同时正在使用 Git 管理你的站点目录，你应当注意你的部署分支应当不同于写作分支。<br>一个好的实践是将站点目录和 Pages 分别存放在两个不同的 Git 仓库中，可以有效避免相互覆盖。<br>Hexo 在部署你的站点生成的文件时并不会更新你的站点目录。因此你应该手动提交并推送你的写作分支。”</a></p><p>Next分支坏了，显示Null。直接换成了<a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="noopener">Fluid高级主题</a></p>]]></content>
    
    
    <categories>
      
      <category>Tools</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Hello World</title>
    <link href="/2020/05/09/hello-world/"/>
    <url>/2020/05/09/hello-world/</url>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><pre><code class="hljs bash">$ hexo new <span class="hljs-string">"My New Post"</span></code></pre><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><pre><code class="hljs bash">$ hexo server</code></pre><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><pre><code class="hljs bash">$ hexo generate</code></pre><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><pre><code class="hljs bash">$ hexo deploy</code></pre><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html" target="_blank" rel="noopener">Deployment</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  
</search>
